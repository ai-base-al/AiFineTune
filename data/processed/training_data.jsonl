{"prompt": "Create a Flutter Flame game component that ConstantVolumeJoint¶: It can for example be useful when simulating “soft-bodies”.", "completion": "import 'dart:math';\n\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boundaries.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\n\nclass ConstantVolumeJointExample extends Forge2DGame {\nstatic const description = '''\nThis example shows how to use a `ConstantVolumeJoint`. Tap the screen to add\na bunch off balls, that maintain a constant volume within them.\n''';\n\nConstantVolumeJointExample() : super(world: SpriteBodyWorld());\n}\n\nclass SpriteBodyWorld extends Forge2DWorld\nwith TapCallbacks, HasGameReference<Forge2DGame> {\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\naddAll(createBoundaries(game));\n}\n\n@override\nFuture<void> onTapDown(TapDownEvent info) async {\nsuper.onTapDown(info);\nfinal center = info.localPosition;\n\nconst numPieces = 20;\nconst radius = 5.0;\nfinal balls = <Ball>[];\n\nfor (var i = 0; i < numPieces; i++) {\nfinal x = radius * cos(2 * pi * (i / numPieces));\nfinal y = radius * sin(2 * pi * (i / numPieces));\n\nfinal ball = Ball(Vector2(x + center.x, y + center.y), radius: 0.5);\n\nadd(ball);\nballs.add(ball);\n}\n\nawait Future.wait(balls.map((e) => e.loaded));\n\nfinal constantVolumeJoint = ConstantVolumeJointDef()\n..frequencyHz = 10\n..dampingRatio = 0.8;\n\nballs.forEach((ball) {\nconstantVolumeJoint.addBody(ball.body);\n});\n\ncreateJoint(\nConstantVolumeJoint(\nphysicsWorld,\nconstantVolumeJoint,\n),\n);\n}\n}"}
{"prompt": "Show me how to implement ConstantVolumeJoint¶: It can for example be useful when simulating “soft-bodies”. using Flutter Flame", "completion": "import 'dart:math';\n\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boundaries.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\n\nclass ConstantVolumeJointExample extends Forge2DGame {\nstatic const description = '''\nThis example shows how to use a `ConstantVolumeJoint`. Tap the screen to add\na bunch off balls, that maintain a constant volume within them.\n''';\n\nConstantVolumeJointExample() : super(world: SpriteBodyWorld());\n}\n\nclass SpriteBodyWorld extends Forge2DWorld\nwith TapCallbacks, HasGameReference<Forge2DGame> {\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\naddAll(createBoundaries(game));\n}\n\n@override\nFuture<void> onTapDown(TapDownEvent info) async {\nsuper.onTapDown(info);\nfinal center = info.localPosition;\n\nconst numPieces = 20;\nconst radius = 5.0;\nfinal balls = <Ball>[];\n\nfor (var i = 0; i < numPieces; i++) {\nfinal x = radius * cos(2 * pi * (i / numPieces));\nfinal y = radius * sin(2 * pi * (i / numPieces));\n\nfinal ball = Ball(Vector2(x + center.x, y + center.y), radius: 0.5);\n\nadd(ball);\nballs.add(ball);\n}\n\nawait Future.wait(balls.map((e) => e.loaded));\n\nfinal constantVolumeJoint = ConstantVolumeJointDef()\n..frequencyHz = 10\n..dampingRatio = 0.8;\n\nballs.forEach((ball) {\nconstantVolumeJoint.addBody(ball.body);\n});\n\ncreateJoint(\nConstantVolumeJoint(\nphysicsWorld,\nconstantVolumeJoint,\n),\n);\n}\n}"}
{"prompt": "Write Flutter Flame code to ConstantVolumeJoint¶: It can for example be useful when simulating “soft-bodies”.", "completion": "import 'dart:math';\n\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boundaries.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\n\nclass ConstantVolumeJointExample extends Forge2DGame {\nstatic const description = '''\nThis example shows how to use a `ConstantVolumeJoint`. Tap the screen to add\na bunch off balls, that maintain a constant volume within them.\n''';\n\nConstantVolumeJointExample() : super(world: SpriteBodyWorld());\n}\n\nclass SpriteBodyWorld extends Forge2DWorld\nwith TapCallbacks, HasGameReference<Forge2DGame> {\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\naddAll(createBoundaries(game));\n}\n\n@override\nFuture<void> onTapDown(TapDownEvent info) async {\nsuper.onTapDown(info);\nfinal center = info.localPosition;\n\nconst numPieces = 20;\nconst radius = 5.0;\nfinal balls = <Ball>[];\n\nfor (var i = 0; i < numPieces; i++) {\nfinal x = radius * cos(2 * pi * (i / numPieces));\nfinal y = radius * sin(2 * pi * (i / numPieces));\n\nfinal ball = Ball(Vector2(x + center.x, y + center.y), radius: 0.5);\n\nadd(ball);\nballs.add(ball);\n}\n\nawait Future.wait(balls.map((e) => e.loaded));\n\nfinal constantVolumeJoint = ConstantVolumeJointDef()\n..frequencyHz = 10\n..dampingRatio = 0.8;\n\nballs.forEach((ball) {\nconstantVolumeJoint.addBody(ball.body);\n});\n\ncreateJoint(\nConstantVolumeJoint(\nphysicsWorld,\nconstantVolumeJoint,\n),\n);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that DistanceJoint¶: You can view this as a massless, rigid rod.", "completion": "import 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boundaries.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\n\nclass DistanceJointExample extends Forge2DGame {\nstatic const description = '''\nThis example shows how to use a `DistanceJoint`. Tap the screen to add a\npair of balls joined with a `DistanceJoint`.\n''';\n\nDistanceJointExample() : super(world: DistanceJointWorld());\n}\n\nclass DistanceJointWorld extends Forge2DWorld\nwith TapCallbacks, HasGameReference<Forge2DGame> {\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\naddAll(createBoundaries(game));\n}\n\n@override\nFuture<void> onTapDown(TapDownEvent info) async {\nsuper.onTapDown(info);\nfinal tap = info.localPosition;\n\nfinal first = Ball(tap);\nfinal second = Ball(Vector2(tap.x + 3, tap.y + 3));\naddAll([first, second]);\n\nawait Future.wait([first.loaded, second.loaded]);\n\nfinal distanceJointDef = DistanceJointDef()\n..initialize(\nfirst.body,\nsecond.body,\nfirst.body.worldCenter,\nsecond.center,\n)\n..length = 10\n..frequencyHz = 3\n..dampingRatio = 0.2;\n\ncreateJoint(DistanceJoint(distanceJointDef));\n}\n}"}
{"prompt": "Show me how to implement DistanceJoint¶: You can view this as a massless, rigid rod. using Flutter Flame", "completion": "import 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boundaries.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\n\nclass DistanceJointExample extends Forge2DGame {\nstatic const description = '''\nThis example shows how to use a `DistanceJoint`. Tap the screen to add a\npair of balls joined with a `DistanceJoint`.\n''';\n\nDistanceJointExample() : super(world: DistanceJointWorld());\n}\n\nclass DistanceJointWorld extends Forge2DWorld\nwith TapCallbacks, HasGameReference<Forge2DGame> {\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\naddAll(createBoundaries(game));\n}\n\n@override\nFuture<void> onTapDown(TapDownEvent info) async {\nsuper.onTapDown(info);\nfinal tap = info.localPosition;\n\nfinal first = Ball(tap);\nfinal second = Ball(Vector2(tap.x + 3, tap.y + 3));\naddAll([first, second]);\n\nawait Future.wait([first.loaded, second.loaded]);\n\nfinal distanceJointDef = DistanceJointDef()\n..initialize(\nfirst.body,\nsecond.body,\nfirst.body.worldCenter,\nsecond.center,\n)\n..length = 10\n..frequencyHz = 3\n..dampingRatio = 0.2;\n\ncreateJoint(DistanceJoint(distanceJointDef));\n}\n}"}
{"prompt": "Write Flutter Flame code to DistanceJoint¶: You can view this as a massless, rigid rod.", "completion": "import 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boundaries.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\n\nclass DistanceJointExample extends Forge2DGame {\nstatic const description = '''\nThis example shows how to use a `DistanceJoint`. Tap the screen to add a\npair of balls joined with a `DistanceJoint`.\n''';\n\nDistanceJointExample() : super(world: DistanceJointWorld());\n}\n\nclass DistanceJointWorld extends Forge2DWorld\nwith TapCallbacks, HasGameReference<Forge2DGame> {\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\naddAll(createBoundaries(game));\n}\n\n@override\nFuture<void> onTapDown(TapDownEvent info) async {\nsuper.onTapDown(info);\nfinal tap = info.localPosition;\n\nfinal first = Ball(tap);\nfinal second = Ball(Vector2(tap.x + 3, tap.y + 3));\naddAll([first, second]);\n\nawait Future.wait([first.loaded, second.loaded]);\n\nfinal distanceJointDef = DistanceJointDef()\n..initialize(\nfirst.body,\nsecond.body,\nfirst.body.worldCenter,\nsecond.center,\n)\n..length = 10\n..frequencyHz = 3\n..dampingRatio = 0.2;\n\ncreateJoint(DistanceJoint(distanceJointDef));\n}\n}"}
{"prompt": "Create a Flutter Flame game component that FrictionJoint¶: The third parameter is the anchor point in the world coordinates where the friction force will be applied. In most cases, it would be the center of the first object. However, for more complex physics interactions between bodies, you can set the anchor point to a specific location on one or both of the bodies.", "completion": "import 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boundaries.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\n\nclass FrictionJointExample extends Forge2DGame {\nstatic const description = '''\nThis example shows how to use a `FrictionJoint`. Tap the screen to move the\nball around and observe it slows down due to the friction force.\n''';\n\nFrictionJointExample()\n: super(gravity: Vector2.all(0), world: FrictionJointWorld());\n}\n\nclass FrictionJointWorld extends Forge2DWorld\nwith TapCallbacks, HasGameReference<Forge2DGame> {\nlate Wall border;\nlate Ball ball;\n\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\nfinal boundaries = createBoundaries(game);\nborder = boundaries.first;\naddAll(boundaries);\n\nball = Ball(Vector2.zero(), radius: 3);\nadd(ball);\n\nawait Future.wait([ball.loaded, border.loaded]);\n\ncreateFrictionJoint(ball.body, border.body);\n}\n\n@override\nFuture<void> onTapDown(TapDownEvent info) async {\nsuper.onTapDown(info);\nball.body.applyLinearImpulse(Vector2.random() * 5000);\n}\n\nvoid createFrictionJoint(Body first, Body second) {\nfinal frictionJointDef = FrictionJointDef()\n..initialize(first, second, first.worldCenter)\n..collideConnected = true\n..maxForce = 500\n..maxTorque = 500;\n\ncreateJoint(FrictionJoint(frictionJointDef));\n}\n}"}
{"prompt": "Show me how to implement FrictionJoint¶: The third parameter is the anchor point in the world coordinates where the friction force will be applied. In most cases, it would be the center of the first object. However, for more complex physics interactions between bodies, you can set the anchor point to a specific location on one or both of the bodies. using Flutter Flame", "completion": "import 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boundaries.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\n\nclass FrictionJointExample extends Forge2DGame {\nstatic const description = '''\nThis example shows how to use a `FrictionJoint`. Tap the screen to move the\nball around and observe it slows down due to the friction force.\n''';\n\nFrictionJointExample()\n: super(gravity: Vector2.all(0), world: FrictionJointWorld());\n}\n\nclass FrictionJointWorld extends Forge2DWorld\nwith TapCallbacks, HasGameReference<Forge2DGame> {\nlate Wall border;\nlate Ball ball;\n\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\nfinal boundaries = createBoundaries(game);\nborder = boundaries.first;\naddAll(boundaries);\n\nball = Ball(Vector2.zero(), radius: 3);\nadd(ball);\n\nawait Future.wait([ball.loaded, border.loaded]);\n\ncreateFrictionJoint(ball.body, border.body);\n}\n\n@override\nFuture<void> onTapDown(TapDownEvent info) async {\nsuper.onTapDown(info);\nball.body.applyLinearImpulse(Vector2.random() * 5000);\n}\n\nvoid createFrictionJoint(Body first, Body second) {\nfinal frictionJointDef = FrictionJointDef()\n..initialize(first, second, first.worldCenter)\n..collideConnected = true\n..maxForce = 500\n..maxTorque = 500;\n\ncreateJoint(FrictionJoint(frictionJointDef));\n}\n}"}
{"prompt": "Write Flutter Flame code to FrictionJoint¶: The third parameter is the anchor point in the world coordinates where the friction force will be applied. In most cases, it would be the center of the first object. However, for more complex physics interactions between bodies, you can set the anchor point to a specific location on one or both of the bodies.", "completion": "import 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boundaries.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\n\nclass FrictionJointExample extends Forge2DGame {\nstatic const description = '''\nThis example shows how to use a `FrictionJoint`. Tap the screen to move the\nball around and observe it slows down due to the friction force.\n''';\n\nFrictionJointExample()\n: super(gravity: Vector2.all(0), world: FrictionJointWorld());\n}\n\nclass FrictionJointWorld extends Forge2DWorld\nwith TapCallbacks, HasGameReference<Forge2DGame> {\nlate Wall border;\nlate Ball ball;\n\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\nfinal boundaries = createBoundaries(game);\nborder = boundaries.first;\naddAll(boundaries);\n\nball = Ball(Vector2.zero(), radius: 3);\nadd(ball);\n\nawait Future.wait([ball.loaded, border.loaded]);\n\ncreateFrictionJoint(ball.body, border.body);\n}\n\n@override\nFuture<void> onTapDown(TapDownEvent info) async {\nsuper.onTapDown(info);\nball.body.applyLinearImpulse(Vector2.random() * 5000);\n}\n\nvoid createFrictionJoint(Body first, Body second) {\nfinal frictionJointDef = FrictionJointDef()\n..initialize(first, second, first.worldCenter)\n..collideConnected = true\n..maxForce = 500\n..maxTorque = 500;\n\ncreateJoint(FrictionJoint(frictionJointDef));\n}\n}"}
{"prompt": "Create a Flutter Flame game component that GearJoint¶: The connected joints must attach a dynamic body to a static body. The static body is expected to be a bodyA on those joints", "completion": "import 'dart:ui';\n\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boxes.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\n\nclass GearJointExample extends Forge2DGame {\nstatic const description = '''\nThis example shows how to use a `GearJoint`.\n\nDrag the box along the specified axis and observe gears respond to the\ntranslation.\n''';\n\nGearJointExample() : super(world: GearJointWorld());\n}\n\nclass GearJointWorld extends Forge2DWorld with HasGameReference<Forge2DGame> {\nlate PrismaticJoint prismaticJoint;\nVector2 boxAnchor = Vector2.zero();\n\ndouble boxWidth = 2;\ndouble ball1Radius = 4;\ndouble ball2Radius = 2;\n\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\n\nfinal box =\nDraggableBox(startPosition: boxAnchor, width: boxWidth, height: 20);\nadd(box);\n\nfinal ball1Anchor = boxAnchor - Vector2(boxWidth / 2 + ball1Radius, 0);\nfinal ball1 = Ball(ball1Anchor, radius: ball1Radius);\nadd(ball1);\n\nfinal ball2Anchor = ball1Anchor - Vector2(ball1Radius + ball2Radius, 0);\nfinal ball2 = Ball(ball2Anchor, radius: ball2Radius);\nadd(ball2);\n\nawait Future.wait([box.loaded, ball1.loaded, ball2.loaded]);\n\nprismaticJoint = createPrismaticJoint(box.body, boxAnchor);\nfinal revoluteJoint1 = createRevoluteJoint(ball1.body, ball1Anchor);\nfinal revoluteJoint2 = createRevoluteJoint(ball2.body, ball2Anchor);\n\ncreateGearJoint(prismaticJoint, revoluteJoint1, 1);\ncreateGearJoint(revoluteJoint1, revoluteJoint2, 0.5);\nadd(JointRenderer(joint: prismaticJoint, anchor: boxAnchor));\n}\n\nPrismaticJoint createPrismaticJoint(Body box, Vector2 anchor) {\nfinal groundBody = createBody(BodyDef());\n\nfinal prismaticJointDef = PrismaticJointDef()\n..initialize(\ngroundBody,\nbox,\nanchor,\nVector2(0, 1),\n)\n..enableLimit = true\n..lowerTranslation = -10\n..upperTranslation = 10;\n\nfinal joint = PrismaticJoint(prismaticJointDef);\ncreateJoint(joint);\nreturn joint;\n}\n\nRevoluteJoint createRevoluteJoint(Body ball, Vector2 anchor) {\nfinal groundBody = createBody(BodyDef());\n\nfinal revoluteJointDef = RevoluteJointDef()\n..initialize(\ngroundBody,\nball,\nanchor,\n);\n\nfinal joint = RevoluteJoint(revoluteJointDef);\ncreateJoint(joint);\nreturn joint;\n}\n\nvoid createGearJoint(Joint first, Joint second, double gearRatio) {\nfinal gearJointDef = GearJointDef()\n..bodyA = first.bodyA\n..bodyB = second.bodyA\n..joint1 = first\n..joint2 = second\n..ratio = gearRatio;\n\nfinal joint = GearJoint(gearJointDef);\ncreateJoint(joint);\n}\n}\n\nclass JointRenderer extends Component {\nJointRenderer({required this.joint, required this.anchor});\n\nfinal PrismaticJoint joint;\nfinal Vector2 anchor;\nfinal Vector2 p1 = Vector2.zero();\nfinal Vector2 p2 = Vector2.zero();\n\n@override\nvoid render(Canvas canvas) {\np1\n..setFrom(joint.getLocalAxisA())\n..scale(joint.getLowerLimit())\n..add(anchor);\np2\n..setFrom(joint.getLocalAxisA())\n..scale(joint.getUpperLimit())\n..add(anchor);\n\ncanvas.drawLine(p1.toOffset(), p2.toOffset(), debugPaint);\n}\n}"}
{"prompt": "Show me how to implement GearJoint¶: The connected joints must attach a dynamic body to a static body. The static body is expected to be a bodyA on those joints using Flutter Flame", "completion": "import 'dart:ui';\n\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boxes.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\n\nclass GearJointExample extends Forge2DGame {\nstatic const description = '''\nThis example shows how to use a `GearJoint`.\n\nDrag the box along the specified axis and observe gears respond to the\ntranslation.\n''';\n\nGearJointExample() : super(world: GearJointWorld());\n}\n\nclass GearJointWorld extends Forge2DWorld with HasGameReference<Forge2DGame> {\nlate PrismaticJoint prismaticJoint;\nVector2 boxAnchor = Vector2.zero();\n\ndouble boxWidth = 2;\ndouble ball1Radius = 4;\ndouble ball2Radius = 2;\n\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\n\nfinal box =\nDraggableBox(startPosition: boxAnchor, width: boxWidth, height: 20);\nadd(box);\n\nfinal ball1Anchor = boxAnchor - Vector2(boxWidth / 2 + ball1Radius, 0);\nfinal ball1 = Ball(ball1Anchor, radius: ball1Radius);\nadd(ball1);\n\nfinal ball2Anchor = ball1Anchor - Vector2(ball1Radius + ball2Radius, 0);\nfinal ball2 = Ball(ball2Anchor, radius: ball2Radius);\nadd(ball2);\n\nawait Future.wait([box.loaded, ball1.loaded, ball2.loaded]);\n\nprismaticJoint = createPrismaticJoint(box.body, boxAnchor);\nfinal revoluteJoint1 = createRevoluteJoint(ball1.body, ball1Anchor);\nfinal revoluteJoint2 = createRevoluteJoint(ball2.body, ball2Anchor);\n\ncreateGearJoint(prismaticJoint, revoluteJoint1, 1);\ncreateGearJoint(revoluteJoint1, revoluteJoint2, 0.5);\nadd(JointRenderer(joint: prismaticJoint, anchor: boxAnchor));\n}\n\nPrismaticJoint createPrismaticJoint(Body box, Vector2 anchor) {\nfinal groundBody = createBody(BodyDef());\n\nfinal prismaticJointDef = PrismaticJointDef()\n..initialize(\ngroundBody,\nbox,\nanchor,\nVector2(0, 1),\n)\n..enableLimit = true\n..lowerTranslation = -10\n..upperTranslation = 10;\n\nfinal joint = PrismaticJoint(prismaticJointDef);\ncreateJoint(joint);\nreturn joint;\n}\n\nRevoluteJoint createRevoluteJoint(Body ball, Vector2 anchor) {\nfinal groundBody = createBody(BodyDef());\n\nfinal revoluteJointDef = RevoluteJointDef()\n..initialize(\ngroundBody,\nball,\nanchor,\n);\n\nfinal joint = RevoluteJoint(revoluteJointDef);\ncreateJoint(joint);\nreturn joint;\n}\n\nvoid createGearJoint(Joint first, Joint second, double gearRatio) {\nfinal gearJointDef = GearJointDef()\n..bodyA = first.bodyA\n..bodyB = second.bodyA\n..joint1 = first\n..joint2 = second\n..ratio = gearRatio;\n\nfinal joint = GearJoint(gearJointDef);\ncreateJoint(joint);\n}\n}\n\nclass JointRenderer extends Component {\nJointRenderer({required this.joint, required this.anchor});\n\nfinal PrismaticJoint joint;\nfinal Vector2 anchor;\nfinal Vector2 p1 = Vector2.zero();\nfinal Vector2 p2 = Vector2.zero();\n\n@override\nvoid render(Canvas canvas) {\np1\n..setFrom(joint.getLocalAxisA())\n..scale(joint.getLowerLimit())\n..add(anchor);\np2\n..setFrom(joint.getLocalAxisA())\n..scale(joint.getUpperLimit())\n..add(anchor);\n\ncanvas.drawLine(p1.toOffset(), p2.toOffset(), debugPaint);\n}\n}"}
{"prompt": "Write Flutter Flame code to GearJoint¶: The connected joints must attach a dynamic body to a static body. The static body is expected to be a bodyA on those joints", "completion": "import 'dart:ui';\n\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boxes.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\n\nclass GearJointExample extends Forge2DGame {\nstatic const description = '''\nThis example shows how to use a `GearJoint`.\n\nDrag the box along the specified axis and observe gears respond to the\ntranslation.\n''';\n\nGearJointExample() : super(world: GearJointWorld());\n}\n\nclass GearJointWorld extends Forge2DWorld with HasGameReference<Forge2DGame> {\nlate PrismaticJoint prismaticJoint;\nVector2 boxAnchor = Vector2.zero();\n\ndouble boxWidth = 2;\ndouble ball1Radius = 4;\ndouble ball2Radius = 2;\n\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\n\nfinal box =\nDraggableBox(startPosition: boxAnchor, width: boxWidth, height: 20);\nadd(box);\n\nfinal ball1Anchor = boxAnchor - Vector2(boxWidth / 2 + ball1Radius, 0);\nfinal ball1 = Ball(ball1Anchor, radius: ball1Radius);\nadd(ball1);\n\nfinal ball2Anchor = ball1Anchor - Vector2(ball1Radius + ball2Radius, 0);\nfinal ball2 = Ball(ball2Anchor, radius: ball2Radius);\nadd(ball2);\n\nawait Future.wait([box.loaded, ball1.loaded, ball2.loaded]);\n\nprismaticJoint = createPrismaticJoint(box.body, boxAnchor);\nfinal revoluteJoint1 = createRevoluteJoint(ball1.body, ball1Anchor);\nfinal revoluteJoint2 = createRevoluteJoint(ball2.body, ball2Anchor);\n\ncreateGearJoint(prismaticJoint, revoluteJoint1, 1);\ncreateGearJoint(revoluteJoint1, revoluteJoint2, 0.5);\nadd(JointRenderer(joint: prismaticJoint, anchor: boxAnchor));\n}\n\nPrismaticJoint createPrismaticJoint(Body box, Vector2 anchor) {\nfinal groundBody = createBody(BodyDef());\n\nfinal prismaticJointDef = PrismaticJointDef()\n..initialize(\ngroundBody,\nbox,\nanchor,\nVector2(0, 1),\n)\n..enableLimit = true\n..lowerTranslation = -10\n..upperTranslation = 10;\n\nfinal joint = PrismaticJoint(prismaticJointDef);\ncreateJoint(joint);\nreturn joint;\n}\n\nRevoluteJoint createRevoluteJoint(Body ball, Vector2 anchor) {\nfinal groundBody = createBody(BodyDef());\n\nfinal revoluteJointDef = RevoluteJointDef()\n..initialize(\ngroundBody,\nball,\nanchor,\n);\n\nfinal joint = RevoluteJoint(revoluteJointDef);\ncreateJoint(joint);\nreturn joint;\n}\n\nvoid createGearJoint(Joint first, Joint second, double gearRatio) {\nfinal gearJointDef = GearJointDef()\n..bodyA = first.bodyA\n..bodyB = second.bodyA\n..joint1 = first\n..joint2 = second\n..ratio = gearRatio;\n\nfinal joint = GearJoint(gearJointDef);\ncreateJoint(joint);\n}\n}\n\nclass JointRenderer extends Component {\nJointRenderer({required this.joint, required this.anchor});\n\nfinal PrismaticJoint joint;\nfinal Vector2 anchor;\nfinal Vector2 p1 = Vector2.zero();\nfinal Vector2 p2 = Vector2.zero();\n\n@override\nvoid render(Canvas canvas) {\np1\n..setFrom(joint.getLocalAxisA())\n..scale(joint.getLowerLimit())\n..add(anchor);\np2\n..setFrom(joint.getLocalAxisA())\n..scale(joint.getUpperLimit())\n..add(anchor);\n\ncanvas.drawLine(p1.toOffset(), p2.toOffset(), debugPaint);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that MotorJoint¶: A MotorJoint lets you control the motion of a body by specifying target position and rotation offsets. You can set the maximum motor force and torque that will be applied to reach the target position and rotation. If the body is blocked, it will stop and the contact forces will be proportional the maximum motor force and torque.", "completion": "import 'dart:ui';\n\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boxes.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\n\nclass MotorJointExample extends Forge2DGame {\nstatic const description = '''\nThis example shows how to use a `MotorJoint`. The ball spins around the\ncenter point. Tap the screen to change the direction.\n''';\n\nMotorJointExample()\n: super(gravity: Vector2.zero(), world: MotorJointWorld());\n}\n\nclass MotorJointWorld extends Forge2DWorld with TapCallbacks {\nlate Ball ball;\nlate MotorJoint joint;\nfinal motorSpeed = 1;\n\nbool clockWise = true;\n\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\n\nfinal box = Box(\nstartPosition: Vector2.zero(),\nwidth: 2,\nheight: 1,\nbodyType: BodyType.static,\n);\nadd(box);\n\nball = Ball(Vector2(0, -5));\nadd(ball);\n\nawait Future.wait([ball.loaded, box.loaded]);\n\njoint = createMotorJoint(ball.body, box.body);\nadd(JointRenderer(joint: joint));\n}\n\n@override\nvoid onTapDown(TapDownEvent info) {\nsuper.onTapDown(info);\nclockWise = !clockWise;\n}\n\nMotorJoint createMotorJoint(Body first, Body second) {\nfinal motorJointDef = MotorJointDef()\n..initialize(first, second)\n..maxForce = 1000\n..maxTorque = 1000\n..correctionFactor = 0.1;\n\nfinal joint = MotorJoint(motorJointDef);\ncreateJoint(joint);\nreturn joint;\n}\n\nfinal linearOffset = Vector2.zero();\n\n@override\nvoid update(double dt) {\nsuper.update(dt);\n\nvar deltaOffset = motorSpeed * dt;\nif (clockWise) {\ndeltaOffset = -deltaOffset;\n}\n\nfinal linearOffsetX = joint.getLinearOffset().x + deltaOffset;\nfinal linearOffsetY = joint.getLinearOffset().y + deltaOffset;\nlinearOffset.setValues(linearOffsetX, linearOffsetY);\nfinal angularOffset = joint.getAngularOffset() + deltaOffset;\n\njoint.setLinearOffset(linearOffset);\njoint.setAngularOffset(angularOffset);\n}\n}\n\nclass JointRenderer extends Component {\nJointRenderer({required this.joint});\n\nfinal MotorJoint joint;\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawLine(\njoint.anchorA.toOffset(),\njoint.anchorB.toOffset(),\ndebugPaint,\n);\n}\n}"}
{"prompt": "Show me how to implement MotorJoint¶: A MotorJoint lets you control the motion of a body by specifying target position and rotation offsets. You can set the maximum motor force and torque that will be applied to reach the target position and rotation. If the body is blocked, it will stop and the contact forces will be proportional the maximum motor force and torque. using Flutter Flame", "completion": "import 'dart:ui';\n\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boxes.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\n\nclass MotorJointExample extends Forge2DGame {\nstatic const description = '''\nThis example shows how to use a `MotorJoint`. The ball spins around the\ncenter point. Tap the screen to change the direction.\n''';\n\nMotorJointExample()\n: super(gravity: Vector2.zero(), world: MotorJointWorld());\n}\n\nclass MotorJointWorld extends Forge2DWorld with TapCallbacks {\nlate Ball ball;\nlate MotorJoint joint;\nfinal motorSpeed = 1;\n\nbool clockWise = true;\n\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\n\nfinal box = Box(\nstartPosition: Vector2.zero(),\nwidth: 2,\nheight: 1,\nbodyType: BodyType.static,\n);\nadd(box);\n\nball = Ball(Vector2(0, -5));\nadd(ball);\n\nawait Future.wait([ball.loaded, box.loaded]);\n\njoint = createMotorJoint(ball.body, box.body);\nadd(JointRenderer(joint: joint));\n}\n\n@override\nvoid onTapDown(TapDownEvent info) {\nsuper.onTapDown(info);\nclockWise = !clockWise;\n}\n\nMotorJoint createMotorJoint(Body first, Body second) {\nfinal motorJointDef = MotorJointDef()\n..initialize(first, second)\n..maxForce = 1000\n..maxTorque = 1000\n..correctionFactor = 0.1;\n\nfinal joint = MotorJoint(motorJointDef);\ncreateJoint(joint);\nreturn joint;\n}\n\nfinal linearOffset = Vector2.zero();\n\n@override\nvoid update(double dt) {\nsuper.update(dt);\n\nvar deltaOffset = motorSpeed * dt;\nif (clockWise) {\ndeltaOffset = -deltaOffset;\n}\n\nfinal linearOffsetX = joint.getLinearOffset().x + deltaOffset;\nfinal linearOffsetY = joint.getLinearOffset().y + deltaOffset;\nlinearOffset.setValues(linearOffsetX, linearOffsetY);\nfinal angularOffset = joint.getAngularOffset() + deltaOffset;\n\njoint.setLinearOffset(linearOffset);\njoint.setAngularOffset(angularOffset);\n}\n}\n\nclass JointRenderer extends Component {\nJointRenderer({required this.joint});\n\nfinal MotorJoint joint;\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawLine(\njoint.anchorA.toOffset(),\njoint.anchorB.toOffset(),\ndebugPaint,\n);\n}\n}"}
{"prompt": "Write Flutter Flame code to MotorJoint¶: A MotorJoint lets you control the motion of a body by specifying target position and rotation offsets. You can set the maximum motor force and torque that will be applied to reach the target position and rotation. If the body is blocked, it will stop and the contact forces will be proportional the maximum motor force and torque.", "completion": "import 'dart:ui';\n\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boxes.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\n\nclass MotorJointExample extends Forge2DGame {\nstatic const description = '''\nThis example shows how to use a `MotorJoint`. The ball spins around the\ncenter point. Tap the screen to change the direction.\n''';\n\nMotorJointExample()\n: super(gravity: Vector2.zero(), world: MotorJointWorld());\n}\n\nclass MotorJointWorld extends Forge2DWorld with TapCallbacks {\nlate Ball ball;\nlate MotorJoint joint;\nfinal motorSpeed = 1;\n\nbool clockWise = true;\n\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\n\nfinal box = Box(\nstartPosition: Vector2.zero(),\nwidth: 2,\nheight: 1,\nbodyType: BodyType.static,\n);\nadd(box);\n\nball = Ball(Vector2(0, -5));\nadd(ball);\n\nawait Future.wait([ball.loaded, box.loaded]);\n\njoint = createMotorJoint(ball.body, box.body);\nadd(JointRenderer(joint: joint));\n}\n\n@override\nvoid onTapDown(TapDownEvent info) {\nsuper.onTapDown(info);\nclockWise = !clockWise;\n}\n\nMotorJoint createMotorJoint(Body first, Body second) {\nfinal motorJointDef = MotorJointDef()\n..initialize(first, second)\n..maxForce = 1000\n..maxTorque = 1000\n..correctionFactor = 0.1;\n\nfinal joint = MotorJoint(motorJointDef);\ncreateJoint(joint);\nreturn joint;\n}\n\nfinal linearOffset = Vector2.zero();\n\n@override\nvoid update(double dt) {\nsuper.update(dt);\n\nvar deltaOffset = motorSpeed * dt;\nif (clockWise) {\ndeltaOffset = -deltaOffset;\n}\n\nfinal linearOffsetX = joint.getLinearOffset().x + deltaOffset;\nfinal linearOffsetY = joint.getLinearOffset().y + deltaOffset;\nlinearOffset.setValues(linearOffsetX, linearOffsetY);\nfinal angularOffset = joint.getAngularOffset() + deltaOffset;\n\njoint.setLinearOffset(linearOffset);\njoint.setAngularOffset(angularOffset);\n}\n}\n\nclass JointRenderer extends Component {\nJointRenderer({required this.joint});\n\nfinal MotorJoint joint;\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawLine(\njoint.anchorA.toOffset(),\njoint.anchorB.toOffset(),\ndebugPaint,\n);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that MouseJoint¶: Many users have tried to adapt the mouse joint for game play. Users often want to achieve precise positioning and instantaneous response. The mouse joint doesn’t work very well in that context. You may wish to consider using kinematic bodies instead.", "completion": "import 'package:examples/stories/bridge_libraries/flame_forge2d/revolute_joint_with_motor_example.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boundaries.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\n\nclass MouseJointExample extends Forge2DGame {\nstatic const description = '''\nIn this example we use a `MouseJoint` to make the ball follow the mouse\nwhen you drag it around.\n''';\n\nMouseJointExample()\n: super(gravity: Vector2(0, 10.0), world: MouseJointWorld());\n}\n\nclass MouseJointWorld extends Forge2DWorld\nwith DragCallbacks, HasGameReference<Forge2DGame> {\nlate Ball ball;\nlate Body groundBody;\nMouseJoint? mouseJoint;\n\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\nfinal boundaries = createBoundaries(game);\naddAll(boundaries);\n\nfinal center = Vector2.zero();\ngroundBody = createBody(BodyDef());\nball = Ball(center, radius: 5);\nadd(ball);\nadd(CornerRamp(center));\nadd(CornerRamp(center, isMirrored: true));\n}\n\n@override\nvoid onDragStart(DragStartEvent info) {\nsuper.onDragStart(info);\nif (mouseJoint != null) {\nreturn;\n}\nfinal mouseJointDef = MouseJointDef()\n..maxForce = 3000 * ball.body.mass * 10\n..dampingRatio = 0.1\n..frequencyHz = 5\n..target.setFrom(ball.body.position)\n..collideConnected = false\n..bodyA = groundBody\n..bodyB = ball.body;\n\nmouseJoint = MouseJoint(mouseJointDef);\ncreateJoint(mouseJoint!);\n}\n\n@override\nvoid onDragUpdate(DragUpdateEvent info) {\nmouseJoint?.setTarget(info.localEndPosition);\n}\n\n@override\nvoid onDragEnd(DragEndEvent info) {\nsuper.onDragEnd(info);\ndestroyJoint(mouseJoint!);\nmouseJoint = null;\n}\n}"}
{"prompt": "Show me how to implement MouseJoint¶: Many users have tried to adapt the mouse joint for game play. Users often want to achieve precise positioning and instantaneous response. The mouse joint doesn’t work very well in that context. You may wish to consider using kinematic bodies instead. using Flutter Flame", "completion": "import 'package:examples/stories/bridge_libraries/flame_forge2d/revolute_joint_with_motor_example.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boundaries.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\n\nclass MouseJointExample extends Forge2DGame {\nstatic const description = '''\nIn this example we use a `MouseJoint` to make the ball follow the mouse\nwhen you drag it around.\n''';\n\nMouseJointExample()\n: super(gravity: Vector2(0, 10.0), world: MouseJointWorld());\n}\n\nclass MouseJointWorld extends Forge2DWorld\nwith DragCallbacks, HasGameReference<Forge2DGame> {\nlate Ball ball;\nlate Body groundBody;\nMouseJoint? mouseJoint;\n\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\nfinal boundaries = createBoundaries(game);\naddAll(boundaries);\n\nfinal center = Vector2.zero();\ngroundBody = createBody(BodyDef());\nball = Ball(center, radius: 5);\nadd(ball);\nadd(CornerRamp(center));\nadd(CornerRamp(center, isMirrored: true));\n}\n\n@override\nvoid onDragStart(DragStartEvent info) {\nsuper.onDragStart(info);\nif (mouseJoint != null) {\nreturn;\n}\nfinal mouseJointDef = MouseJointDef()\n..maxForce = 3000 * ball.body.mass * 10\n..dampingRatio = 0.1\n..frequencyHz = 5\n..target.setFrom(ball.body.position)\n..collideConnected = false\n..bodyA = groundBody\n..bodyB = ball.body;\n\nmouseJoint = MouseJoint(mouseJointDef);\ncreateJoint(mouseJoint!);\n}\n\n@override\nvoid onDragUpdate(DragUpdateEvent info) {\nmouseJoint?.setTarget(info.localEndPosition);\n}\n\n@override\nvoid onDragEnd(DragEndEvent info) {\nsuper.onDragEnd(info);\ndestroyJoint(mouseJoint!);\nmouseJoint = null;\n}\n}"}
{"prompt": "Write Flutter Flame code to MouseJoint¶: Many users have tried to adapt the mouse joint for game play. Users often want to achieve precise positioning and instantaneous response. The mouse joint doesn’t work very well in that context. You may wish to consider using kinematic bodies instead.", "completion": "import 'package:examples/stories/bridge_libraries/flame_forge2d/revolute_joint_with_motor_example.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boundaries.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\n\nclass MouseJointExample extends Forge2DGame {\nstatic const description = '''\nIn this example we use a `MouseJoint` to make the ball follow the mouse\nwhen you drag it around.\n''';\n\nMouseJointExample()\n: super(gravity: Vector2(0, 10.0), world: MouseJointWorld());\n}\n\nclass MouseJointWorld extends Forge2DWorld\nwith DragCallbacks, HasGameReference<Forge2DGame> {\nlate Ball ball;\nlate Body groundBody;\nMouseJoint? mouseJoint;\n\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\nfinal boundaries = createBoundaries(game);\naddAll(boundaries);\n\nfinal center = Vector2.zero();\ngroundBody = createBody(BodyDef());\nball = Ball(center, radius: 5);\nadd(ball);\nadd(CornerRamp(center));\nadd(CornerRamp(center, isMirrored: true));\n}\n\n@override\nvoid onDragStart(DragStartEvent info) {\nsuper.onDragStart(info);\nif (mouseJoint != null) {\nreturn;\n}\nfinal mouseJointDef = MouseJointDef()\n..maxForce = 3000 * ball.body.mass * 10\n..dampingRatio = 0.1\n..frequencyHz = 5\n..target.setFrom(ball.body.position)\n..collideConnected = false\n..bodyA = groundBody\n..bodyB = ball.body;\n\nmouseJoint = MouseJoint(mouseJointDef);\ncreateJoint(mouseJoint!);\n}\n\n@override\nvoid onDragUpdate(DragUpdateEvent info) {\nmouseJoint?.setTarget(info.localEndPosition);\n}\n\n@override\nvoid onDragEnd(DragEndEvent info) {\nsuper.onDragEnd(info);\ndestroyJoint(mouseJoint!);\nmouseJoint = null;\n}\n}"}
{"prompt": "Create a Flutter Flame game component that PrismaticJoint¶: The PrismaticJoint definition is similar to the RevoluteJoint definition, but instead of rotation, it uses translation.", "completion": "final prismaticJointDef = PrismaticJointDef()\n  ..initialize(\n    dynamicBody,\n    groundBody,\n    dynamicBody.worldCenter,\n    Vector2(1, 0),\n  )"}
{"prompt": "Show me how to implement PrismaticJoint¶: The PrismaticJoint definition is similar to the RevoluteJoint definition, but instead of rotation, it uses translation. using Flutter Flame", "completion": "final prismaticJointDef = PrismaticJointDef()\n  ..initialize(\n    dynamicBody,\n    groundBody,\n    dynamicBody.worldCenter,\n    Vector2(1, 0),\n  )"}
{"prompt": "Write Flutter Flame code to PrismaticJoint¶: The PrismaticJoint definition is similar to the RevoluteJoint definition, but instead of rotation, it uses translation.", "completion": "final prismaticJointDef = PrismaticJointDef()\n  ..initialize(\n    dynamicBody,\n    groundBody,\n    dynamicBody.worldCenter,\n    Vector2(1, 0),\n  )"}
{"prompt": "Create a Flutter Flame game component that PrismaticJoint¶: The PrismaticJoint definition is similar to the RevoluteJoint definition, but instead of rotation, it uses translation.", "completion": "import 'dart:ui';\n\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boxes.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\n\nclass PrismaticJointExample extends Forge2DGame {\nstatic const description = '''\nThis example shows how to use a `PrismaticJoint`.\n\nDrag the box along the specified axis, bound between lower and upper limits.\nAlso, there's a motor enabled that's pulling the box to the lower limit.\n''';\n\nfinal Vector2 anchor = Vector2.zero();\n\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\n\nfinal box = DraggableBox(startPosition: anchor, width: 6, height: 6);\nworld.add(box);\nawait Future.wait([box.loaded]);\n\nfinal joint = createJoint(box.body, anchor);\nworld.add(JointRenderer(joint: joint, anchor: anchor));\n}\n\nPrismaticJoint createJoint(Body box, Vector2 anchor) {\nfinal groundBody = world.createBody(BodyDef());\n\nfinal prismaticJointDef = PrismaticJointDef()\n..initialize(\nbox,\ngroundBody,\nanchor,\nVector2(1, 0),\n)\n..enableLimit = true\n..lowerTranslation = -20\n..upperTranslation = 20\n..enableMotor = true\n..motorSpeed = 1\n..maxMotorForce = 100;\n\nfinal joint = PrismaticJoint(prismaticJointDef);\nworld.createJoint(joint);\nreturn joint;\n}\n}\n\nclass JointRenderer extends Component {\nJointRenderer({required this.joint, required this.anchor});\n\nfinal PrismaticJoint joint;\nfinal Vector2 anchor;\nfinal Vector2 p1 = Vector2.zero();\nfinal Vector2 p2 = Vector2.zero();\n\n@override\nvoid render(Canvas canvas) {\np1\n..setFrom(joint.getLocalAxisA())\n..scale(joint.getLowerLimit())\n..add(anchor);\np2\n..setFrom(joint.getLocalAxisA())\n..scale(joint.getUpperLimit())\n..add(anchor);\n\ncanvas.drawLine(p1.toOffset(), p2.toOffset(), debugPaint);\n}\n}"}
{"prompt": "Show me how to implement PrismaticJoint¶: The PrismaticJoint definition is similar to the RevoluteJoint definition, but instead of rotation, it uses translation. using Flutter Flame", "completion": "import 'dart:ui';\n\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boxes.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\n\nclass PrismaticJointExample extends Forge2DGame {\nstatic const description = '''\nThis example shows how to use a `PrismaticJoint`.\n\nDrag the box along the specified axis, bound between lower and upper limits.\nAlso, there's a motor enabled that's pulling the box to the lower limit.\n''';\n\nfinal Vector2 anchor = Vector2.zero();\n\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\n\nfinal box = DraggableBox(startPosition: anchor, width: 6, height: 6);\nworld.add(box);\nawait Future.wait([box.loaded]);\n\nfinal joint = createJoint(box.body, anchor);\nworld.add(JointRenderer(joint: joint, anchor: anchor));\n}\n\nPrismaticJoint createJoint(Body box, Vector2 anchor) {\nfinal groundBody = world.createBody(BodyDef());\n\nfinal prismaticJointDef = PrismaticJointDef()\n..initialize(\nbox,\ngroundBody,\nanchor,\nVector2(1, 0),\n)\n..enableLimit = true\n..lowerTranslation = -20\n..upperTranslation = 20\n..enableMotor = true\n..motorSpeed = 1\n..maxMotorForce = 100;\n\nfinal joint = PrismaticJoint(prismaticJointDef);\nworld.createJoint(joint);\nreturn joint;\n}\n}\n\nclass JointRenderer extends Component {\nJointRenderer({required this.joint, required this.anchor});\n\nfinal PrismaticJoint joint;\nfinal Vector2 anchor;\nfinal Vector2 p1 = Vector2.zero();\nfinal Vector2 p2 = Vector2.zero();\n\n@override\nvoid render(Canvas canvas) {\np1\n..setFrom(joint.getLocalAxisA())\n..scale(joint.getLowerLimit())\n..add(anchor);\np2\n..setFrom(joint.getLocalAxisA())\n..scale(joint.getUpperLimit())\n..add(anchor);\n\ncanvas.drawLine(p1.toOffset(), p2.toOffset(), debugPaint);\n}\n}"}
{"prompt": "Write Flutter Flame code to PrismaticJoint¶: The PrismaticJoint definition is similar to the RevoluteJoint definition, but instead of rotation, it uses translation.", "completion": "import 'dart:ui';\n\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boxes.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\n\nclass PrismaticJointExample extends Forge2DGame {\nstatic const description = '''\nThis example shows how to use a `PrismaticJoint`.\n\nDrag the box along the specified axis, bound between lower and upper limits.\nAlso, there's a motor enabled that's pulling the box to the lower limit.\n''';\n\nfinal Vector2 anchor = Vector2.zero();\n\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\n\nfinal box = DraggableBox(startPosition: anchor, width: 6, height: 6);\nworld.add(box);\nawait Future.wait([box.loaded]);\n\nfinal joint = createJoint(box.body, anchor);\nworld.add(JointRenderer(joint: joint, anchor: anchor));\n}\n\nPrismaticJoint createJoint(Body box, Vector2 anchor) {\nfinal groundBody = world.createBody(BodyDef());\n\nfinal prismaticJointDef = PrismaticJointDef()\n..initialize(\nbox,\ngroundBody,\nanchor,\nVector2(1, 0),\n)\n..enableLimit = true\n..lowerTranslation = -20\n..upperTranslation = 20\n..enableMotor = true\n..motorSpeed = 1\n..maxMotorForce = 100;\n\nfinal joint = PrismaticJoint(prismaticJointDef);\nworld.createJoint(joint);\nreturn joint;\n}\n}\n\nclass JointRenderer extends Component {\nJointRenderer({required this.joint, required this.anchor});\n\nfinal PrismaticJoint joint;\nfinal Vector2 anchor;\nfinal Vector2 p1 = Vector2.zero();\nfinal Vector2 p2 = Vector2.zero();\n\n@override\nvoid render(Canvas canvas) {\np1\n..setFrom(joint.getLocalAxisA())\n..scale(joint.getLowerLimit())\n..add(anchor);\np2\n..setFrom(joint.getLocalAxisA())\n..scale(joint.getUpperLimit())\n..add(anchor);\n\ncanvas.drawLine(p1.toOffset(), p2.toOffset(), debugPaint);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that PulleyJoint¶: For example, if the ratio is 2, then length1 will vary at twice the rate of length2. Also the force in the rope attached to the first body will have half the constraint force as the rope attached to the second body.", "completion": "import 'dart:ui';\n\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boxes.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\n\nclass PulleyJointExample extends Forge2DGame {\nstatic const description = '''\nThis example shows how to use a `PulleyJoint`. Drag one of the boxes and see\nhow the other one gets moved by the pulley\n''';\n\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\nfinal distanceFromCenter = camera.visibleWorldRect.width / 5;\n\nfinal firstPulley = Ball(\nVector2(-distanceFromCenter, -10),\nbodyType: BodyType.static,\n);\nfinal secondPulley = Ball(\nVector2(distanceFromCenter, -10),\nbodyType: BodyType.static,\n);\n\nfinal firstBox = DraggableBox(\nstartPosition: Vector2(-distanceFromCenter, 20),\nwidth: 5,\nheight: 10,\n);\nfinal secondBox = DraggableBox(\nstartPosition: Vector2(distanceFromCenter, 20),\nwidth: 7,\nheight: 10,\n);\nworld.addAll([firstBox, secondBox, firstPulley, secondPulley]);\n\nawait Future.wait([\nfirstBox.loaded,\nsecondBox.loaded,\nfirstPulley.loaded,\nsecondPulley.loaded,\n]);\n\nfinal joint = createJoint(firstBox, secondBox, firstPulley, secondPulley);\nworld.add(PulleyRenderer(joint: joint));\n}\n\nPulleyJoint createJoint(\nBox firstBox,\nBox secondBox,\nBall firstPulley,\nBall secondPulley,\n) {\nfinal pulleyJointDef = PulleyJointDef()\n..initialize(\nfirstBox.body,\nsecondBox.body,\nfirstPulley.center,\nsecondPulley.center,\nfirstBox.body.worldPoint(Vector2(0, -firstBox.height / 2)),\nsecondBox.body.worldPoint(Vector2(0, -secondBox.height / 2)),\n1,\n);\nfinal joint = PulleyJoint(pulleyJointDef);\nworld.createJoint(joint);\nreturn joint;\n}\n}\n\nclass PulleyRenderer extends Component {\nPulleyRenderer({required this.joint});\n\nfinal PulleyJoint joint;\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawLine(\njoint.anchorA.toOffset(),\njoint.getGroundAnchorA().toOffset(),\ndebugPaint,\n);\n\ncanvas.drawLine(\njoint.anchorB.toOffset(),\njoint.getGroundAnchorB().toOffset(),\ndebugPaint,\n);\n\ncanvas.drawLine(\njoint.getGroundAnchorA().toOffset(),\njoint.getGroundAnchorB().toOffset(),\ndebugPaint,\n);\n}\n}"}
{"prompt": "Show me how to implement PulleyJoint¶: For example, if the ratio is 2, then length1 will vary at twice the rate of length2. Also the force in the rope attached to the first body will have half the constraint force as the rope attached to the second body. using Flutter Flame", "completion": "import 'dart:ui';\n\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boxes.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\n\nclass PulleyJointExample extends Forge2DGame {\nstatic const description = '''\nThis example shows how to use a `PulleyJoint`. Drag one of the boxes and see\nhow the other one gets moved by the pulley\n''';\n\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\nfinal distanceFromCenter = camera.visibleWorldRect.width / 5;\n\nfinal firstPulley = Ball(\nVector2(-distanceFromCenter, -10),\nbodyType: BodyType.static,\n);\nfinal secondPulley = Ball(\nVector2(distanceFromCenter, -10),\nbodyType: BodyType.static,\n);\n\nfinal firstBox = DraggableBox(\nstartPosition: Vector2(-distanceFromCenter, 20),\nwidth: 5,\nheight: 10,\n);\nfinal secondBox = DraggableBox(\nstartPosition: Vector2(distanceFromCenter, 20),\nwidth: 7,\nheight: 10,\n);\nworld.addAll([firstBox, secondBox, firstPulley, secondPulley]);\n\nawait Future.wait([\nfirstBox.loaded,\nsecondBox.loaded,\nfirstPulley.loaded,\nsecondPulley.loaded,\n]);\n\nfinal joint = createJoint(firstBox, secondBox, firstPulley, secondPulley);\nworld.add(PulleyRenderer(joint: joint));\n}\n\nPulleyJoint createJoint(\nBox firstBox,\nBox secondBox,\nBall firstPulley,\nBall secondPulley,\n) {\nfinal pulleyJointDef = PulleyJointDef()\n..initialize(\nfirstBox.body,\nsecondBox.body,\nfirstPulley.center,\nsecondPulley.center,\nfirstBox.body.worldPoint(Vector2(0, -firstBox.height / 2)),\nsecondBox.body.worldPoint(Vector2(0, -secondBox.height / 2)),\n1,\n);\nfinal joint = PulleyJoint(pulleyJointDef);\nworld.createJoint(joint);\nreturn joint;\n}\n}\n\nclass PulleyRenderer extends Component {\nPulleyRenderer({required this.joint});\n\nfinal PulleyJoint joint;\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawLine(\njoint.anchorA.toOffset(),\njoint.getGroundAnchorA().toOffset(),\ndebugPaint,\n);\n\ncanvas.drawLine(\njoint.anchorB.toOffset(),\njoint.getGroundAnchorB().toOffset(),\ndebugPaint,\n);\n\ncanvas.drawLine(\njoint.getGroundAnchorA().toOffset(),\njoint.getGroundAnchorB().toOffset(),\ndebugPaint,\n);\n}\n}"}
{"prompt": "Write Flutter Flame code to PulleyJoint¶: For example, if the ratio is 2, then length1 will vary at twice the rate of length2. Also the force in the rope attached to the first body will have half the constraint force as the rope attached to the second body.", "completion": "import 'dart:ui';\n\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boxes.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\n\nclass PulleyJointExample extends Forge2DGame {\nstatic const description = '''\nThis example shows how to use a `PulleyJoint`. Drag one of the boxes and see\nhow the other one gets moved by the pulley\n''';\n\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\nfinal distanceFromCenter = camera.visibleWorldRect.width / 5;\n\nfinal firstPulley = Ball(\nVector2(-distanceFromCenter, -10),\nbodyType: BodyType.static,\n);\nfinal secondPulley = Ball(\nVector2(distanceFromCenter, -10),\nbodyType: BodyType.static,\n);\n\nfinal firstBox = DraggableBox(\nstartPosition: Vector2(-distanceFromCenter, 20),\nwidth: 5,\nheight: 10,\n);\nfinal secondBox = DraggableBox(\nstartPosition: Vector2(distanceFromCenter, 20),\nwidth: 7,\nheight: 10,\n);\nworld.addAll([firstBox, secondBox, firstPulley, secondPulley]);\n\nawait Future.wait([\nfirstBox.loaded,\nsecondBox.loaded,\nfirstPulley.loaded,\nsecondPulley.loaded,\n]);\n\nfinal joint = createJoint(firstBox, secondBox, firstPulley, secondPulley);\nworld.add(PulleyRenderer(joint: joint));\n}\n\nPulleyJoint createJoint(\nBox firstBox,\nBox secondBox,\nBall firstPulley,\nBall secondPulley,\n) {\nfinal pulleyJointDef = PulleyJointDef()\n..initialize(\nfirstBox.body,\nsecondBox.body,\nfirstPulley.center,\nsecondPulley.center,\nfirstBox.body.worldPoint(Vector2(0, -firstBox.height / 2)),\nsecondBox.body.worldPoint(Vector2(0, -secondBox.height / 2)),\n1,\n);\nfinal joint = PulleyJoint(pulleyJointDef);\nworld.createJoint(joint);\nreturn joint;\n}\n}\n\nclass PulleyRenderer extends Component {\nPulleyRenderer({required this.joint});\n\nfinal PulleyJoint joint;\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawLine(\njoint.anchorA.toOffset(),\njoint.getGroundAnchorA().toOffset(),\ndebugPaint,\n);\n\ncanvas.drawLine(\njoint.anchorB.toOffset(),\njoint.getGroundAnchorB().toOffset(),\ndebugPaint,\n);\n\ncanvas.drawLine(\njoint.getGroundAnchorA().toOffset(),\njoint.getGroundAnchorB().toOffset(),\ndebugPaint,\n);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that RevoluteJoint¶: To create a RevoluteJoint, provide two bodies and a common point to the initialize method. The definition uses local anchor points so that the initial configuration can violate the constraint slightly.", "completion": "import 'dart:math';\n\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boundaries.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\n\nclass RevoluteJointExample extends Forge2DGame {\nstatic const description = '''\nIn this example we use a joint to keep a body with several fixtures stuck\nto another body.\n\nTap the screen to add more of these combined bodies.\n''';\n\nRevoluteJointExample()\n: super(gravity: Vector2(0, 10.0), world: RevoluteJointWorld());\n}\n\nclass RevoluteJointWorld extends Forge2DWorld\nwith TapCallbacks, HasGameReference<Forge2DGame> {\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\naddAll(createBoundaries(game));\n}\n\n@override\nvoid onTapDown(TapDownEvent info) {\nsuper.onTapDown(info);\nfinal ball = Ball(info.localPosition);\nadd(ball);\nadd(CircleShuffler(ball));\n}\n}\n\nclass CircleShuffler extends BodyComponent {\nfinal Ball ball;\n\nCircleShuffler(this.ball);\n\n@override\nBody createBody() {\nfinal bodyDef = BodyDef(\ntype: BodyType.dynamic,\nposition: ball.body.position.clone(),\n);\nconst numPieces = 5;\nconst radius = 6.0;\nfinal body = world.createBody(bodyDef);\n\nfor (var i = 0; i < numPieces; i++) {\nfinal xPos = radius * cos(2 * pi * (i / numPieces));\nfinal yPos = radius * sin(2 * pi * (i / numPieces));\n\nfinal shape = CircleShape()\n..radius = 1.2\n..position.setValues(xPos, yPos);\n\nfinal fixtureDef = FixtureDef(\nshape,\ndensity: 50.0,\nfriction: 0.1,\nrestitution: 0.9,\n);\n\nbody.createFixture(fixtureDef);\n}\n\nfinal jointDef = RevoluteJointDef()\n..initialize(body, ball.body, body.position);\nworld.createJoint(RevoluteJoint(jointDef));\n\nreturn body;\n}\n}"}
{"prompt": "Show me how to implement RevoluteJoint¶: To create a RevoluteJoint, provide two bodies and a common point to the initialize method. The definition uses local anchor points so that the initial configuration can violate the constraint slightly. using Flutter Flame", "completion": "import 'dart:math';\n\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boundaries.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\n\nclass RevoluteJointExample extends Forge2DGame {\nstatic const description = '''\nIn this example we use a joint to keep a body with several fixtures stuck\nto another body.\n\nTap the screen to add more of these combined bodies.\n''';\n\nRevoluteJointExample()\n: super(gravity: Vector2(0, 10.0), world: RevoluteJointWorld());\n}\n\nclass RevoluteJointWorld extends Forge2DWorld\nwith TapCallbacks, HasGameReference<Forge2DGame> {\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\naddAll(createBoundaries(game));\n}\n\n@override\nvoid onTapDown(TapDownEvent info) {\nsuper.onTapDown(info);\nfinal ball = Ball(info.localPosition);\nadd(ball);\nadd(CircleShuffler(ball));\n}\n}\n\nclass CircleShuffler extends BodyComponent {\nfinal Ball ball;\n\nCircleShuffler(this.ball);\n\n@override\nBody createBody() {\nfinal bodyDef = BodyDef(\ntype: BodyType.dynamic,\nposition: ball.body.position.clone(),\n);\nconst numPieces = 5;\nconst radius = 6.0;\nfinal body = world.createBody(bodyDef);\n\nfor (var i = 0; i < numPieces; i++) {\nfinal xPos = radius * cos(2 * pi * (i / numPieces));\nfinal yPos = radius * sin(2 * pi * (i / numPieces));\n\nfinal shape = CircleShape()\n..radius = 1.2\n..position.setValues(xPos, yPos);\n\nfinal fixtureDef = FixtureDef(\nshape,\ndensity: 50.0,\nfriction: 0.1,\nrestitution: 0.9,\n);\n\nbody.createFixture(fixtureDef);\n}\n\nfinal jointDef = RevoluteJointDef()\n..initialize(body, ball.body, body.position);\nworld.createJoint(RevoluteJoint(jointDef));\n\nreturn body;\n}\n}"}
{"prompt": "Write Flutter Flame code to RevoluteJoint¶: To create a RevoluteJoint, provide two bodies and a common point to the initialize method. The definition uses local anchor points so that the initial configuration can violate the constraint slightly.", "completion": "import 'dart:math';\n\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boundaries.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\n\nclass RevoluteJointExample extends Forge2DGame {\nstatic const description = '''\nIn this example we use a joint to keep a body with several fixtures stuck\nto another body.\n\nTap the screen to add more of these combined bodies.\n''';\n\nRevoluteJointExample()\n: super(gravity: Vector2(0, 10.0), world: RevoluteJointWorld());\n}\n\nclass RevoluteJointWorld extends Forge2DWorld\nwith TapCallbacks, HasGameReference<Forge2DGame> {\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\naddAll(createBoundaries(game));\n}\n\n@override\nvoid onTapDown(TapDownEvent info) {\nsuper.onTapDown(info);\nfinal ball = Ball(info.localPosition);\nadd(ball);\nadd(CircleShuffler(ball));\n}\n}\n\nclass CircleShuffler extends BodyComponent {\nfinal Ball ball;\n\nCircleShuffler(this.ball);\n\n@override\nBody createBody() {\nfinal bodyDef = BodyDef(\ntype: BodyType.dynamic,\nposition: ball.body.position.clone(),\n);\nconst numPieces = 5;\nconst radius = 6.0;\nfinal body = world.createBody(bodyDef);\n\nfor (var i = 0; i < numPieces; i++) {\nfinal xPos = radius * cos(2 * pi * (i / numPieces));\nfinal yPos = radius * sin(2 * pi * (i / numPieces));\n\nfinal shape = CircleShape()\n..radius = 1.2\n..position.setValues(xPos, yPos);\n\nfinal fixtureDef = FixtureDef(\nshape,\ndensity: 50.0,\nfriction: 0.1,\nrestitution: 0.9,\n);\n\nbody.createFixture(fixtureDef);\n}\n\nfinal jointDef = RevoluteJointDef()\n..initialize(body, ball.body, body.position);\nworld.createJoint(RevoluteJoint(jointDef));\n\nreturn body;\n}\n}"}
{"prompt": "Create a Flutter Flame game component that RopeJoint¶: RopeJointDef requires two body anchor points and the maximum length.", "completion": "import 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boxes.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\nimport 'package:flutter/material.dart';\n\nclass RopeJointExample extends Forge2DGame {\nstatic const description = '''\nThis example shows how to use a `RopeJoint`.\n\nDrag the box handle along the axis and observe the rope respond to the\nmovement.\n''';\n\nRopeJointExample() : super(world: RopeJointWorld());\n}\n\nclass RopeJointWorld extends Forge2DWorld\nwith DragCallbacks, HasGameReference<Forge2DGame> {\ndouble handleWidth = 6;\n\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\n\nfinal handleBody = await createHandle();\ncreateRope(handleBody);\n}\n\nFuture<Body> createHandle() async {\nfinal anchor = game.screenToWorld(Vector2(0, 100))..x = 0;\n\nfinal box = DraggableBox(\nstartPosition: anchor,\nwidth: handleWidth,\nheight: 3,\n);\nawait add(box);\n\ncreatePrismaticJoint(box.body, anchor);\nreturn box.body;\n}\n\nFuture<void> createRope(Body handle) async {\nconst length = 50;\nvar prevBody = handle;\n\nfor (var i = 0; i < length; i++) {\nfinal newPosition = prevBody.worldCenter + Vector2(0, 1);\nfinal ball = Ball(newPosition, radius: 0.5, color: Colors.white);\nawait add(ball);\n\ncreateRopeJoint(ball.body, prevBody);\nprevBody = ball.body;\n}\n}\n\nvoid createPrismaticJoint(Body box, Vector2 anchor) {\nfinal groundBody = createBody(BodyDef());\nfinal halfWidth = game.screenToWorld(Vector2.zero()).x.abs();\n\nfinal prismaticJointDef = PrismaticJointDef()\n..initialize(\nbox,\ngroundBody,\nanchor,\nVector2(1, 0),\n)\n..enableLimit = true\n..lowerTranslation = -halfWidth + handleWidth / 2\n..upperTranslation = halfWidth - handleWidth / 2;\n\nfinal joint = PrismaticJoint(prismaticJointDef);\ncreateJoint(joint);\n}\n\nvoid createRopeJoint(Body first, Body second) {\nfinal ropeJointDef = RopeJointDef()\n..bodyA = first\n..localAnchorA.setFrom(first.getLocalCenter())\n..bodyB = second\n..localAnchorB.setFrom(second.getLocalCenter())\n..maxLength = (second.worldCenter - first.worldCenter).length;\n\ncreateJoint(RopeJoint(ropeJointDef));\n}\n}"}
{"prompt": "Show me how to implement RopeJoint¶: RopeJointDef requires two body anchor points and the maximum length. using Flutter Flame", "completion": "import 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boxes.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\nimport 'package:flutter/material.dart';\n\nclass RopeJointExample extends Forge2DGame {\nstatic const description = '''\nThis example shows how to use a `RopeJoint`.\n\nDrag the box handle along the axis and observe the rope respond to the\nmovement.\n''';\n\nRopeJointExample() : super(world: RopeJointWorld());\n}\n\nclass RopeJointWorld extends Forge2DWorld\nwith DragCallbacks, HasGameReference<Forge2DGame> {\ndouble handleWidth = 6;\n\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\n\nfinal handleBody = await createHandle();\ncreateRope(handleBody);\n}\n\nFuture<Body> createHandle() async {\nfinal anchor = game.screenToWorld(Vector2(0, 100))..x = 0;\n\nfinal box = DraggableBox(\nstartPosition: anchor,\nwidth: handleWidth,\nheight: 3,\n);\nawait add(box);\n\ncreatePrismaticJoint(box.body, anchor);\nreturn box.body;\n}\n\nFuture<void> createRope(Body handle) async {\nconst length = 50;\nvar prevBody = handle;\n\nfor (var i = 0; i < length; i++) {\nfinal newPosition = prevBody.worldCenter + Vector2(0, 1);\nfinal ball = Ball(newPosition, radius: 0.5, color: Colors.white);\nawait add(ball);\n\ncreateRopeJoint(ball.body, prevBody);\nprevBody = ball.body;\n}\n}\n\nvoid createPrismaticJoint(Body box, Vector2 anchor) {\nfinal groundBody = createBody(BodyDef());\nfinal halfWidth = game.screenToWorld(Vector2.zero()).x.abs();\n\nfinal prismaticJointDef = PrismaticJointDef()\n..initialize(\nbox,\ngroundBody,\nanchor,\nVector2(1, 0),\n)\n..enableLimit = true\n..lowerTranslation = -halfWidth + handleWidth / 2\n..upperTranslation = halfWidth - handleWidth / 2;\n\nfinal joint = PrismaticJoint(prismaticJointDef);\ncreateJoint(joint);\n}\n\nvoid createRopeJoint(Body first, Body second) {\nfinal ropeJointDef = RopeJointDef()\n..bodyA = first\n..localAnchorA.setFrom(first.getLocalCenter())\n..bodyB = second\n..localAnchorB.setFrom(second.getLocalCenter())\n..maxLength = (second.worldCenter - first.worldCenter).length;\n\ncreateJoint(RopeJoint(ropeJointDef));\n}\n}"}
{"prompt": "Write Flutter Flame code to RopeJoint¶: RopeJointDef requires two body anchor points and the maximum length.", "completion": "import 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boxes.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\nimport 'package:flutter/material.dart';\n\nclass RopeJointExample extends Forge2DGame {\nstatic const description = '''\nThis example shows how to use a `RopeJoint`.\n\nDrag the box handle along the axis and observe the rope respond to the\nmovement.\n''';\n\nRopeJointExample() : super(world: RopeJointWorld());\n}\n\nclass RopeJointWorld extends Forge2DWorld\nwith DragCallbacks, HasGameReference<Forge2DGame> {\ndouble handleWidth = 6;\n\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\n\nfinal handleBody = await createHandle();\ncreateRope(handleBody);\n}\n\nFuture<Body> createHandle() async {\nfinal anchor = game.screenToWorld(Vector2(0, 100))..x = 0;\n\nfinal box = DraggableBox(\nstartPosition: anchor,\nwidth: handleWidth,\nheight: 3,\n);\nawait add(box);\n\ncreatePrismaticJoint(box.body, anchor);\nreturn box.body;\n}\n\nFuture<void> createRope(Body handle) async {\nconst length = 50;\nvar prevBody = handle;\n\nfor (var i = 0; i < length; i++) {\nfinal newPosition = prevBody.worldCenter + Vector2(0, 1);\nfinal ball = Ball(newPosition, radius: 0.5, color: Colors.white);\nawait add(ball);\n\ncreateRopeJoint(ball.body, prevBody);\nprevBody = ball.body;\n}\n}\n\nvoid createPrismaticJoint(Body box, Vector2 anchor) {\nfinal groundBody = createBody(BodyDef());\nfinal halfWidth = game.screenToWorld(Vector2.zero()).x.abs();\n\nfinal prismaticJointDef = PrismaticJointDef()\n..initialize(\nbox,\ngroundBody,\nanchor,\nVector2(1, 0),\n)\n..enableLimit = true\n..lowerTranslation = -halfWidth + handleWidth / 2\n..upperTranslation = halfWidth - handleWidth / 2;\n\nfinal joint = PrismaticJoint(prismaticJointDef);\ncreateJoint(joint);\n}\n\nvoid createRopeJoint(Body first, Body second) {\nfinal ropeJointDef = RopeJointDef()\n..bodyA = first\n..localAnchorA.setFrom(first.getLocalCenter())\n..bodyB = second\n..localAnchorB.setFrom(second.getLocalCenter())\n..maxLength = (second.worldCenter - first.worldCenter).length;\n\ncreateJoint(RopeJoint(ropeJointDef));\n}\n}"}
{"prompt": "Create a Flutter Flame game component that WeldJoint¶: WeldJointDef requires two bodies that will be connected, and a world anchor:", "completion": "import 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boxes.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\nimport 'package:flutter/material.dart';\n\nclass WeldJointExample extends Forge2DGame {\nstatic const description = '''\nThis example shows how to use a `WeldJoint`. Tap the screen to add a\nball to test the bridge built using a `WeldJoint`\n''';\n\nWeldJointExample() : super(world: WeldJointWorld());\n}\n\nclass WeldJointWorld extends Forge2DWorld\nwith TapCallbacks, HasGameReference<Forge2DGame> {\nfinal pillarHeight = 20.0;\nfinal pillarWidth = 5.0;\n\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\n\nfinal leftPillar = Box(\nstartPosition: game.screenToWorld(Vector2(50, game.size.y))\n..y -= pillarHeight / 2,\nwidth: pillarWidth,\nheight: pillarHeight,\nbodyType: BodyType.static,\ncolor: Colors.white,\n);\nfinal rightPillar = Box(\nstartPosition: game.screenToWorld(Vector2(game.size.x - 50, game.size.y))\n..y -= pillarHeight / 2,\nwidth: pillarWidth,\nheight: pillarHeight,\nbodyType: BodyType.static,\ncolor: Colors.white,\n);\n\nawait addAll([leftPillar, rightPillar]);\n\ncreateBridge(leftPillar, rightPillar);\n}\n\nFuture<void> createBridge(\nBox leftPillar,\nBox rightPillar,\n) async {\nconst sectionsCount = 10;\n// Vector2.zero is used here since 0,0 is in the middle and 0,0 in the\n// screen space then gives us the coordinates of the upper left corner in\n// world space.\nfinal halfSize = game.screenToWorld(Vector2.zero())..absolute();\nfinal sectionWidth = ((leftPillar.center.x.abs() +\nrightPillar.center.x.abs() +\npillarWidth) /\nsectionsCount)\n.ceilToDouble();\nBody? prevSection;\n\nfor (var i = 0; i < sectionsCount; i++) {\nfinal section = Box(\nstartPosition: Vector2(\nsectionWidth * i - halfSize.x + sectionWidth / 2,\nhalfSize.y - pillarHeight,\n),\nwidth: sectionWidth,\nheight: 1,\n);\nawait add(section);\n\nif (prevSection != null) {\ncreateWeldJoint(\nprevSection,\nsection.body,\nVector2(\nsectionWidth * i - halfSize.x + sectionWidth,\nhalfSize.y - pillarHeight,\n),\n);\n}\n\nprevSection = section.body;\n}\n}\n\nvoid createWeldJoint(Body first, Body second, Vector2 anchor) {\nfinal weldJointDef = WeldJointDef()..initialize(first, second, anchor);\n\ncreateJoint(WeldJoint(weldJointDef));\n}\n\n@override\nFuture<void> onTapDown(TapDownEvent info) async {\nsuper.onTapDown(info);\nfinal ball = Ball(info.localPosition, radius: 5);\nadd(ball);\n}\n}"}
{"prompt": "Show me how to implement WeldJoint¶: WeldJointDef requires two bodies that will be connected, and a world anchor: using Flutter Flame", "completion": "import 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boxes.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\nimport 'package:flutter/material.dart';\n\nclass WeldJointExample extends Forge2DGame {\nstatic const description = '''\nThis example shows how to use a `WeldJoint`. Tap the screen to add a\nball to test the bridge built using a `WeldJoint`\n''';\n\nWeldJointExample() : super(world: WeldJointWorld());\n}\n\nclass WeldJointWorld extends Forge2DWorld\nwith TapCallbacks, HasGameReference<Forge2DGame> {\nfinal pillarHeight = 20.0;\nfinal pillarWidth = 5.0;\n\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\n\nfinal leftPillar = Box(\nstartPosition: game.screenToWorld(Vector2(50, game.size.y))\n..y -= pillarHeight / 2,\nwidth: pillarWidth,\nheight: pillarHeight,\nbodyType: BodyType.static,\ncolor: Colors.white,\n);\nfinal rightPillar = Box(\nstartPosition: game.screenToWorld(Vector2(game.size.x - 50, game.size.y))\n..y -= pillarHeight / 2,\nwidth: pillarWidth,\nheight: pillarHeight,\nbodyType: BodyType.static,\ncolor: Colors.white,\n);\n\nawait addAll([leftPillar, rightPillar]);\n\ncreateBridge(leftPillar, rightPillar);\n}\n\nFuture<void> createBridge(\nBox leftPillar,\nBox rightPillar,\n) async {\nconst sectionsCount = 10;\n// Vector2.zero is used here since 0,0 is in the middle and 0,0 in the\n// screen space then gives us the coordinates of the upper left corner in\n// world space.\nfinal halfSize = game.screenToWorld(Vector2.zero())..absolute();\nfinal sectionWidth = ((leftPillar.center.x.abs() +\nrightPillar.center.x.abs() +\npillarWidth) /\nsectionsCount)\n.ceilToDouble();\nBody? prevSection;\n\nfor (var i = 0; i < sectionsCount; i++) {\nfinal section = Box(\nstartPosition: Vector2(\nsectionWidth * i - halfSize.x + sectionWidth / 2,\nhalfSize.y - pillarHeight,\n),\nwidth: sectionWidth,\nheight: 1,\n);\nawait add(section);\n\nif (prevSection != null) {\ncreateWeldJoint(\nprevSection,\nsection.body,\nVector2(\nsectionWidth * i - halfSize.x + sectionWidth,\nhalfSize.y - pillarHeight,\n),\n);\n}\n\nprevSection = section.body;\n}\n}\n\nvoid createWeldJoint(Body first, Body second, Vector2 anchor) {\nfinal weldJointDef = WeldJointDef()..initialize(first, second, anchor);\n\ncreateJoint(WeldJoint(weldJointDef));\n}\n\n@override\nFuture<void> onTapDown(TapDownEvent info) async {\nsuper.onTapDown(info);\nfinal ball = Ball(info.localPosition, radius: 5);\nadd(ball);\n}\n}"}
{"prompt": "Write Flutter Flame code to WeldJoint¶: WeldJointDef requires two bodies that will be connected, and a world anchor:", "completion": "import 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boxes.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\nimport 'package:flutter/material.dart';\n\nclass WeldJointExample extends Forge2DGame {\nstatic const description = '''\nThis example shows how to use a `WeldJoint`. Tap the screen to add a\nball to test the bridge built using a `WeldJoint`\n''';\n\nWeldJointExample() : super(world: WeldJointWorld());\n}\n\nclass WeldJointWorld extends Forge2DWorld\nwith TapCallbacks, HasGameReference<Forge2DGame> {\nfinal pillarHeight = 20.0;\nfinal pillarWidth = 5.0;\n\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\n\nfinal leftPillar = Box(\nstartPosition: game.screenToWorld(Vector2(50, game.size.y))\n..y -= pillarHeight / 2,\nwidth: pillarWidth,\nheight: pillarHeight,\nbodyType: BodyType.static,\ncolor: Colors.white,\n);\nfinal rightPillar = Box(\nstartPosition: game.screenToWorld(Vector2(game.size.x - 50, game.size.y))\n..y -= pillarHeight / 2,\nwidth: pillarWidth,\nheight: pillarHeight,\nbodyType: BodyType.static,\ncolor: Colors.white,\n);\n\nawait addAll([leftPillar, rightPillar]);\n\ncreateBridge(leftPillar, rightPillar);\n}\n\nFuture<void> createBridge(\nBox leftPillar,\nBox rightPillar,\n) async {\nconst sectionsCount = 10;\n// Vector2.zero is used here since 0,0 is in the middle and 0,0 in the\n// screen space then gives us the coordinates of the upper left corner in\n// world space.\nfinal halfSize = game.screenToWorld(Vector2.zero())..absolute();\nfinal sectionWidth = ((leftPillar.center.x.abs() +\nrightPillar.center.x.abs() +\npillarWidth) /\nsectionsCount)\n.ceilToDouble();\nBody? prevSection;\n\nfor (var i = 0; i < sectionsCount; i++) {\nfinal section = Box(\nstartPosition: Vector2(\nsectionWidth * i - halfSize.x + sectionWidth / 2,\nhalfSize.y - pillarHeight,\n),\nwidth: sectionWidth,\nheight: 1,\n);\nawait add(section);\n\nif (prevSection != null) {\ncreateWeldJoint(\nprevSection,\nsection.body,\nVector2(\nsectionWidth * i - halfSize.x + sectionWidth,\nhalfSize.y - pillarHeight,\n),\n);\n}\n\nprevSection = section.body;\n}\n}\n\nvoid createWeldJoint(Body first, Body second, Vector2 anchor) {\nfinal weldJointDef = WeldJointDef()..initialize(first, second, anchor);\n\ncreateJoint(WeldJoint(weldJointDef));\n}\n\n@override\nFuture<void> onTapDown(TapDownEvent info) async {\nsuper.onTapDown(info);\nfinal ball = Ball(info.localPosition, radius: 5);\nadd(ball);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that <<StartQuest>>¶: In order to implement this command, we create a Dart function startQuest() with two string arguments. The function will do a brief animated “Started quest X” message, but we don’t want the game dialogue to wait for that message, so we’ll make the function return void, not a future. Finally, we register the command with commands.addCommand2().", "completion": "class MyGame {\n  late YarnProject yarnProject;\n\n  void startQuest(String questId, String questName) {\n    assert(quests.containsKey(questId));\n    assert(quests[questId]!.name == questName);\n    // ...\n  }\n  @override\n  void onLoad() {\n    yarnProject = YarnProject()\n      ..commands.addCommand2('StartQuest', startQuest);\n  }\n}"}
{"prompt": "Show me how to implement <<StartQuest>>¶: In order to implement this command, we create a Dart function startQuest() with two string arguments. The function will do a brief animated “Started quest X” message, but we don’t want the game dialogue to wait for that message, so we’ll make the function return void, not a future. Finally, we register the command with commands.addCommand2(). using Flutter Flame", "completion": "class MyGame {\n  late YarnProject yarnProject;\n\n  void startQuest(String questId, String questName) {\n    assert(quests.containsKey(questId));\n    assert(quests[questId]!.name == questName);\n    // ...\n  }\n  @override\n  void onLoad() {\n    yarnProject = YarnProject()\n      ..commands.addCommand2('StartQuest', startQuest);\n  }\n}"}
{"prompt": "Write Flutter Flame code to <<StartQuest>>¶: In order to implement this command, we create a Dart function startQuest() with two string arguments. The function will do a brief animated “Started quest X” message, but we don’t want the game dialogue to wait for that message, so we’ll make the function return void, not a future. Finally, we register the command with commands.addCommand2().", "completion": "class MyGame {\n  late YarnProject yarnProject;\n\n  void startQuest(String questId, String questName) {\n    assert(quests.containsKey(questId));\n    assert(quests[questId]!.name == questName);\n    // ...\n  }\n  @override\n  void onLoad() {\n    yarnProject = YarnProject()\n      ..commands.addCommand2('StartQuest', startQuest);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that <<prompt>>¶: The <<prompt>> function will open a modal dialogue and ask the user to enter their response. This command will be waiting for the user’s input, so it must return a future. Also, we want to return the result of the prompt into the dialogue – but, unfortunately, the commands are not expressions, and are not supposed to return values. So instead we will write the result into a global variable $prompt, and then the dialogue can access that variable in order to read the result of the prompt.", "completion": "class MyGame {\n  final YarnProject yarnProject = YarnProject();\n\n  Future<void> prompt(String message) async {\n    // This will wait until the modal dialog is popped from the router stack\n    final name = await router.pushAndWait(KeyboardDialog(message));\n    yarnProject.variables.setVariable(r'$prompt', name);\n  }\n\n  @override\n  void onLoad() {\n    yarnProject\n      ..variables.setVariable(r'$prompt', '')\n      ..commands.addCommand1('prompt', prompt);\n  }\n}"}
{"prompt": "Show me how to implement <<prompt>>¶: The <<prompt>> function will open a modal dialogue and ask the user to enter their response. This command will be waiting for the user’s input, so it must return a future. Also, we want to return the result of the prompt into the dialogue – but, unfortunately, the commands are not expressions, and are not supposed to return values. So instead we will write the result into a global variable $prompt, and then the dialogue can access that variable in order to read the result of the prompt. using Flutter Flame", "completion": "class MyGame {\n  final YarnProject yarnProject = YarnProject();\n\n  Future<void> prompt(String message) async {\n    // This will wait until the modal dialog is popped from the router stack\n    final name = await router.pushAndWait(KeyboardDialog(message));\n    yarnProject.variables.setVariable(r'$prompt', name);\n  }\n\n  @override\n  void onLoad() {\n    yarnProject\n      ..variables.setVariable(r'$prompt', '')\n      ..commands.addCommand1('prompt', prompt);\n  }\n}"}
{"prompt": "Write Flutter Flame code to <<prompt>>¶: The <<prompt>> function will open a modal dialogue and ask the user to enter their response. This command will be waiting for the user’s input, so it must return a future. Also, we want to return the result of the prompt into the dialogue – but, unfortunately, the commands are not expressions, and are not supposed to return values. So instead we will write the result into a global variable $prompt, and then the dialogue can access that variable in order to read the result of the prompt.", "completion": "class MyGame {\n  final YarnProject yarnProject = YarnProject();\n\n  Future<void> prompt(String message) async {\n    // This will wait until the modal dialog is popped from the router stack\n    final name = await router.pushAndWait(KeyboardDialog(message));\n    yarnProject.variables.setVariable(r'$prompt', name);\n  }\n\n  @override\n  void onLoad() {\n    yarnProject\n      ..variables.setVariable(r'$prompt', '')\n      ..commands.addCommand1('prompt', prompt);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Getting started: Here is a simple example of how to use the `GameWidget`:", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(\n    GameWidget(\n      game: FlameGame(),\n    ),\n  );\n}"}
{"prompt": "Show me how to implement Getting started: Here is a simple example of how to use the `GameWidget`: using Flutter Flame", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(\n    GameWidget(\n      game: FlameGame(),\n    ),\n  );\n}"}
{"prompt": "Write Flutter Flame code to Getting started: Here is a simple example of how to use the `GameWidget`:", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(\n    GameWidget(\n      game: FlameGame(),\n    ),\n  );\n}"}
{"prompt": "Create a Flutter Flame game component that Getting started: So to create a simple game you can do something like this:", "completion": "import 'package:flame/game.dart';\nimport 'package:flame/components.dart';\nimport 'package:flutter/widgets.dart';\n\nvoid main() {\n  runApp(\n    GameWidget(\n      game: FlameGame(world: MyWorld()),\n    ),\n  );\n}\n\nclass MyWorld extends World {\n  @override\n  Future<void> onLoad() async {\n    add(Player(position: Vector2(0, 0)));\n  }\n}"}
{"prompt": "Show me how to implement Getting started: So to create a simple game you can do something like this: using Flutter Flame", "completion": "import 'package:flame/game.dart';\nimport 'package:flame/components.dart';\nimport 'package:flutter/widgets.dart';\n\nvoid main() {\n  runApp(\n    GameWidget(\n      game: FlameGame(world: MyWorld()),\n    ),\n  );\n}\n\nclass MyWorld extends World {\n  @override\n  Future<void> onLoad() async {\n    add(Player(position: Vector2(0, 0)));\n  }\n}"}
{"prompt": "Write Flutter Flame code to Getting started: So to create a simple game you can do something like this:", "completion": "import 'package:flame/game.dart';\nimport 'package:flame/components.dart';\nimport 'package:flutter/widgets.dart';\n\nvoid main() {\n  runApp(\n    GameWidget(\n      game: FlameGame(world: MyWorld()),\n    ),\n  );\n}\n\nclass MyWorld extends World {\n  @override\n  Future<void> onLoad() async {\n    add(Player(position: Vector2(0, 0)));\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Getting started: For example something like this:", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/geometry.dart';\nimport 'package:flame/extensions.dart';\n\nclass Player extends SpriteComponent {\n  Player({super.position}) :\n    super(size: Vector2.all(200), anchor: Anchor.center);\n\n  @override\n  Future<void> onLoad() async {\n    sprite = await Sprite.load('player.png');\n  }\n}"}
{"prompt": "Show me how to implement Getting started: For example something like this: using Flutter Flame", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/geometry.dart';\nimport 'package:flame/extensions.dart';\n\nclass Player extends SpriteComponent {\n  Player({super.position}) :\n    super(size: Vector2.all(200), anchor: Anchor.center);\n\n  @override\n  Future<void> onLoad() async {\n    sprite = await Sprite.load('player.png');\n  }\n}"}
{"prompt": "Write Flutter Flame code to Getting started: For example something like this:", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/geometry.dart';\nimport 'package:flame/extensions.dart';\n\nclass Player extends SpriteComponent {\n  Player({super.position}) :\n    super(size: Vector2.all(200), anchor: Anchor.center);\n\n  @override\n  Future<void> onLoad() async {\n    sprite = await Sprite.load('player.png');\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Getting started: tapped the size of the player will increase by 50 pixels in both width and height.", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/geometry.dart';\nimport 'package:flame/extensions.dart';\n\nclass Player extends SpriteComponent with TapCallbacks {\n  Player({super.position}) :\n    super(size: Vector2.all(200), anchor: Anchor.center);\n\n  @override\n  Future<void> onLoad() async {\n    sprite = await Sprite.load('player.png');\n  }\n  \n  @override\n  void onTapUp(TapUpInfo info) {\n    size += Vector2.all(50);\n  }\n}"}
{"prompt": "Show me how to implement Getting started: tapped the size of the player will increase by 50 pixels in both width and height. using Flutter Flame", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/geometry.dart';\nimport 'package:flame/extensions.dart';\n\nclass Player extends SpriteComponent with TapCallbacks {\n  Player({super.position}) :\n    super(size: Vector2.all(200), anchor: Anchor.center);\n\n  @override\n  Future<void> onLoad() async {\n    sprite = await Sprite.load('player.png');\n  }\n  \n  @override\n  void onTapUp(TapUpInfo info) {\n    size += Vector2.all(50);\n  }\n}"}
{"prompt": "Write Flutter Flame code to Getting started: tapped the size of the player will increase by 50 pixels in both width and height.", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/geometry.dart';\nimport 'package:flame/extensions.dart';\n\nclass Player extends SpriteComponent with TapCallbacks {\n  Player({super.position}) :\n    super(size: Vector2.all(200), anchor: Anchor.center);\n\n  @override\n  Future<void> onLoad() async {\n    sprite = await Sprite.load('player.png');\n  }\n  \n  @override\n  void onTapUp(TapUpInfo info) {\n    size += Vector2.all(50);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that How to use¶: We can do that by using FlameBlocProvider component:", "completion": "class MyGame extends FlameGame {\n  @override\n  Future<void> onLoad() async {\n    await add(\n      FlameBlocProvider<PlayerInventoryBloc, PlayerInventoryState>(\n        create: () => PlayerInventoryBloc(),\n        children: [\n          Player(),\n          // ...\n        ],\n      ),\n    );\n  }\n}"}
{"prompt": "Show me how to implement How to use¶: We can do that by using FlameBlocProvider component: using Flutter Flame", "completion": "class MyGame extends FlameGame {\n  @override\n  Future<void> onLoad() async {\n    await add(\n      FlameBlocProvider<PlayerInventoryBloc, PlayerInventoryState>(\n        create: () => PlayerInventoryBloc(),\n        children: [\n          Player(),\n          // ...\n        ],\n      ),\n    );\n  }\n}"}
{"prompt": "Write Flutter Flame code to How to use¶: We can do that by using FlameBlocProvider component:", "completion": "class MyGame extends FlameGame {\n  @override\n  Future<void> onLoad() async {\n    await add(\n      FlameBlocProvider<PlayerInventoryBloc, PlayerInventoryState>(\n        create: () => PlayerInventoryBloc(),\n        children: [\n          Player(),\n          // ...\n        ],\n      ),\n    );\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that How to use¶: If more than one bloc needs to be provided, FlameMultiBlocProvider can be used in a similar fashion:", "completion": "class MyGame extends FlameGame {\n  @override\n  Future<void> onLoad() async {\n    await add(\n      FlameMultiBlocProvider(\n        providers: [\n          FlameBlocProvider<PlayerInventoryBloc, PlayerInventoryState>(\n            create: () => PlayerInventoryBloc(),\n          ),\n          FlameBlocProvider<PlayerStatsBloc, PlayerStatsState>(\n            create: () => PlayerStatsBloc(),\n          ),\n        ],\n        children: [\n          Player(),\n          // ...\n        ],\n      ),\n    );\n  }\n}"}
{"prompt": "Show me how to implement How to use¶: If more than one bloc needs to be provided, FlameMultiBlocProvider can be used in a similar fashion: using Flutter Flame", "completion": "class MyGame extends FlameGame {\n  @override\n  Future<void> onLoad() async {\n    await add(\n      FlameMultiBlocProvider(\n        providers: [\n          FlameBlocProvider<PlayerInventoryBloc, PlayerInventoryState>(\n            create: () => PlayerInventoryBloc(),\n          ),\n          FlameBlocProvider<PlayerStatsBloc, PlayerStatsState>(\n            create: () => PlayerStatsBloc(),\n          ),\n        ],\n        children: [\n          Player(),\n          // ...\n        ],\n      ),\n    );\n  }\n}"}
{"prompt": "Write Flutter Flame code to How to use¶: If more than one bloc needs to be provided, FlameMultiBlocProvider can be used in a similar fashion:", "completion": "class MyGame extends FlameGame {\n  @override\n  Future<void> onLoad() async {\n    await add(\n      FlameMultiBlocProvider(\n        providers: [\n          FlameBlocProvider<PlayerInventoryBloc, PlayerInventoryState>(\n            create: () => PlayerInventoryBloc(),\n          ),\n          FlameBlocProvider<PlayerStatsBloc, PlayerStatsState>(\n            create: () => PlayerStatsBloc(),\n          ),\n        ],\n        children: [\n          Player(),\n          // ...\n        ],\n      ),\n    );\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that How to use¶: By using FlameBlocListener component:", "completion": "class Player extends PositionComponent {\n  @override\n  Future<void> onLoad() async {\n    await add(\n      FlameBlocListener<PlayerInventoryBloc, PlayerInventoryState>(\n        listener: (state) {\n          updateGear(state);\n        },\n      ),\n    );\n  }\n}"}
{"prompt": "Show me how to implement How to use¶: By using FlameBlocListener component: using Flutter Flame", "completion": "class Player extends PositionComponent {\n  @override\n  Future<void> onLoad() async {\n    await add(\n      FlameBlocListener<PlayerInventoryBloc, PlayerInventoryState>(\n        listener: (state) {\n          updateGear(state);\n        },\n      ),\n    );\n  }\n}"}
{"prompt": "Write Flutter Flame code to How to use¶: By using FlameBlocListener component:", "completion": "class Player extends PositionComponent {\n  @override\n  Future<void> onLoad() async {\n    await add(\n      FlameBlocListener<PlayerInventoryBloc, PlayerInventoryState>(\n        listener: (state) {\n          updateGear(state);\n        },\n      ),\n    );\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that How to use¶: Or by using FlameBlocListenable mixin:", "completion": "class Player extends PositionComponent\n    with FlameBlocListenable<PlayerInventoryBloc, PlayerInventoryState> {\n\n  @override\n  void onNewState(state) {\n    updateGear(state);\n  }\n}"}
{"prompt": "Show me how to implement How to use¶: Or by using FlameBlocListenable mixin: using Flutter Flame", "completion": "class Player extends PositionComponent\n    with FlameBlocListenable<PlayerInventoryBloc, PlayerInventoryState> {\n\n  @override\n  void onNewState(state) {\n    updateGear(state);\n  }\n}"}
{"prompt": "Write Flutter Flame code to How to use¶: Or by using FlameBlocListenable mixin:", "completion": "class Player extends PositionComponent\n    with FlameBlocListenable<PlayerInventoryBloc, PlayerInventoryState> {\n\n  @override\n  void onNewState(state) {\n    updateGear(state);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that How to use¶: If all your component need is to simply access a bloc, the FlameBlocReader mixin can be applied to a component:", "completion": "class Player extends PositionComponent\n    with FlameBlocReader<PlayerStatsBloc, PlayerStatsState> {\n\n  void takeHit() {\n    bloc.add(const PlayerDamaged());\n  }\n}"}
{"prompt": "Show me how to implement How to use¶: If all your component need is to simply access a bloc, the FlameBlocReader mixin can be applied to a component: using Flutter Flame", "completion": "class Player extends PositionComponent\n    with FlameBlocReader<PlayerStatsBloc, PlayerStatsState> {\n\n  void takeHit() {\n    bloc.add(const PlayerDamaged());\n  }\n}"}
{"prompt": "Write Flutter Flame code to How to use¶: If all your component need is to simply access a bloc, the FlameBlocReader mixin can be applied to a component:", "completion": "class Player extends PositionComponent\n    with FlameBlocReader<PlayerStatsBloc, PlayerStatsState> {\n\n  void takeHit() {\n    bloc.add(const PlayerDamaged());\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Getting Started¶: Let’s start by creating our game class and the GameWidget that will run it.", "completion": "import 'package:flutter/material.dart';\nimport 'package:flame/game.dart';\n\nclass SpaceShooterGame extends FlameGame {\n}\n\nvoid main() {\n  runApp(GameWidget(game: SpaceShooterGame()));\n}"}
{"prompt": "Show me how to implement Getting Started¶: Let’s start by creating our game class and the GameWidget that will run it. using Flutter Flame", "completion": "import 'package:flutter/material.dart';\nimport 'package:flame/game.dart';\n\nclass SpaceShooterGame extends FlameGame {\n}\n\nvoid main() {\n  runApp(GameWidget(game: SpaceShooterGame()));\n}"}
{"prompt": "Write Flutter Flame code to Getting Started¶: Let’s start by creating our game class and the GameWidget that will run it.", "completion": "import 'package:flutter/material.dart';\nimport 'package:flame/game.dart';\n\nclass SpaceShooterGame extends FlameGame {\n}\n\nvoid main() {\n  runApp(GameWidget(game: SpaceShooterGame()));\n}"}
{"prompt": "Create a Flutter Flame game component that Getting Started¶: Next, let’s create our player component. To do so, we will create a new class based on Flame’s PositionComponent. This component is the base for all components that have a position and a size on the game screen. For now, our component will only render a white square; it could be implemented as follows:", "completion": "import 'package:flame/components.dart';\nimport 'package:flutter/material.dart';\n\nclass Player extends PositionComponent {\n  static final _paint = Paint()..color = Colors.white;\n\n  @override\n  void render(Canvas canvas) {\n    canvas.drawRect(size.toRect(), _paint);\n  }\n}"}
{"prompt": "Show me how to implement Getting Started¶: Next, let’s create our player component. To do so, we will create a new class based on Flame’s PositionComponent. This component is the base for all components that have a position and a size on the game screen. For now, our component will only render a white square; it could be implemented as follows: using Flutter Flame", "completion": "import 'package:flame/components.dart';\nimport 'package:flutter/material.dart';\n\nclass Player extends PositionComponent {\n  static final _paint = Paint()..color = Colors.white;\n\n  @override\n  void render(Canvas canvas) {\n    canvas.drawRect(size.toRect(), _paint);\n  }\n}"}
{"prompt": "Write Flutter Flame code to Getting Started¶: Next, let’s create our player component. To do so, we will create a new class based on Flame’s PositionComponent. This component is the base for all components that have a position and a size on the game screen. For now, our component will only render a white square; it could be implemented as follows:", "completion": "import 'package:flame/components.dart';\nimport 'package:flutter/material.dart';\n\nclass Player extends PositionComponent {\n  static final _paint = Paint()..color = Colors.white;\n\n  @override\n  void render(Canvas canvas) {\n    canvas.drawRect(size.toRect(), _paint);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Getting Started¶: Now, let’s add our new component to the game. Adding any component on game startup should be done in the onLoad method, so let’s override FlameGame.onLoad and add our logic there. The modified code will look like the following:", "completion": "class SpaceShooterGame extends FlameGame {\n  @override\n  Future<void> onLoad() async {\n    await super.onLoad();\n\n    add(\n      Player()\n        ..position = size / 2\n        ..width = 50\n        ..height = 100\n        ..anchor = Anchor.center,\n    );\n  }\n}"}
{"prompt": "Show me how to implement Getting Started¶: Now, let’s add our new component to the game. Adding any component on game startup should be done in the onLoad method, so let’s override FlameGame.onLoad and add our logic there. The modified code will look like the following: using Flutter Flame", "completion": "class SpaceShooterGame extends FlameGame {\n  @override\n  Future<void> onLoad() async {\n    await super.onLoad();\n\n    add(\n      Player()\n        ..position = size / 2\n        ..width = 50\n        ..height = 100\n        ..anchor = Anchor.center,\n    );\n  }\n}"}
{"prompt": "Write Flutter Flame code to Getting Started¶: Now, let’s add our new component to the game. Adding any component on game startup should be done in the onLoad method, so let’s override FlameGame.onLoad and add our logic there. The modified code will look like the following:", "completion": "class SpaceShooterGame extends FlameGame {\n  @override\n  Future<void> onLoad() async {\n    await super.onLoad();\n\n    add(\n      Player()\n        ..position = size / 2\n        ..width = 50\n        ..height = 100\n        ..anchor = Anchor.center,\n    );\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Getting Started¶: And that is it for this first part! In this first step, we learned the basics of how to create a game class, insert it into the Flutter widget tree, and render a simple component.", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/game.dart';\nimport 'package:flutter/material.dart';\n\nvoid main() {\nrunApp(GameWidget(game: SpaceShooterGame()));\n}\n\nclass Player extends PositionComponent {\nstatic final _paint = Paint()..color = Colors.white;\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRect(size.toRect(), _paint);\n}\n}\n\nclass SpaceShooterGame extends FlameGame {\n@override\nFuture<void> onLoad() async {\nadd(\nPlayer()\n..position = size / 2\n..width = 50\n..height = 100\n..anchor = Anchor.center,\n);\n}\n}"}
{"prompt": "Show me how to implement Getting Started¶: And that is it for this first part! In this first step, we learned the basics of how to create a game class, insert it into the Flutter widget tree, and render a simple component. using Flutter Flame", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/game.dart';\nimport 'package:flutter/material.dart';\n\nvoid main() {\nrunApp(GameWidget(game: SpaceShooterGame()));\n}\n\nclass Player extends PositionComponent {\nstatic final _paint = Paint()..color = Colors.white;\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRect(size.toRect(), _paint);\n}\n}\n\nclass SpaceShooterGame extends FlameGame {\n@override\nFuture<void> onLoad() async {\nadd(\nPlayer()\n..position = size / 2\n..width = 50\n..height = 100\n..anchor = Anchor.center,\n);\n}\n}"}
{"prompt": "Write Flutter Flame code to Getting Started¶: And that is it for this first part! In this first step, we learned the basics of how to create a game class, insert it into the Flutter widget tree, and render a simple component.", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/game.dart';\nimport 'package:flutter/material.dart';\n\nvoid main() {\nrunApp(GameWidget(game: SpaceShooterGame()));\n}\n\nclass Player extends PositionComponent {\nstatic final _paint = Paint()..color = Colors.white;\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRect(size.toRect(), _paint);\n}\n}\n\nclass SpaceShooterGame extends FlameGame {\n@override\nFuture<void> onLoad() async {\nadd(\nPlayer()\n..position = size / 2\n..width = 50\n..height = 100\n..anchor = Anchor.center,\n);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that Stock pile¶: Having this in mind, let’s start implementing the StockPile component:", "completion": "class StockPile extends PositionComponent {\n  StockPile({super.position}) : super(size: KlondikeGame.cardSize);\n\n  /// Which cards are currently placed onto this pile. The first card in the\n  /// list is at the bottom, the last card is on top.\n  final List<Card> _cards = [];\n\n  void acquireCard(Card card) {\n    assert(!card.isFaceUp);\n    card.position = position;\n    card.priority = _cards.length;\n    _cards.add(card);\n  }\n}"}
{"prompt": "Show me how to implement Stock pile¶: Having this in mind, let’s start implementing the StockPile component: using Flutter Flame", "completion": "class StockPile extends PositionComponent {\n  StockPile({super.position}) : super(size: KlondikeGame.cardSize);\n\n  /// Which cards are currently placed onto this pile. The first card in the\n  /// list is at the bottom, the last card is on top.\n  final List<Card> _cards = [];\n\n  void acquireCard(Card card) {\n    assert(!card.isFaceUp);\n    card.position = position;\n    card.priority = _cards.length;\n    _cards.add(card);\n  }\n}"}
{"prompt": "Write Flutter Flame code to Stock pile¶: Having this in mind, let’s start implementing the StockPile component:", "completion": "class StockPile extends PositionComponent {\n  StockPile({super.position}) : super(size: KlondikeGame.cardSize);\n\n  /// Which cards are currently placed onto this pile. The first card in the\n  /// list is at the bottom, the last card is on top.\n  final List<Card> _cards = [];\n\n  void acquireCard(Card card) {\n    assert(!card.isFaceUp);\n    card.position = position;\n    card.priority = _cards.length;\n    _cards.add(card);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Waste pile¶: Let’s start implementing the WastePile class same way as we did with the StockPile class, only now the cards are expected to be face up:", "completion": "class WastePile extends PositionComponent {\n  WastePile({super.position}) : super(size: KlondikeGame.cardSize);\n\n  final List<Card> _cards = [];\n\n  void acquireCard(Card card) {\n    assert(card.isFaceUp);\n    card.position = position;\n    card.priority = _cards.length;\n    _cards.add(card);\n  }\n}"}
{"prompt": "Show me how to implement Waste pile¶: Let’s start implementing the WastePile class same way as we did with the StockPile class, only now the cards are expected to be face up: using Flutter Flame", "completion": "class WastePile extends PositionComponent {\n  WastePile({super.position}) : super(size: KlondikeGame.cardSize);\n\n  final List<Card> _cards = [];\n\n  void acquireCard(Card card) {\n    assert(card.isFaceUp);\n    card.position = position;\n    card.priority = _cards.length;\n    _cards.add(card);\n  }\n}"}
{"prompt": "Write Flutter Flame code to Waste pile¶: Let’s start implementing the WastePile class same way as we did with the StockPile class, only now the cards are expected to be face up:", "completion": "class WastePile extends PositionComponent {\n  WastePile({super.position}) : super(size: KlondikeGame.cardSize);\n\n  final List<Card> _cards = [];\n\n  void acquireCard(Card card) {\n    assert(card.isFaceUp);\n    card.position = position;\n    card.priority = _cards.length;\n    _cards.add(card);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Stock pile – visual representation¶: In our case, the empty stock pile will have a card-like border, and a circle in the middle:", "completion": "@override\n  void render(Canvas canvas) {\n    canvas.drawRRect(KlondikeGame.cardRRect, _borderPaint);\n    canvas.drawCircle(\n      Offset(width / 2, height / 2),\n      KlondikeGame.cardWidth * 0.3,\n      _circlePaint,\n    );\n  }"}
{"prompt": "Show me how to implement Stock pile – visual representation¶: In our case, the empty stock pile will have a card-like border, and a circle in the middle: using Flutter Flame", "completion": "@override\n  void render(Canvas canvas) {\n    canvas.drawRRect(KlondikeGame.cardRRect, _borderPaint);\n    canvas.drawCircle(\n      Offset(width / 2, height / 2),\n      KlondikeGame.cardWidth * 0.3,\n      _circlePaint,\n    );\n  }"}
{"prompt": "Write Flutter Flame code to Stock pile – visual representation¶: In our case, the empty stock pile will have a card-like border, and a circle in the middle:", "completion": "@override\n  void render(Canvas canvas) {\n    canvas.drawRRect(KlondikeGame.cardRRect, _borderPaint);\n    canvas.drawCircle(\n      Offset(width / 2, height / 2),\n      KlondikeGame.cardWidth * 0.3,\n      _circlePaint,\n    );\n  }"}
{"prompt": "Create a Flutter Flame game component that Foundation piles¶: First, let’s implement the card-holding logic:", "completion": "class FoundationPile extends PositionComponent {\n  FoundationPile({super.position}) : super(size: KlondikeGame.cardSize);\n\n  final List<Card> _cards = [];\n\n  void acquireCard(Card card) {\n    assert(card.isFaceUp);\n    card.position = position;\n    card.priority = _cards.length;\n    _cards.add(card);\n  }\n}"}
{"prompt": "Show me how to implement Foundation piles¶: First, let’s implement the card-holding logic: using Flutter Flame", "completion": "class FoundationPile extends PositionComponent {\n  FoundationPile({super.position}) : super(size: KlondikeGame.cardSize);\n\n  final List<Card> _cards = [];\n\n  void acquireCard(Card card) {\n    assert(card.isFaceUp);\n    card.position = position;\n    card.priority = _cards.length;\n    _cards.add(card);\n  }\n}"}
{"prompt": "Write Flutter Flame code to Foundation piles¶: First, let’s implement the card-holding logic:", "completion": "class FoundationPile extends PositionComponent {\n  FoundationPile({super.position}) : super(size: KlondikeGame.cardSize);\n\n  final List<Card> _cards = [];\n\n  void acquireCard(Card card) {\n    assert(card.isFaceUp);\n    card.position = position;\n    card.priority = _cards.length;\n    _cards.add(card);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Foundation piles¶: For visual representation of a foundation, I’ve decided to make a large icon of that foundation’s suit, in grey color. Which means we’d need to update the definition of the class to include the suit information:", "completion": "class FoundationPile extends PositionComponent {\n  FoundationPile(int intSuit, {super.position})\n      : suit = Suit.fromInt(intSuit),\n        super(size: KlondikeGame.cardSize);\n\n  final Suit suit;\n  ...\n}"}
{"prompt": "Show me how to implement Foundation piles¶: For visual representation of a foundation, I’ve decided to make a large icon of that foundation’s suit, in grey color. Which means we’d need to update the definition of the class to include the suit information: using Flutter Flame", "completion": "class FoundationPile extends PositionComponent {\n  FoundationPile(int intSuit, {super.position})\n      : suit = Suit.fromInt(intSuit),\n        super(size: KlondikeGame.cardSize);\n\n  final Suit suit;\n  ...\n}"}
{"prompt": "Write Flutter Flame code to Foundation piles¶: For visual representation of a foundation, I’ve decided to make a large icon of that foundation’s suit, in grey color. Which means we’d need to update the definition of the class to include the suit information:", "completion": "class FoundationPile extends PositionComponent {\n  FoundationPile(int intSuit, {super.position})\n      : suit = Suit.fromInt(intSuit),\n        super(size: KlondikeGame.cardSize);\n\n  final Suit suit;\n  ...\n}"}
{"prompt": "Create a Flutter Flame game component that Foundation piles¶: Now, the rendering code for the foundation pile will look like this:", "completion": "@override\n  void render(Canvas canvas) {\n    canvas.drawRRect(KlondikeGame.cardRRect, _borderPaint);\n    suit.sprite.render(\n      canvas,\n      position: size / 2,\n      anchor: Anchor.center,\n      size: Vector2.all(KlondikeGame.cardWidth * 0.6),\n      overridePaint: _suitPaint,\n    );\n  }"}
{"prompt": "Show me how to implement Foundation piles¶: Now, the rendering code for the foundation pile will look like this: using Flutter Flame", "completion": "@override\n  void render(Canvas canvas) {\n    canvas.drawRRect(KlondikeGame.cardRRect, _borderPaint);\n    suit.sprite.render(\n      canvas,\n      position: size / 2,\n      anchor: Anchor.center,\n      size: Vector2.all(KlondikeGame.cardWidth * 0.6),\n      overridePaint: _suitPaint,\n    );\n  }"}
{"prompt": "Write Flutter Flame code to Foundation piles¶: Now, the rendering code for the foundation pile will look like this:", "completion": "@override\n  void render(Canvas canvas) {\n    canvas.drawRRect(KlondikeGame.cardRRect, _borderPaint);\n    suit.sprite.render(\n      canvas,\n      position: size / 2,\n      anchor: Anchor.center,\n      size: Vector2.all(KlondikeGame.cardWidth * 0.6),\n      overridePaint: _suitPaint,\n    );\n  }"}
{"prompt": "Create a Flutter Flame game component that Tableau Piles¶: The TableauPile also needs a visual representation, in order to indicate that it’s a place where a King can be placed when it is empty. I believe it could be just an empty frame, and that should be sufficient:", "completion": "class TableauPile extends PositionComponent {\n  TableauPile({super.position}) : super(size: KlondikeGame.cardSize);\n\n  final _borderPaint = Paint()\n    ..style = PaintingStyle.stroke\n    ..strokeWidth = 10\n    ..color = const Color(0x50ffffff);\n\n  @override\n  void render(Canvas canvas) {\n    canvas.drawRRect(KlondikeGame.cardRRect, _borderPaint);\n  }\n}"}
{"prompt": "Show me how to implement Tableau Piles¶: The TableauPile also needs a visual representation, in order to indicate that it’s a place where a King can be placed when it is empty. I believe it could be just an empty frame, and that should be sufficient: using Flutter Flame", "completion": "class TableauPile extends PositionComponent {\n  TableauPile({super.position}) : super(size: KlondikeGame.cardSize);\n\n  final _borderPaint = Paint()\n    ..style = PaintingStyle.stroke\n    ..strokeWidth = 10\n    ..color = const Color(0x50ffffff);\n\n  @override\n  void render(Canvas canvas) {\n    canvas.drawRRect(KlondikeGame.cardRRect, _borderPaint);\n  }\n}"}
{"prompt": "Write Flutter Flame code to Tableau Piles¶: The TableauPile also needs a visual representation, in order to indicate that it’s a place where a King can be placed when it is empty. I believe it could be just an empty frame, and that should be sufficient:", "completion": "class TableauPile extends PositionComponent {\n  TableauPile({super.position}) : super(size: KlondikeGame.cardSize);\n\n  final _borderPaint = Paint()\n    ..style = PaintingStyle.stroke\n    ..strokeWidth = 10\n    ..color = const Color(0x50ffffff);\n\n  @override\n  void render(Canvas canvas) {\n    canvas.drawRRect(KlondikeGame.cardRRect, _borderPaint);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Tableau Piles¶: Oh, and the class will need to be able hold the cards too, obviously. Here, some of the cards will be face down, while others will be face up. Also we will need a small amount of vertical fanning, similar to how we did it for the WastePile component:", "completion": "/// Which cards are currently placed onto this pile.\n  final List<Card> _cards = [];\n  final Vector2 _fanOffset = Vector2(0, KlondikeGame.cardHeight * 0.05);\n\n  void acquireCard(Card card) {\n    if (_cards.isEmpty) {\n      card.position = position;\n    } else {\n      card.position = _cards.last.position + _fanOffset;\n    }\n    card.priority = _cards.length;\n    _cards.add(card);\n  }"}
{"prompt": "Show me how to implement Tableau Piles¶: Oh, and the class will need to be able hold the cards too, obviously. Here, some of the cards will be face down, while others will be face up. Also we will need a small amount of vertical fanning, similar to how we did it for the WastePile component: using Flutter Flame", "completion": "/// Which cards are currently placed onto this pile.\n  final List<Card> _cards = [];\n  final Vector2 _fanOffset = Vector2(0, KlondikeGame.cardHeight * 0.05);\n\n  void acquireCard(Card card) {\n    if (_cards.isEmpty) {\n      card.position = position;\n    } else {\n      card.position = _cards.last.position + _fanOffset;\n    }\n    card.priority = _cards.length;\n    _cards.add(card);\n  }"}
{"prompt": "Write Flutter Flame code to Tableau Piles¶: Oh, and the class will need to be able hold the cards too, obviously. Here, some of the cards will be face down, while others will be face up. Also we will need a small amount of vertical fanning, similar to how we did it for the WastePile component:", "completion": "/// Which cards are currently placed onto this pile.\n  final List<Card> _cards = [];\n  final Vector2 _fanOffset = Vector2(0, KlondikeGame.cardHeight * 0.05);\n\n  void acquireCard(Card card) {\n    if (_cards.isEmpty) {\n      card.position = position;\n    } else {\n      card.position = _cards.last.position + _fanOffset;\n    }\n    card.priority = _cards.length;\n    _cards.add(card);\n  }"}
{"prompt": "Create a Flutter Flame game component that 2. Move only allowed cards¶: We will expand this class further later, but for now let’s make sure that each of the classes StockPile, WastePile, FoundationPile, and TableauPile are marked as implementing this interface:", "completion": "class StockPile extends PositionComponent with TapCallbacks implements Pile {\n  ...\n  @override\n  bool canMoveCard(Card card) => false;\n}\n\nclass WastePile extends PositionComponent implements Pile {\n  ...\n  @override\n  bool canMoveCard(Card card) => _cards.isNotEmpty && card == _cards.last;\n}\n\nclass FoundationPile extends PositionComponent implements Pile {\n  ...\n  @override\n  bool canMoveCard(Card card) => _cards.isNotEmpty && card == _cards.last;\n}\n\nclass TableauPile extends PositionComponent implements Pile {\n  ...\n  @override\n  bool canMoveCard(Card card) => _cards.isNotEmpty && card == _cards.last;\n}"}
{"prompt": "Show me how to implement 2. Move only allowed cards¶: We will expand this class further later, but for now let’s make sure that each of the classes StockPile, WastePile, FoundationPile, and TableauPile are marked as implementing this interface: using Flutter Flame", "completion": "class StockPile extends PositionComponent with TapCallbacks implements Pile {\n  ...\n  @override\n  bool canMoveCard(Card card) => false;\n}\n\nclass WastePile extends PositionComponent implements Pile {\n  ...\n  @override\n  bool canMoveCard(Card card) => _cards.isNotEmpty && card == _cards.last;\n}\n\nclass FoundationPile extends PositionComponent implements Pile {\n  ...\n  @override\n  bool canMoveCard(Card card) => _cards.isNotEmpty && card == _cards.last;\n}\n\nclass TableauPile extends PositionComponent implements Pile {\n  ...\n  @override\n  bool canMoveCard(Card card) => _cards.isNotEmpty && card == _cards.last;\n}"}
{"prompt": "Write Flutter Flame code to 2. Move only allowed cards¶: We will expand this class further later, but for now let’s make sure that each of the classes StockPile, WastePile, FoundationPile, and TableauPile are marked as implementing this interface:", "completion": "class StockPile extends PositionComponent with TapCallbacks implements Pile {\n  ...\n  @override\n  bool canMoveCard(Card card) => false;\n}\n\nclass WastePile extends PositionComponent implements Pile {\n  ...\n  @override\n  bool canMoveCard(Card card) => _cards.isNotEmpty && card == _cards.last;\n}\n\nclass FoundationPile extends PositionComponent implements Pile {\n  ...\n  @override\n  bool canMoveCard(Card card) => _cards.isNotEmpty && card == _cards.last;\n}\n\nclass TableauPile extends PositionComponent implements Pile {\n  ...\n  @override\n  bool canMoveCard(Card card) => _cards.isNotEmpty && card == _cards.last;\n}"}
{"prompt": "Create a Flutter Flame game component that 4. Moving a run of cards¶: So, let’s head over into the TableauPile class and create a new method layOutCards(), whose job would be to ensure that all cards currently in the pile have the right positions:", "completion": "final Vector2 _fanOffset1 = Vector2(0, KlondikeGame.cardHeight * 0.05);\n  final Vector2 _fanOffset2 = Vector2(0, KlondikeGame.cardHeight * 0.20);\n\n  void layOutCards() {\n    if (_cards.isEmpty) {\n      return;\n    }\n    _cards[0].position.setFrom(position);\n    for (var i = 1; i < _cards.length; i++) {\n      _cards[i].position\n        ..setFrom(_cards[i - 1].position)\n        ..add(_cards[i - 1].isFaceDown ? _fanOffset1 : _fanOffset2);\n    }\n  }"}
{"prompt": "Show me how to implement 4. Moving a run of cards¶: So, let’s head over into the TableauPile class and create a new method layOutCards(), whose job would be to ensure that all cards currently in the pile have the right positions: using Flutter Flame", "completion": "final Vector2 _fanOffset1 = Vector2(0, KlondikeGame.cardHeight * 0.05);\n  final Vector2 _fanOffset2 = Vector2(0, KlondikeGame.cardHeight * 0.20);\n\n  void layOutCards() {\n    if (_cards.isEmpty) {\n      return;\n    }\n    _cards[0].position.setFrom(position);\n    for (var i = 1; i < _cards.length; i++) {\n      _cards[i].position\n        ..setFrom(_cards[i - 1].position)\n        ..add(_cards[i - 1].isFaceDown ? _fanOffset1 : _fanOffset2);\n    }\n  }"}
{"prompt": "Write Flutter Flame code to 4. Moving a run of cards¶: So, let’s head over into the TableauPile class and create a new method layOutCards(), whose job would be to ensure that all cards currently in the pile have the right positions:", "completion": "final Vector2 _fanOffset1 = Vector2(0, KlondikeGame.cardHeight * 0.05);\n  final Vector2 _fanOffset2 = Vector2(0, KlondikeGame.cardHeight * 0.20);\n\n  void layOutCards() {\n    if (_cards.isEmpty) {\n      return;\n    }\n    _cards[0].position.setFrom(position);\n    for (var i = 1; i < _cards.length; i++) {\n      _cards[i].position\n        ..setFrom(_cards[i - 1].position)\n        ..add(_cards[i - 1].isFaceDown ? _fanOffset1 : _fanOffset2);\n    }\n  }"}
{"prompt": "Create a Flutter Flame game component that 4. Moving a run of cards¶: Well, this is it! The game is now fully playable. Press the button below to see what the resulting code looks like, or to play it live. In the next section we will discuss how to make it more animated with the help of effects.", "completion": "import 'dart:math';\nimport 'dart:ui';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport '../klondike_game.dart';\nimport '../pile.dart';\nimport '../rank.dart';\nimport '../suit.dart';\nimport 'tableau_pile.dart';\n\nclass Card extends PositionComponent with DragCallbacks {\nCard(int intRank, int intSuit)\n: rank = Rank.fromInt(intRank),\nsuit = Suit.fromInt(intSuit),\nsuper(size: KlondikeGame.cardSize);\n\nfinal Rank rank;\nfinal Suit suit;\nPile? pile;\nbool _faceUp = false;\nbool _isDragging = false;\nfinal List<Card> attachedCards = [];\n\nbool get isFaceUp => _faceUp;\nbool get isFaceDown => !_faceUp;\nvoid flip() => _faceUp = !_faceUp;\n\n@override\nString toString() => rank.label + suit.label; // e.g. \"Q♠\" or \"10♦\"\n\n//#region Rendering\n\n@override\nvoid render(Canvas canvas) {\nif (_faceUp) {\n_renderFront(canvas);\n} else {\n_renderBack(canvas);\n}\n}\n\nstatic final Paint backBackgroundPaint = Paint()\n..color = const Color(0xff380c02);\nstatic final Paint backBorderPaint1 = Paint()\n..color = const Color(0xffdbaf58)\n..style = PaintingStyle.stroke\n..strokeWidth = 10;\nstatic final Paint backBorderPaint2 = Paint()\n..color = const Color(0x5CEF971B)\n..style = PaintingStyle.stroke\n..strokeWidth = 35;\nstatic final RRect cardRRect = RRect.fromRectAndRadius(\nKlondikeGame.cardSize.toRect(),\nconst Radius.circular(KlondikeGame.cardRadius),\n);\nstatic final RRect backRRectInner = cardRRect.deflate(40);\nstatic final Sprite flameSprite = klondikeSprite(1367, 6, 357, 501);\n\nvoid _renderBack(Canvas canvas) {\ncanvas.drawRRect(cardRRect, backBackgroundPaint);\ncanvas.drawRRect(cardRRect, backBorderPaint1);\ncanvas.drawRRect(backRRectInner, backBorderPaint2);\nflameSprite.render(canvas, position: size / 2, anchor: Anchor.center);\n}\n\nstatic final Paint frontBackgroundPaint = Paint()\n..color = const Color(0xff000000);\nstatic final Paint redBorderPaint = Paint()\n..color = const Color(0xffece8a3)\n..style = PaintingStyle.stroke\n..strokeWidth = 10;\nstatic final Paint blackBorderPaint = Paint()\n..color = const Color(0xff7ab2e8)\n..style = PaintingStyle.stroke\n..strokeWidth = 10;\nstatic final blueFilter = Paint()\n..colorFilter = const ColorFilter.mode(\nColor(0x880d8bff),\nBlendMode.srcATop,\n);\nstatic final Sprite redJack = klondikeSprite(81, 565, 562, 488);\nstatic final Sprite redQueen = klondikeSprite(717, 541, 486, 515);\nstatic final Sprite redKing = klondikeSprite(1305, 532, 407, 549);\nstatic final Sprite blackJack = klondikeSprite(81, 565, 562, 488)\n..paint = blueFilter;\nstatic final Sprite blackQueen = klondikeSprite(717, 541, 486, 515)\n..paint = blueFilter;\nstatic final Sprite blackKing = klondikeSprite(1305, 532, 407, 549)\n..paint = blueFilter;\n\nvoid _renderFront(Canvas canvas) {\ncanvas.drawRRect(cardRRect, frontBackgroundPaint);\ncanvas.drawRRect(\ncardRRect,\nsuit.isRed ? redBorderPaint : blackBorderPaint,\n);\n\nfinal rankSprite = suit.isBlack ? rank.blackSprite : rank.redSprite;\nfinal suitSprite = suit.sprite;\n_drawSprite(canvas, rankSprite, 0.1, 0.08);\n_drawSprite(canvas, suitSprite, 0.1, 0.18, scale: 0.5);\n_drawSprite(canvas, rankSprite, 0.1, 0.08, rotate: true);\n_drawSprite(canvas, suitSprite, 0.1, 0.18, scale: 0.5, rotate: true);\nswitch (rank.value) {\ncase 1:\n_drawSprite(canvas, suitSprite, 0.5, 0.5, scale: 2.5);\ncase 2:\n_drawSprite(canvas, suitSprite, 0.5, 0.25);\n_drawSprite(canvas, suitSprite, 0.5, 0.25, rotate: true);\ncase 3:\n_drawSprite(canvas, suitSprite, 0.5, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.5);\n_drawSprite(canvas, suitSprite, 0.5, 0.2, rotate: true);\ncase 4:\n_drawSprite(canvas, suitSprite, 0.3, 0.25);\n_drawSprite(canvas, suitSprite, 0.7, 0.25);\n_drawSprite(canvas, suitSprite, 0.3, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.25, rotate: true);\ncase 5:\n_drawSprite(canvas, suitSprite, 0.3, 0.25);\n_drawSprite(canvas, suitSprite, 0.7, 0.25);\n_drawSprite(canvas, suitSprite, 0.3, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.5, 0.5);\ncase 6:\n_drawSprite(canvas, suitSprite, 0.3, 0.25);\n_drawSprite(canvas, suitSprite, 0.7, 0.25);\n_drawSprite(canvas, suitSprite, 0.3, 0.5);\n_drawSprite(canvas, suitSprite, 0.7, 0.5);\n_drawSprite(canvas, suitSprite, 0.3, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.25, rotate: true);\ncase 7:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.35);\n_drawSprite(canvas, suitSprite, 0.3, 0.5);\n_drawSprite(canvas, suitSprite, 0.7, 0.5);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\ncase 8:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.35);\n_drawSprite(canvas, suitSprite, 0.3, 0.5);\n_drawSprite(canvas, suitSprite, 0.7, 0.5);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.5, 0.35, rotate: true);\ncase 9:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.3);\n_drawSprite(canvas, suitSprite, 0.3, 0.4);\n_drawSprite(canvas, suitSprite, 0.7, 0.4);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.3, 0.4, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.4, rotate: true);\ncase 10:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.3);\n_drawSprite(canvas, suitSprite, 0.3, 0.4);\n_drawSprite(canvas, suitSprite, 0.7, 0.4);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.5, 0.3, rotate: true);\n_drawSprite(canvas, suitSprite, 0.3, 0.4, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.4, rotate: true);\ncase 11:\n_drawSprite(canvas, suit.isRed ? redJack : blackJack, 0.5, 0.5);\ncase 12:\n_drawSprite(canvas, suit.isRed ? redQueen : blackQueen, 0.5, 0.5);\ncase 13:\n_drawSprite(canvas, suit.isRed ? redKing : blackKing, 0.5, 0.5);\n}\n}\n\nvoid _drawSprite(\nCanvas canvas,\nSprite sprite,\ndouble relativeX,\ndouble relativeY, {\ndouble scale = 1,\nbool rotate = false,\n}) {\nif (rotate) {\ncanvas.save();\ncanvas.translate(size.x / 2, size.y / 2);\ncanvas.rotate(pi);\ncanvas.translate(-size.x / 2, -size.y / 2);\n}\nsprite.render(\ncanvas,\nposition: Vector2(relativeX * size.x, relativeY * size.y),\nanchor: Anchor.center,\nsize: sprite.srcSize.scaled(scale),\n);\nif (rotate) {\ncanvas.restore();\n}\n}\n\n//#endregion\n\n//#region Dragging\n\n@override\nvoid onDragStart(DragStartEvent event) {\nsuper.onDragStart(event);\nif (pile?.canMoveCard(this) ?? false) {\n_isDragging = true;\npriority = 100;\nif (pile is TableauPile) {\nattachedCards.clear();\nfinal extraCards = (pile! as TableauPile).cardsOnTop(this);\nfor (final card in extraCards) {\ncard.priority = attachedCards.length + 101;\nattachedCards.add(card);\n}\n}\n}\n}\n\n@override\nvoid onDragUpdate(DragUpdateEvent event) {\nif (!_isDragging) {\nreturn;\n}\nfinal delta = event.localDelta;\nposition.add(delta);\nattachedCards.forEach((card) => card.position.add(delta));\n}\n\n@override\nvoid onDragEnd(DragEndEvent event) {\nsuper.onDragEnd(event);\nif (!_isDragging) {\nreturn;\n}\n_isDragging = false;\nfinal dropPiles = parent!\n.componentsAtPoint(position + size / 2)\n.whereType<Pile>()\n.toList();\nif (dropPiles.isNotEmpty) {\nif (dropPiles.first.canAcceptCard(this)) {\npile!.removeCard(this);\ndropPiles.first.acquireCard(this);\nif (attachedCards.isNotEmpty) {\nattachedCards.forEach((card) => dropPiles.first.acquireCard(card));\nattachedCards.clear();\n}\nreturn;\n}\n}\npile!.returnCard(this);\nif (attachedCards.isNotEmpty) {\nattachedCards.forEach((card) => pile!.returnCard(card));\nattachedCards.clear();\n}\n}\n\n//#endregion\n}"}
{"prompt": "Show me how to implement 4. Moving a run of cards¶: Well, this is it! The game is now fully playable. Press the button below to see what the resulting code looks like, or to play it live. In the next section we will discuss how to make it more animated with the help of effects. using Flutter Flame", "completion": "import 'dart:math';\nimport 'dart:ui';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport '../klondike_game.dart';\nimport '../pile.dart';\nimport '../rank.dart';\nimport '../suit.dart';\nimport 'tableau_pile.dart';\n\nclass Card extends PositionComponent with DragCallbacks {\nCard(int intRank, int intSuit)\n: rank = Rank.fromInt(intRank),\nsuit = Suit.fromInt(intSuit),\nsuper(size: KlondikeGame.cardSize);\n\nfinal Rank rank;\nfinal Suit suit;\nPile? pile;\nbool _faceUp = false;\nbool _isDragging = false;\nfinal List<Card> attachedCards = [];\n\nbool get isFaceUp => _faceUp;\nbool get isFaceDown => !_faceUp;\nvoid flip() => _faceUp = !_faceUp;\n\n@override\nString toString() => rank.label + suit.label; // e.g. \"Q♠\" or \"10♦\"\n\n//#region Rendering\n\n@override\nvoid render(Canvas canvas) {\nif (_faceUp) {\n_renderFront(canvas);\n} else {\n_renderBack(canvas);\n}\n}\n\nstatic final Paint backBackgroundPaint = Paint()\n..color = const Color(0xff380c02);\nstatic final Paint backBorderPaint1 = Paint()\n..color = const Color(0xffdbaf58)\n..style = PaintingStyle.stroke\n..strokeWidth = 10;\nstatic final Paint backBorderPaint2 = Paint()\n..color = const Color(0x5CEF971B)\n..style = PaintingStyle.stroke\n..strokeWidth = 35;\nstatic final RRect cardRRect = RRect.fromRectAndRadius(\nKlondikeGame.cardSize.toRect(),\nconst Radius.circular(KlondikeGame.cardRadius),\n);\nstatic final RRect backRRectInner = cardRRect.deflate(40);\nstatic final Sprite flameSprite = klondikeSprite(1367, 6, 357, 501);\n\nvoid _renderBack(Canvas canvas) {\ncanvas.drawRRect(cardRRect, backBackgroundPaint);\ncanvas.drawRRect(cardRRect, backBorderPaint1);\ncanvas.drawRRect(backRRectInner, backBorderPaint2);\nflameSprite.render(canvas, position: size / 2, anchor: Anchor.center);\n}\n\nstatic final Paint frontBackgroundPaint = Paint()\n..color = const Color(0xff000000);\nstatic final Paint redBorderPaint = Paint()\n..color = const Color(0xffece8a3)\n..style = PaintingStyle.stroke\n..strokeWidth = 10;\nstatic final Paint blackBorderPaint = Paint()\n..color = const Color(0xff7ab2e8)\n..style = PaintingStyle.stroke\n..strokeWidth = 10;\nstatic final blueFilter = Paint()\n..colorFilter = const ColorFilter.mode(\nColor(0x880d8bff),\nBlendMode.srcATop,\n);\nstatic final Sprite redJack = klondikeSprite(81, 565, 562, 488);\nstatic final Sprite redQueen = klondikeSprite(717, 541, 486, 515);\nstatic final Sprite redKing = klondikeSprite(1305, 532, 407, 549);\nstatic final Sprite blackJack = klondikeSprite(81, 565, 562, 488)\n..paint = blueFilter;\nstatic final Sprite blackQueen = klondikeSprite(717, 541, 486, 515)\n..paint = blueFilter;\nstatic final Sprite blackKing = klondikeSprite(1305, 532, 407, 549)\n..paint = blueFilter;\n\nvoid _renderFront(Canvas canvas) {\ncanvas.drawRRect(cardRRect, frontBackgroundPaint);\ncanvas.drawRRect(\ncardRRect,\nsuit.isRed ? redBorderPaint : blackBorderPaint,\n);\n\nfinal rankSprite = suit.isBlack ? rank.blackSprite : rank.redSprite;\nfinal suitSprite = suit.sprite;\n_drawSprite(canvas, rankSprite, 0.1, 0.08);\n_drawSprite(canvas, suitSprite, 0.1, 0.18, scale: 0.5);\n_drawSprite(canvas, rankSprite, 0.1, 0.08, rotate: true);\n_drawSprite(canvas, suitSprite, 0.1, 0.18, scale: 0.5, rotate: true);\nswitch (rank.value) {\ncase 1:\n_drawSprite(canvas, suitSprite, 0.5, 0.5, scale: 2.5);\ncase 2:\n_drawSprite(canvas, suitSprite, 0.5, 0.25);\n_drawSprite(canvas, suitSprite, 0.5, 0.25, rotate: true);\ncase 3:\n_drawSprite(canvas, suitSprite, 0.5, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.5);\n_drawSprite(canvas, suitSprite, 0.5, 0.2, rotate: true);\ncase 4:\n_drawSprite(canvas, suitSprite, 0.3, 0.25);\n_drawSprite(canvas, suitSprite, 0.7, 0.25);\n_drawSprite(canvas, suitSprite, 0.3, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.25, rotate: true);\ncase 5:\n_drawSprite(canvas, suitSprite, 0.3, 0.25);\n_drawSprite(canvas, suitSprite, 0.7, 0.25);\n_drawSprite(canvas, suitSprite, 0.3, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.5, 0.5);\ncase 6:\n_drawSprite(canvas, suitSprite, 0.3, 0.25);\n_drawSprite(canvas, suitSprite, 0.7, 0.25);\n_drawSprite(canvas, suitSprite, 0.3, 0.5);\n_drawSprite(canvas, suitSprite, 0.7, 0.5);\n_drawSprite(canvas, suitSprite, 0.3, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.25, rotate: true);\ncase 7:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.35);\n_drawSprite(canvas, suitSprite, 0.3, 0.5);\n_drawSprite(canvas, suitSprite, 0.7, 0.5);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\ncase 8:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.35);\n_drawSprite(canvas, suitSprite, 0.3, 0.5);\n_drawSprite(canvas, suitSprite, 0.7, 0.5);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.5, 0.35, rotate: true);\ncase 9:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.3);\n_drawSprite(canvas, suitSprite, 0.3, 0.4);\n_drawSprite(canvas, suitSprite, 0.7, 0.4);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.3, 0.4, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.4, rotate: true);\ncase 10:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.3);\n_drawSprite(canvas, suitSprite, 0.3, 0.4);\n_drawSprite(canvas, suitSprite, 0.7, 0.4);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.5, 0.3, rotate: true);\n_drawSprite(canvas, suitSprite, 0.3, 0.4, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.4, rotate: true);\ncase 11:\n_drawSprite(canvas, suit.isRed ? redJack : blackJack, 0.5, 0.5);\ncase 12:\n_drawSprite(canvas, suit.isRed ? redQueen : blackQueen, 0.5, 0.5);\ncase 13:\n_drawSprite(canvas, suit.isRed ? redKing : blackKing, 0.5, 0.5);\n}\n}\n\nvoid _drawSprite(\nCanvas canvas,\nSprite sprite,\ndouble relativeX,\ndouble relativeY, {\ndouble scale = 1,\nbool rotate = false,\n}) {\nif (rotate) {\ncanvas.save();\ncanvas.translate(size.x / 2, size.y / 2);\ncanvas.rotate(pi);\ncanvas.translate(-size.x / 2, -size.y / 2);\n}\nsprite.render(\ncanvas,\nposition: Vector2(relativeX * size.x, relativeY * size.y),\nanchor: Anchor.center,\nsize: sprite.srcSize.scaled(scale),\n);\nif (rotate) {\ncanvas.restore();\n}\n}\n\n//#endregion\n\n//#region Dragging\n\n@override\nvoid onDragStart(DragStartEvent event) {\nsuper.onDragStart(event);\nif (pile?.canMoveCard(this) ?? false) {\n_isDragging = true;\npriority = 100;\nif (pile is TableauPile) {\nattachedCards.clear();\nfinal extraCards = (pile! as TableauPile).cardsOnTop(this);\nfor (final card in extraCards) {\ncard.priority = attachedCards.length + 101;\nattachedCards.add(card);\n}\n}\n}\n}\n\n@override\nvoid onDragUpdate(DragUpdateEvent event) {\nif (!_isDragging) {\nreturn;\n}\nfinal delta = event.localDelta;\nposition.add(delta);\nattachedCards.forEach((card) => card.position.add(delta));\n}\n\n@override\nvoid onDragEnd(DragEndEvent event) {\nsuper.onDragEnd(event);\nif (!_isDragging) {\nreturn;\n}\n_isDragging = false;\nfinal dropPiles = parent!\n.componentsAtPoint(position + size / 2)\n.whereType<Pile>()\n.toList();\nif (dropPiles.isNotEmpty) {\nif (dropPiles.first.canAcceptCard(this)) {\npile!.removeCard(this);\ndropPiles.first.acquireCard(this);\nif (attachedCards.isNotEmpty) {\nattachedCards.forEach((card) => dropPiles.first.acquireCard(card));\nattachedCards.clear();\n}\nreturn;\n}\n}\npile!.returnCard(this);\nif (attachedCards.isNotEmpty) {\nattachedCards.forEach((card) => pile!.returnCard(card));\nattachedCards.clear();\n}\n}\n\n//#endregion\n}"}
{"prompt": "Write Flutter Flame code to 4. Moving a run of cards¶: Well, this is it! The game is now fully playable. Press the button below to see what the resulting code looks like, or to play it live. In the next section we will discuss how to make it more animated with the help of effects.", "completion": "import 'dart:math';\nimport 'dart:ui';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport '../klondike_game.dart';\nimport '../pile.dart';\nimport '../rank.dart';\nimport '../suit.dart';\nimport 'tableau_pile.dart';\n\nclass Card extends PositionComponent with DragCallbacks {\nCard(int intRank, int intSuit)\n: rank = Rank.fromInt(intRank),\nsuit = Suit.fromInt(intSuit),\nsuper(size: KlondikeGame.cardSize);\n\nfinal Rank rank;\nfinal Suit suit;\nPile? pile;\nbool _faceUp = false;\nbool _isDragging = false;\nfinal List<Card> attachedCards = [];\n\nbool get isFaceUp => _faceUp;\nbool get isFaceDown => !_faceUp;\nvoid flip() => _faceUp = !_faceUp;\n\n@override\nString toString() => rank.label + suit.label; // e.g. \"Q♠\" or \"10♦\"\n\n//#region Rendering\n\n@override\nvoid render(Canvas canvas) {\nif (_faceUp) {\n_renderFront(canvas);\n} else {\n_renderBack(canvas);\n}\n}\n\nstatic final Paint backBackgroundPaint = Paint()\n..color = const Color(0xff380c02);\nstatic final Paint backBorderPaint1 = Paint()\n..color = const Color(0xffdbaf58)\n..style = PaintingStyle.stroke\n..strokeWidth = 10;\nstatic final Paint backBorderPaint2 = Paint()\n..color = const Color(0x5CEF971B)\n..style = PaintingStyle.stroke\n..strokeWidth = 35;\nstatic final RRect cardRRect = RRect.fromRectAndRadius(\nKlondikeGame.cardSize.toRect(),\nconst Radius.circular(KlondikeGame.cardRadius),\n);\nstatic final RRect backRRectInner = cardRRect.deflate(40);\nstatic final Sprite flameSprite = klondikeSprite(1367, 6, 357, 501);\n\nvoid _renderBack(Canvas canvas) {\ncanvas.drawRRect(cardRRect, backBackgroundPaint);\ncanvas.drawRRect(cardRRect, backBorderPaint1);\ncanvas.drawRRect(backRRectInner, backBorderPaint2);\nflameSprite.render(canvas, position: size / 2, anchor: Anchor.center);\n}\n\nstatic final Paint frontBackgroundPaint = Paint()\n..color = const Color(0xff000000);\nstatic final Paint redBorderPaint = Paint()\n..color = const Color(0xffece8a3)\n..style = PaintingStyle.stroke\n..strokeWidth = 10;\nstatic final Paint blackBorderPaint = Paint()\n..color = const Color(0xff7ab2e8)\n..style = PaintingStyle.stroke\n..strokeWidth = 10;\nstatic final blueFilter = Paint()\n..colorFilter = const ColorFilter.mode(\nColor(0x880d8bff),\nBlendMode.srcATop,\n);\nstatic final Sprite redJack = klondikeSprite(81, 565, 562, 488);\nstatic final Sprite redQueen = klondikeSprite(717, 541, 486, 515);\nstatic final Sprite redKing = klondikeSprite(1305, 532, 407, 549);\nstatic final Sprite blackJack = klondikeSprite(81, 565, 562, 488)\n..paint = blueFilter;\nstatic final Sprite blackQueen = klondikeSprite(717, 541, 486, 515)\n..paint = blueFilter;\nstatic final Sprite blackKing = klondikeSprite(1305, 532, 407, 549)\n..paint = blueFilter;\n\nvoid _renderFront(Canvas canvas) {\ncanvas.drawRRect(cardRRect, frontBackgroundPaint);\ncanvas.drawRRect(\ncardRRect,\nsuit.isRed ? redBorderPaint : blackBorderPaint,\n);\n\nfinal rankSprite = suit.isBlack ? rank.blackSprite : rank.redSprite;\nfinal suitSprite = suit.sprite;\n_drawSprite(canvas, rankSprite, 0.1, 0.08);\n_drawSprite(canvas, suitSprite, 0.1, 0.18, scale: 0.5);\n_drawSprite(canvas, rankSprite, 0.1, 0.08, rotate: true);\n_drawSprite(canvas, suitSprite, 0.1, 0.18, scale: 0.5, rotate: true);\nswitch (rank.value) {\ncase 1:\n_drawSprite(canvas, suitSprite, 0.5, 0.5, scale: 2.5);\ncase 2:\n_drawSprite(canvas, suitSprite, 0.5, 0.25);\n_drawSprite(canvas, suitSprite, 0.5, 0.25, rotate: true);\ncase 3:\n_drawSprite(canvas, suitSprite, 0.5, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.5);\n_drawSprite(canvas, suitSprite, 0.5, 0.2, rotate: true);\ncase 4:\n_drawSprite(canvas, suitSprite, 0.3, 0.25);\n_drawSprite(canvas, suitSprite, 0.7, 0.25);\n_drawSprite(canvas, suitSprite, 0.3, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.25, rotate: true);\ncase 5:\n_drawSprite(canvas, suitSprite, 0.3, 0.25);\n_drawSprite(canvas, suitSprite, 0.7, 0.25);\n_drawSprite(canvas, suitSprite, 0.3, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.5, 0.5);\ncase 6:\n_drawSprite(canvas, suitSprite, 0.3, 0.25);\n_drawSprite(canvas, suitSprite, 0.7, 0.25);\n_drawSprite(canvas, suitSprite, 0.3, 0.5);\n_drawSprite(canvas, suitSprite, 0.7, 0.5);\n_drawSprite(canvas, suitSprite, 0.3, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.25, rotate: true);\ncase 7:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.35);\n_drawSprite(canvas, suitSprite, 0.3, 0.5);\n_drawSprite(canvas, suitSprite, 0.7, 0.5);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\ncase 8:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.35);\n_drawSprite(canvas, suitSprite, 0.3, 0.5);\n_drawSprite(canvas, suitSprite, 0.7, 0.5);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.5, 0.35, rotate: true);\ncase 9:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.3);\n_drawSprite(canvas, suitSprite, 0.3, 0.4);\n_drawSprite(canvas, suitSprite, 0.7, 0.4);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.3, 0.4, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.4, rotate: true);\ncase 10:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.3);\n_drawSprite(canvas, suitSprite, 0.3, 0.4);\n_drawSprite(canvas, suitSprite, 0.7, 0.4);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.5, 0.3, rotate: true);\n_drawSprite(canvas, suitSprite, 0.3, 0.4, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.4, rotate: true);\ncase 11:\n_drawSprite(canvas, suit.isRed ? redJack : blackJack, 0.5, 0.5);\ncase 12:\n_drawSprite(canvas, suit.isRed ? redQueen : blackQueen, 0.5, 0.5);\ncase 13:\n_drawSprite(canvas, suit.isRed ? redKing : blackKing, 0.5, 0.5);\n}\n}\n\nvoid _drawSprite(\nCanvas canvas,\nSprite sprite,\ndouble relativeX,\ndouble relativeY, {\ndouble scale = 1,\nbool rotate = false,\n}) {\nif (rotate) {\ncanvas.save();\ncanvas.translate(size.x / 2, size.y / 2);\ncanvas.rotate(pi);\ncanvas.translate(-size.x / 2, -size.y / 2);\n}\nsprite.render(\ncanvas,\nposition: Vector2(relativeX * size.x, relativeY * size.y),\nanchor: Anchor.center,\nsize: sprite.srcSize.scaled(scale),\n);\nif (rotate) {\ncanvas.restore();\n}\n}\n\n//#endregion\n\n//#region Dragging\n\n@override\nvoid onDragStart(DragStartEvent event) {\nsuper.onDragStart(event);\nif (pile?.canMoveCard(this) ?? false) {\n_isDragging = true;\npriority = 100;\nif (pile is TableauPile) {\nattachedCards.clear();\nfinal extraCards = (pile! as TableauPile).cardsOnTop(this);\nfor (final card in extraCards) {\ncard.priority = attachedCards.length + 101;\nattachedCards.add(card);\n}\n}\n}\n}\n\n@override\nvoid onDragUpdate(DragUpdateEvent event) {\nif (!_isDragging) {\nreturn;\n}\nfinal delta = event.localDelta;\nposition.add(delta);\nattachedCards.forEach((card) => card.position.add(delta));\n}\n\n@override\nvoid onDragEnd(DragEndEvent event) {\nsuper.onDragEnd(event);\nif (!_isDragging) {\nreturn;\n}\n_isDragging = false;\nfinal dropPiles = parent!\n.componentsAtPoint(position + size / 2)\n.whereType<Pile>()\n.toList();\nif (dropPiles.isNotEmpty) {\nif (dropPiles.first.canAcceptCard(this)) {\npile!.removeCard(this);\ndropPiles.first.acquireCard(this);\nif (attachedCards.isNotEmpty) {\nattachedCards.forEach((card) => dropPiles.first.acquireCard(card));\nattachedCards.clear();\n}\nreturn;\n}\n}\npile!.returnCard(this);\nif (attachedCards.isNotEmpty) {\nattachedCards.forEach((card) => pile!.returnCard(card));\nattachedCards.clear();\n}\n}\n\n//#endregion\n}"}
{"prompt": "Create a Flutter Flame game component that 4. Moving a run of cards¶: Well, this is it! The game is now fully playable. Press the button below to see what the resulting code looks like, or to play it live. In the next section we will discuss how to make it more animated with the help of effects.", "completion": "import 'dart:ui';\n\nimport 'package:flame/components.dart';\n\nimport '../klondike_game.dart';\nimport '../pile.dart';\nimport '../suit.dart';\nimport 'card.dart';\n\nclass FoundationPile extends PositionComponent implements Pile {\nFoundationPile(int intSuit, {super.position})\n: suit = Suit.fromInt(intSuit),\nsuper(size: KlondikeGame.cardSize);\n\nfinal Suit suit;\nfinal List<Card> _cards = [];\n\n//#region Pile API\n\n@override\nbool canMoveCard(Card card) {\nreturn _cards.isNotEmpty && card == _cards.last;\n}\n\n@override\nbool canAcceptCard(Card card) {\nfinal topCardRank = _cards.isEmpty ? 0 : _cards.last.rank.value;\nreturn card.suit == suit &&\ncard.rank.value == topCardRank + 1 &&\ncard.attachedCards.isEmpty;\n}\n\n@override\nvoid removeCard(Card card) {\nassert(canMoveCard(card));\n_cards.removeLast();\n}\n\n@override\nvoid returnCard(Card card) {\ncard.position = position;\ncard.priority = _cards.indexOf(card);\n}\n\n@override\nvoid acquireCard(Card card) {\nassert(card.isFaceUp);\ncard.position = position;\ncard.priority = _cards.length;\ncard.pile = this;\n_cards.add(card);\n}\n\n//#endregion\n\n//#region Rendering\n\nfinal _borderPaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 10\n..color = const Color(0x50ffffff);\nlate final _suitPaint = Paint()\n..color = suit.isRed ? const Color(0x3a000000) : const Color(0x64000000)\n..blendMode = BlendMode.luminosity;\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRRect(KlondikeGame.cardRRect, _borderPaint);\nsuit.sprite.render(\ncanvas,\nposition: size / 2,\nanchor: Anchor.center,\nsize: Vector2.all(KlondikeGame.cardWidth * 0.6),\noverridePaint: _suitPaint,\n);\n}\n\n//#endregion\n}"}
{"prompt": "Show me how to implement 4. Moving a run of cards¶: Well, this is it! The game is now fully playable. Press the button below to see what the resulting code looks like, or to play it live. In the next section we will discuss how to make it more animated with the help of effects. using Flutter Flame", "completion": "import 'dart:ui';\n\nimport 'package:flame/components.dart';\n\nimport '../klondike_game.dart';\nimport '../pile.dart';\nimport '../suit.dart';\nimport 'card.dart';\n\nclass FoundationPile extends PositionComponent implements Pile {\nFoundationPile(int intSuit, {super.position})\n: suit = Suit.fromInt(intSuit),\nsuper(size: KlondikeGame.cardSize);\n\nfinal Suit suit;\nfinal List<Card> _cards = [];\n\n//#region Pile API\n\n@override\nbool canMoveCard(Card card) {\nreturn _cards.isNotEmpty && card == _cards.last;\n}\n\n@override\nbool canAcceptCard(Card card) {\nfinal topCardRank = _cards.isEmpty ? 0 : _cards.last.rank.value;\nreturn card.suit == suit &&\ncard.rank.value == topCardRank + 1 &&\ncard.attachedCards.isEmpty;\n}\n\n@override\nvoid removeCard(Card card) {\nassert(canMoveCard(card));\n_cards.removeLast();\n}\n\n@override\nvoid returnCard(Card card) {\ncard.position = position;\ncard.priority = _cards.indexOf(card);\n}\n\n@override\nvoid acquireCard(Card card) {\nassert(card.isFaceUp);\ncard.position = position;\ncard.priority = _cards.length;\ncard.pile = this;\n_cards.add(card);\n}\n\n//#endregion\n\n//#region Rendering\n\nfinal _borderPaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 10\n..color = const Color(0x50ffffff);\nlate final _suitPaint = Paint()\n..color = suit.isRed ? const Color(0x3a000000) : const Color(0x64000000)\n..blendMode = BlendMode.luminosity;\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRRect(KlondikeGame.cardRRect, _borderPaint);\nsuit.sprite.render(\ncanvas,\nposition: size / 2,\nanchor: Anchor.center,\nsize: Vector2.all(KlondikeGame.cardWidth * 0.6),\noverridePaint: _suitPaint,\n);\n}\n\n//#endregion\n}"}
{"prompt": "Write Flutter Flame code to 4. Moving a run of cards¶: Well, this is it! The game is now fully playable. Press the button below to see what the resulting code looks like, or to play it live. In the next section we will discuss how to make it more animated with the help of effects.", "completion": "import 'dart:ui';\n\nimport 'package:flame/components.dart';\n\nimport '../klondike_game.dart';\nimport '../pile.dart';\nimport '../suit.dart';\nimport 'card.dart';\n\nclass FoundationPile extends PositionComponent implements Pile {\nFoundationPile(int intSuit, {super.position})\n: suit = Suit.fromInt(intSuit),\nsuper(size: KlondikeGame.cardSize);\n\nfinal Suit suit;\nfinal List<Card> _cards = [];\n\n//#region Pile API\n\n@override\nbool canMoveCard(Card card) {\nreturn _cards.isNotEmpty && card == _cards.last;\n}\n\n@override\nbool canAcceptCard(Card card) {\nfinal topCardRank = _cards.isEmpty ? 0 : _cards.last.rank.value;\nreturn card.suit == suit &&\ncard.rank.value == topCardRank + 1 &&\ncard.attachedCards.isEmpty;\n}\n\n@override\nvoid removeCard(Card card) {\nassert(canMoveCard(card));\n_cards.removeLast();\n}\n\n@override\nvoid returnCard(Card card) {\ncard.position = position;\ncard.priority = _cards.indexOf(card);\n}\n\n@override\nvoid acquireCard(Card card) {\nassert(card.isFaceUp);\ncard.position = position;\ncard.priority = _cards.length;\ncard.pile = this;\n_cards.add(card);\n}\n\n//#endregion\n\n//#region Rendering\n\nfinal _borderPaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 10\n..color = const Color(0x50ffffff);\nlate final _suitPaint = Paint()\n..color = suit.isRed ? const Color(0x3a000000) : const Color(0x64000000)\n..blendMode = BlendMode.luminosity;\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRRect(KlondikeGame.cardRRect, _borderPaint);\nsuit.sprite.render(\ncanvas,\nposition: size / 2,\nanchor: Anchor.center,\nsize: Vector2.all(KlondikeGame.cardWidth * 0.6),\noverridePaint: _suitPaint,\n);\n}\n\n//#endregion\n}"}
{"prompt": "Create a Flutter Flame game component that 4. Moving a run of cards¶: Well, this is it! The game is now fully playable. Press the button below to see what the resulting code looks like, or to play it live. In the next section we will discuss how to make it more animated with the help of effects.", "completion": "import 'dart:ui';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\n\nimport '../klondike_game.dart';\nimport '../pile.dart';\nimport 'card.dart';\nimport 'waste_pile.dart';\n\nclass StockPile extends PositionComponent with TapCallbacks implements Pile {\nStockPile({super.position}) : super(size: KlondikeGame.cardSize);\n\n/// Which cards are currently placed onto this pile. The first card in the\n/// list is at the bottom, the last card is on top.\nfinal List<Card> _cards = [];\n\n//#region Pile API\n\n@override\nbool canMoveCard(Card card) => false;\n\n@override\nbool canAcceptCard(Card card) => false;\n\n@override\nvoid removeCard(Card card) => throw StateError('cannot remove cards');\n\n@override\nvoid returnCard(Card card) => throw StateError('cannot remove cards');\n\n@override\nvoid acquireCard(Card card) {\nassert(card.isFaceDown);\ncard.pile = this;\ncard.position = position;\ncard.priority = _cards.length;\n_cards.add(card);\n}\n\n//#endregion\n\n@override\nvoid onTapUp(TapUpEvent event) {\nfinal wastePile = parent!.firstChild<WastePile>()!;\nif (_cards.isEmpty) {\nwastePile.removeAllCards().reversed.forEach((card) {\ncard.flip();\nacquireCard(card);\n});\n} else {\nfor (var i = 0; i < 3; i++) {\nif (_cards.isNotEmpty) {\nfinal card = _cards.removeLast();\ncard.flip();\nwastePile.acquireCard(card);\n}\n}\n}\n}\n\n//#region Rendering\n\nfinal _borderPaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 10\n..color = const Color(0xFF3F5B5D);\nfinal _circlePaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 100\n..color = const Color(0x883F5B5D);\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRRect(KlondikeGame.cardRRect, _borderPaint);\ncanvas.drawCircle(\nOffset(width / 2, height / 2),\nKlondikeGame.cardWidth * 0.3,\n_circlePaint,\n);\n}\n\n//#endregion\n}"}
{"prompt": "Show me how to implement 4. Moving a run of cards¶: Well, this is it! The game is now fully playable. Press the button below to see what the resulting code looks like, or to play it live. In the next section we will discuss how to make it more animated with the help of effects. using Flutter Flame", "completion": "import 'dart:ui';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\n\nimport '../klondike_game.dart';\nimport '../pile.dart';\nimport 'card.dart';\nimport 'waste_pile.dart';\n\nclass StockPile extends PositionComponent with TapCallbacks implements Pile {\nStockPile({super.position}) : super(size: KlondikeGame.cardSize);\n\n/// Which cards are currently placed onto this pile. The first card in the\n/// list is at the bottom, the last card is on top.\nfinal List<Card> _cards = [];\n\n//#region Pile API\n\n@override\nbool canMoveCard(Card card) => false;\n\n@override\nbool canAcceptCard(Card card) => false;\n\n@override\nvoid removeCard(Card card) => throw StateError('cannot remove cards');\n\n@override\nvoid returnCard(Card card) => throw StateError('cannot remove cards');\n\n@override\nvoid acquireCard(Card card) {\nassert(card.isFaceDown);\ncard.pile = this;\ncard.position = position;\ncard.priority = _cards.length;\n_cards.add(card);\n}\n\n//#endregion\n\n@override\nvoid onTapUp(TapUpEvent event) {\nfinal wastePile = parent!.firstChild<WastePile>()!;\nif (_cards.isEmpty) {\nwastePile.removeAllCards().reversed.forEach((card) {\ncard.flip();\nacquireCard(card);\n});\n} else {\nfor (var i = 0; i < 3; i++) {\nif (_cards.isNotEmpty) {\nfinal card = _cards.removeLast();\ncard.flip();\nwastePile.acquireCard(card);\n}\n}\n}\n}\n\n//#region Rendering\n\nfinal _borderPaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 10\n..color = const Color(0xFF3F5B5D);\nfinal _circlePaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 100\n..color = const Color(0x883F5B5D);\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRRect(KlondikeGame.cardRRect, _borderPaint);\ncanvas.drawCircle(\nOffset(width / 2, height / 2),\nKlondikeGame.cardWidth * 0.3,\n_circlePaint,\n);\n}\n\n//#endregion\n}"}
{"prompt": "Write Flutter Flame code to 4. Moving a run of cards¶: Well, this is it! The game is now fully playable. Press the button below to see what the resulting code looks like, or to play it live. In the next section we will discuss how to make it more animated with the help of effects.", "completion": "import 'dart:ui';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\n\nimport '../klondike_game.dart';\nimport '../pile.dart';\nimport 'card.dart';\nimport 'waste_pile.dart';\n\nclass StockPile extends PositionComponent with TapCallbacks implements Pile {\nStockPile({super.position}) : super(size: KlondikeGame.cardSize);\n\n/// Which cards are currently placed onto this pile. The first card in the\n/// list is at the bottom, the last card is on top.\nfinal List<Card> _cards = [];\n\n//#region Pile API\n\n@override\nbool canMoveCard(Card card) => false;\n\n@override\nbool canAcceptCard(Card card) => false;\n\n@override\nvoid removeCard(Card card) => throw StateError('cannot remove cards');\n\n@override\nvoid returnCard(Card card) => throw StateError('cannot remove cards');\n\n@override\nvoid acquireCard(Card card) {\nassert(card.isFaceDown);\ncard.pile = this;\ncard.position = position;\ncard.priority = _cards.length;\n_cards.add(card);\n}\n\n//#endregion\n\n@override\nvoid onTapUp(TapUpEvent event) {\nfinal wastePile = parent!.firstChild<WastePile>()!;\nif (_cards.isEmpty) {\nwastePile.removeAllCards().reversed.forEach((card) {\ncard.flip();\nacquireCard(card);\n});\n} else {\nfor (var i = 0; i < 3; i++) {\nif (_cards.isNotEmpty) {\nfinal card = _cards.removeLast();\ncard.flip();\nwastePile.acquireCard(card);\n}\n}\n}\n}\n\n//#region Rendering\n\nfinal _borderPaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 10\n..color = const Color(0xFF3F5B5D);\nfinal _circlePaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 100\n..color = const Color(0x883F5B5D);\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRRect(KlondikeGame.cardRRect, _borderPaint);\ncanvas.drawCircle(\nOffset(width / 2, height / 2),\nKlondikeGame.cardWidth * 0.3,\n_circlePaint,\n);\n}\n\n//#endregion\n}"}
{"prompt": "Create a Flutter Flame game component that 4. Moving a run of cards¶: Well, this is it! The game is now fully playable. Press the button below to see what the resulting code looks like, or to play it live. In the next section we will discuss how to make it more animated with the help of effects.", "completion": "import 'dart:ui';\n\nimport 'package:flame/components.dart';\n\nimport '../klondike_game.dart';\nimport '../pile.dart';\nimport 'card.dart';\n\nclass TableauPile extends PositionComponent implements Pile {\nTableauPile({super.position}) : super(size: KlondikeGame.cardSize);\n\n/// Which cards are currently placed onto this pile.\nfinal List<Card> _cards = [];\nfinal Vector2 _fanOffset1 = Vector2(0, KlondikeGame.cardHeight * 0.05);\nfinal Vector2 _fanOffset2 = Vector2(0, KlondikeGame.cardHeight * 0.2);\n\n//#region Pile API\n\n@override\nbool canMoveCard(Card card) => card.isFaceUp;\n\n@override\nbool canAcceptCard(Card card) {\nif (_cards.isEmpty) {\nreturn card.rank.value == 13;\n} else {\nfinal topCard = _cards.last;\nreturn card.suit.isRed == !topCard.suit.isRed &&\ncard.rank.value == topCard.rank.value - 1;\n}\n}\n\n@override\nvoid removeCard(Card card) {\nassert(_cards.contains(card) && card.isFaceUp);\nfinal index = _cards.indexOf(card);\n_cards.removeRange(index, _cards.length);\nif (_cards.isNotEmpty && _cards.last.isFaceDown) {\nflipTopCard();\n}\nlayOutCards();\n}\n\n@override\nvoid returnCard(Card card) {\ncard.priority = _cards.indexOf(card);\nlayOutCards();\n}\n\n@override\nvoid acquireCard(Card card) {\ncard.pile = this;\ncard.priority = _cards.length;\n_cards.add(card);\nlayOutCards();\n}\n\n//#endregion\n\nvoid flipTopCard() {\nassert(_cards.last.isFaceDown);\n_cards.last.flip();\n}\n\nvoid layOutCards() {\nif (_cards.isEmpty) {\nreturn;\n}\n_cards[0].position.setFrom(position);\nfor (var i = 1; i < _cards.length; i++) {\n_cards[i].position\n..setFrom(_cards[i - 1].position)\n..add(_cards[i - 1].isFaceDown ? _fanOffset1 : _fanOffset2);\n}\nheight = KlondikeGame.cardHeight * 1.5 + _cards.last.y - _cards.first.y;\n}\n\nList<Card> cardsOnTop(Card card) {\nassert(card.isFaceUp && _cards.contains(card));\nfinal index = _cards.indexOf(card);\nreturn _cards.getRange(index + 1, _cards.length).toList();\n}\n\n//#region Rendering\n\nfinal _borderPaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 10\n..color = const Color(0x50ffffff);\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRRect(KlondikeGame.cardRRect, _borderPaint);\n}\n\n//#endregion\n}"}
{"prompt": "Show me how to implement 4. Moving a run of cards¶: Well, this is it! The game is now fully playable. Press the button below to see what the resulting code looks like, or to play it live. In the next section we will discuss how to make it more animated with the help of effects. using Flutter Flame", "completion": "import 'dart:ui';\n\nimport 'package:flame/components.dart';\n\nimport '../klondike_game.dart';\nimport '../pile.dart';\nimport 'card.dart';\n\nclass TableauPile extends PositionComponent implements Pile {\nTableauPile({super.position}) : super(size: KlondikeGame.cardSize);\n\n/// Which cards are currently placed onto this pile.\nfinal List<Card> _cards = [];\nfinal Vector2 _fanOffset1 = Vector2(0, KlondikeGame.cardHeight * 0.05);\nfinal Vector2 _fanOffset2 = Vector2(0, KlondikeGame.cardHeight * 0.2);\n\n//#region Pile API\n\n@override\nbool canMoveCard(Card card) => card.isFaceUp;\n\n@override\nbool canAcceptCard(Card card) {\nif (_cards.isEmpty) {\nreturn card.rank.value == 13;\n} else {\nfinal topCard = _cards.last;\nreturn card.suit.isRed == !topCard.suit.isRed &&\ncard.rank.value == topCard.rank.value - 1;\n}\n}\n\n@override\nvoid removeCard(Card card) {\nassert(_cards.contains(card) && card.isFaceUp);\nfinal index = _cards.indexOf(card);\n_cards.removeRange(index, _cards.length);\nif (_cards.isNotEmpty && _cards.last.isFaceDown) {\nflipTopCard();\n}\nlayOutCards();\n}\n\n@override\nvoid returnCard(Card card) {\ncard.priority = _cards.indexOf(card);\nlayOutCards();\n}\n\n@override\nvoid acquireCard(Card card) {\ncard.pile = this;\ncard.priority = _cards.length;\n_cards.add(card);\nlayOutCards();\n}\n\n//#endregion\n\nvoid flipTopCard() {\nassert(_cards.last.isFaceDown);\n_cards.last.flip();\n}\n\nvoid layOutCards() {\nif (_cards.isEmpty) {\nreturn;\n}\n_cards[0].position.setFrom(position);\nfor (var i = 1; i < _cards.length; i++) {\n_cards[i].position\n..setFrom(_cards[i - 1].position)\n..add(_cards[i - 1].isFaceDown ? _fanOffset1 : _fanOffset2);\n}\nheight = KlondikeGame.cardHeight * 1.5 + _cards.last.y - _cards.first.y;\n}\n\nList<Card> cardsOnTop(Card card) {\nassert(card.isFaceUp && _cards.contains(card));\nfinal index = _cards.indexOf(card);\nreturn _cards.getRange(index + 1, _cards.length).toList();\n}\n\n//#region Rendering\n\nfinal _borderPaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 10\n..color = const Color(0x50ffffff);\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRRect(KlondikeGame.cardRRect, _borderPaint);\n}\n\n//#endregion\n}"}
{"prompt": "Write Flutter Flame code to 4. Moving a run of cards¶: Well, this is it! The game is now fully playable. Press the button below to see what the resulting code looks like, or to play it live. In the next section we will discuss how to make it more animated with the help of effects.", "completion": "import 'dart:ui';\n\nimport 'package:flame/components.dart';\n\nimport '../klondike_game.dart';\nimport '../pile.dart';\nimport 'card.dart';\n\nclass TableauPile extends PositionComponent implements Pile {\nTableauPile({super.position}) : super(size: KlondikeGame.cardSize);\n\n/// Which cards are currently placed onto this pile.\nfinal List<Card> _cards = [];\nfinal Vector2 _fanOffset1 = Vector2(0, KlondikeGame.cardHeight * 0.05);\nfinal Vector2 _fanOffset2 = Vector2(0, KlondikeGame.cardHeight * 0.2);\n\n//#region Pile API\n\n@override\nbool canMoveCard(Card card) => card.isFaceUp;\n\n@override\nbool canAcceptCard(Card card) {\nif (_cards.isEmpty) {\nreturn card.rank.value == 13;\n} else {\nfinal topCard = _cards.last;\nreturn card.suit.isRed == !topCard.suit.isRed &&\ncard.rank.value == topCard.rank.value - 1;\n}\n}\n\n@override\nvoid removeCard(Card card) {\nassert(_cards.contains(card) && card.isFaceUp);\nfinal index = _cards.indexOf(card);\n_cards.removeRange(index, _cards.length);\nif (_cards.isNotEmpty && _cards.last.isFaceDown) {\nflipTopCard();\n}\nlayOutCards();\n}\n\n@override\nvoid returnCard(Card card) {\ncard.priority = _cards.indexOf(card);\nlayOutCards();\n}\n\n@override\nvoid acquireCard(Card card) {\ncard.pile = this;\ncard.priority = _cards.length;\n_cards.add(card);\nlayOutCards();\n}\n\n//#endregion\n\nvoid flipTopCard() {\nassert(_cards.last.isFaceDown);\n_cards.last.flip();\n}\n\nvoid layOutCards() {\nif (_cards.isEmpty) {\nreturn;\n}\n_cards[0].position.setFrom(position);\nfor (var i = 1; i < _cards.length; i++) {\n_cards[i].position\n..setFrom(_cards[i - 1].position)\n..add(_cards[i - 1].isFaceDown ? _fanOffset1 : _fanOffset2);\n}\nheight = KlondikeGame.cardHeight * 1.5 + _cards.last.y - _cards.first.y;\n}\n\nList<Card> cardsOnTop(Card card) {\nassert(card.isFaceUp && _cards.contains(card));\nfinal index = _cards.indexOf(card);\nreturn _cards.getRange(index + 1, _cards.length).toList();\n}\n\n//#region Rendering\n\nfinal _borderPaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 10\n..color = const Color(0x50ffffff);\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRRect(KlondikeGame.cardRRect, _borderPaint);\n}\n\n//#endregion\n}"}
{"prompt": "Create a Flutter Flame game component that 4. Moving a run of cards¶: Well, this is it! The game is now fully playable. Press the button below to see what the resulting code looks like, or to play it live. In the next section we will discuss how to make it more animated with the help of effects.", "completion": "import 'package:flame/components.dart';\n\nimport '../klondike_game.dart';\nimport '../pile.dart';\nimport 'card.dart';\n\nclass WastePile extends PositionComponent implements Pile {\nWastePile({super.position}) : super(size: KlondikeGame.cardSize);\n\nfinal List<Card> _cards = [];\nfinal Vector2 _fanOffset = Vector2(KlondikeGame.cardWidth * 0.2, 0);\n\n//#region Pile API\n\n@override\nbool canMoveCard(Card card) => _cards.isNotEmpty && card == _cards.last;\n\n@override\nbool canAcceptCard(Card card) => false;\n\n@override\nvoid removeCard(Card card) {\nassert(canMoveCard(card));\n_cards.removeLast();\n_fanOutTopCards();\n}\n\n@override\nvoid returnCard(Card card) {\ncard.priority = _cards.indexOf(card);\n_fanOutTopCards();\n}\n\n@override\nvoid acquireCard(Card card) {\nassert(card.isFaceUp);\ncard.pile = this;\ncard.position = position;\ncard.priority = _cards.length;\n_cards.add(card);\n_fanOutTopCards();\n}\n\n//#endregion\n\nList<Card> removeAllCards() {\nfinal cards = _cards.toList();\n_cards.clear();\nreturn cards;\n}\n\nvoid _fanOutTopCards() {\nfinal n = _cards.length;\nfor (var i = 0; i < n; i++) {\n_cards[i].position = position;\n}\nif (n == 2) {\n_cards[1].position.add(_fanOffset);\n} else if (n >= 3) {\n_cards[n - 2].position.add(_fanOffset);\n_cards[n - 1].position.addScaled(_fanOffset, 2);\n}\n}\n}"}
{"prompt": "Show me how to implement 4. Moving a run of cards¶: Well, this is it! The game is now fully playable. Press the button below to see what the resulting code looks like, or to play it live. In the next section we will discuss how to make it more animated with the help of effects. using Flutter Flame", "completion": "import 'package:flame/components.dart';\n\nimport '../klondike_game.dart';\nimport '../pile.dart';\nimport 'card.dart';\n\nclass WastePile extends PositionComponent implements Pile {\nWastePile({super.position}) : super(size: KlondikeGame.cardSize);\n\nfinal List<Card> _cards = [];\nfinal Vector2 _fanOffset = Vector2(KlondikeGame.cardWidth * 0.2, 0);\n\n//#region Pile API\n\n@override\nbool canMoveCard(Card card) => _cards.isNotEmpty && card == _cards.last;\n\n@override\nbool canAcceptCard(Card card) => false;\n\n@override\nvoid removeCard(Card card) {\nassert(canMoveCard(card));\n_cards.removeLast();\n_fanOutTopCards();\n}\n\n@override\nvoid returnCard(Card card) {\ncard.priority = _cards.indexOf(card);\n_fanOutTopCards();\n}\n\n@override\nvoid acquireCard(Card card) {\nassert(card.isFaceUp);\ncard.pile = this;\ncard.position = position;\ncard.priority = _cards.length;\n_cards.add(card);\n_fanOutTopCards();\n}\n\n//#endregion\n\nList<Card> removeAllCards() {\nfinal cards = _cards.toList();\n_cards.clear();\nreturn cards;\n}\n\nvoid _fanOutTopCards() {\nfinal n = _cards.length;\nfor (var i = 0; i < n; i++) {\n_cards[i].position = position;\n}\nif (n == 2) {\n_cards[1].position.add(_fanOffset);\n} else if (n >= 3) {\n_cards[n - 2].position.add(_fanOffset);\n_cards[n - 1].position.addScaled(_fanOffset, 2);\n}\n}\n}"}
{"prompt": "Write Flutter Flame code to 4. Moving a run of cards¶: Well, this is it! The game is now fully playable. Press the button below to see what the resulting code looks like, or to play it live. In the next section we will discuss how to make it more animated with the help of effects.", "completion": "import 'package:flame/components.dart';\n\nimport '../klondike_game.dart';\nimport '../pile.dart';\nimport 'card.dart';\n\nclass WastePile extends PositionComponent implements Pile {\nWastePile({super.position}) : super(size: KlondikeGame.cardSize);\n\nfinal List<Card> _cards = [];\nfinal Vector2 _fanOffset = Vector2(KlondikeGame.cardWidth * 0.2, 0);\n\n//#region Pile API\n\n@override\nbool canMoveCard(Card card) => _cards.isNotEmpty && card == _cards.last;\n\n@override\nbool canAcceptCard(Card card) => false;\n\n@override\nvoid removeCard(Card card) {\nassert(canMoveCard(card));\n_cards.removeLast();\n_fanOutTopCards();\n}\n\n@override\nvoid returnCard(Card card) {\ncard.priority = _cards.indexOf(card);\n_fanOutTopCards();\n}\n\n@override\nvoid acquireCard(Card card) {\nassert(card.isFaceUp);\ncard.pile = this;\ncard.position = position;\ncard.priority = _cards.length;\n_cards.add(card);\n_fanOutTopCards();\n}\n\n//#endregion\n\nList<Card> removeAllCards() {\nfinal cards = _cards.toList();\n_cards.clear();\nreturn cards;\n}\n\nvoid _fanOutTopCards() {\nfinal n = _cards.length;\nfor (var i = 0; i < n; i++) {\n_cards[i].position = position;\n}\nif (n == 2) {\n_cards[1].position.add(_fanOffset);\n} else if (n >= 3) {\n_cards[n - 2].position.add(_fanOffset);\n_cards[n - 1].position.addScaled(_fanOffset, 2);\n}\n}\n}"}
{"prompt": "Create a Flutter Flame game component that 4. Moving a run of cards¶: Well, this is it! The game is now fully playable. Press the button below to see what the resulting code looks like, or to play it live. In the next section we will discuss how to make it more animated with the help of effects.", "completion": "import 'dart:ui';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/flame.dart';\nimport 'package:flame/game.dart';\n\nimport 'components/card.dart';\nimport 'components/foundation_pile.dart';\nimport 'components/stock_pile.dart';\nimport 'components/tableau_pile.dart';\nimport 'components/waste_pile.dart';\n\nclass KlondikeGame extends FlameGame {\nstatic const double cardGap = 175.0;\nstatic const double cardWidth = 1000.0;\nstatic const double cardHeight = 1400.0;\nstatic const double cardRadius = 100.0;\nstatic final Vector2 cardSize = Vector2(cardWidth, cardHeight);\nstatic final cardRRect = RRect.fromRectAndRadius(\nconst Rect.fromLTWH(0, 0, cardWidth, cardHeight),\nconst Radius.circular(cardRadius),\n);\n\n@override\nFuture<void> onLoad() async {\nawait Flame.images.load('klondike-sprites.png');\n\nfinal stock = StockPile(position: Vector2(cardGap, cardGap));\nfinal waste =\nWastePile(position: Vector2(cardWidth + 2 * cardGap, cardGap));\nfinal foundations = List.generate(\n4,\n(i) => FoundationPile(\ni,\nposition: Vector2((i + 3) * (cardWidth + cardGap) + cardGap, cardGap),\n),\n);\nfinal piles = List.generate(\n7,\n(i) => TableauPile(\nposition: Vector2(\ncardGap + i * (cardWidth + cardGap),\ncardHeight + 2 * cardGap,\n),\n),\n);\n\nworld.add(stock);\nworld.add(waste);\nworld.addAll(foundations);\nworld.addAll(piles);\n\ncamera.viewfinder.visibleGameSize =\nVector2(cardWidth * 7 + cardGap * 8, 4 * cardHeight + 3 * cardGap);\ncamera.viewfinder.position = Vector2(cardWidth * 3.5 + cardGap * 4, 0);\ncamera.viewfinder.anchor = Anchor.topCenter;\n\nfinal cards = [\nfor (var rank = 1; rank <= 13; rank++)\nfor (var suit = 0; suit < 4; suit++) Card(rank, suit),\n];\ncards.shuffle();\nworld.addAll(cards);\n\nvar cardToDeal = cards.length - 1;\nfor (var i = 0; i < 7; i++) {\nfor (var j = i; j < 7; j++) {\npiles[j].acquireCard(cards[cardToDeal--]);\n}\npiles[i].flipTopCard();\n}\nfor (var n = 0; n <= cardToDeal; n++) {\nstock.acquireCard(cards[n]);\n}\n}\n}\n\nSprite klondikeSprite(double x, double y, double width, double height) {\nreturn Sprite(\nFlame.images.fromCache('klondike-sprites.png'),\nsrcPosition: Vector2(x, y),\nsrcSize: Vector2(width, height),\n);\n}"}
{"prompt": "Show me how to implement 4. Moving a run of cards¶: Well, this is it! The game is now fully playable. Press the button below to see what the resulting code looks like, or to play it live. In the next section we will discuss how to make it more animated with the help of effects. using Flutter Flame", "completion": "import 'dart:ui';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/flame.dart';\nimport 'package:flame/game.dart';\n\nimport 'components/card.dart';\nimport 'components/foundation_pile.dart';\nimport 'components/stock_pile.dart';\nimport 'components/tableau_pile.dart';\nimport 'components/waste_pile.dart';\n\nclass KlondikeGame extends FlameGame {\nstatic const double cardGap = 175.0;\nstatic const double cardWidth = 1000.0;\nstatic const double cardHeight = 1400.0;\nstatic const double cardRadius = 100.0;\nstatic final Vector2 cardSize = Vector2(cardWidth, cardHeight);\nstatic final cardRRect = RRect.fromRectAndRadius(\nconst Rect.fromLTWH(0, 0, cardWidth, cardHeight),\nconst Radius.circular(cardRadius),\n);\n\n@override\nFuture<void> onLoad() async {\nawait Flame.images.load('klondike-sprites.png');\n\nfinal stock = StockPile(position: Vector2(cardGap, cardGap));\nfinal waste =\nWastePile(position: Vector2(cardWidth + 2 * cardGap, cardGap));\nfinal foundations = List.generate(\n4,\n(i) => FoundationPile(\ni,\nposition: Vector2((i + 3) * (cardWidth + cardGap) + cardGap, cardGap),\n),\n);\nfinal piles = List.generate(\n7,\n(i) => TableauPile(\nposition: Vector2(\ncardGap + i * (cardWidth + cardGap),\ncardHeight + 2 * cardGap,\n),\n),\n);\n\nworld.add(stock);\nworld.add(waste);\nworld.addAll(foundations);\nworld.addAll(piles);\n\ncamera.viewfinder.visibleGameSize =\nVector2(cardWidth * 7 + cardGap * 8, 4 * cardHeight + 3 * cardGap);\ncamera.viewfinder.position = Vector2(cardWidth * 3.5 + cardGap * 4, 0);\ncamera.viewfinder.anchor = Anchor.topCenter;\n\nfinal cards = [\nfor (var rank = 1; rank <= 13; rank++)\nfor (var suit = 0; suit < 4; suit++) Card(rank, suit),\n];\ncards.shuffle();\nworld.addAll(cards);\n\nvar cardToDeal = cards.length - 1;\nfor (var i = 0; i < 7; i++) {\nfor (var j = i; j < 7; j++) {\npiles[j].acquireCard(cards[cardToDeal--]);\n}\npiles[i].flipTopCard();\n}\nfor (var n = 0; n <= cardToDeal; n++) {\nstock.acquireCard(cards[n]);\n}\n}\n}\n\nSprite klondikeSprite(double x, double y, double width, double height) {\nreturn Sprite(\nFlame.images.fromCache('klondike-sprites.png'),\nsrcPosition: Vector2(x, y),\nsrcSize: Vector2(width, height),\n);\n}"}
{"prompt": "Write Flutter Flame code to 4. Moving a run of cards¶: Well, this is it! The game is now fully playable. Press the button below to see what the resulting code looks like, or to play it live. In the next section we will discuss how to make it more animated with the help of effects.", "completion": "import 'dart:ui';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/flame.dart';\nimport 'package:flame/game.dart';\n\nimport 'components/card.dart';\nimport 'components/foundation_pile.dart';\nimport 'components/stock_pile.dart';\nimport 'components/tableau_pile.dart';\nimport 'components/waste_pile.dart';\n\nclass KlondikeGame extends FlameGame {\nstatic const double cardGap = 175.0;\nstatic const double cardWidth = 1000.0;\nstatic const double cardHeight = 1400.0;\nstatic const double cardRadius = 100.0;\nstatic final Vector2 cardSize = Vector2(cardWidth, cardHeight);\nstatic final cardRRect = RRect.fromRectAndRadius(\nconst Rect.fromLTWH(0, 0, cardWidth, cardHeight),\nconst Radius.circular(cardRadius),\n);\n\n@override\nFuture<void> onLoad() async {\nawait Flame.images.load('klondike-sprites.png');\n\nfinal stock = StockPile(position: Vector2(cardGap, cardGap));\nfinal waste =\nWastePile(position: Vector2(cardWidth + 2 * cardGap, cardGap));\nfinal foundations = List.generate(\n4,\n(i) => FoundationPile(\ni,\nposition: Vector2((i + 3) * (cardWidth + cardGap) + cardGap, cardGap),\n),\n);\nfinal piles = List.generate(\n7,\n(i) => TableauPile(\nposition: Vector2(\ncardGap + i * (cardWidth + cardGap),\ncardHeight + 2 * cardGap,\n),\n),\n);\n\nworld.add(stock);\nworld.add(waste);\nworld.addAll(foundations);\nworld.addAll(piles);\n\ncamera.viewfinder.visibleGameSize =\nVector2(cardWidth * 7 + cardGap * 8, 4 * cardHeight + 3 * cardGap);\ncamera.viewfinder.position = Vector2(cardWidth * 3.5 + cardGap * 4, 0);\ncamera.viewfinder.anchor = Anchor.topCenter;\n\nfinal cards = [\nfor (var rank = 1; rank <= 13; rank++)\nfor (var suit = 0; suit < 4; suit++) Card(rank, suit),\n];\ncards.shuffle();\nworld.addAll(cards);\n\nvar cardToDeal = cards.length - 1;\nfor (var i = 0; i < 7; i++) {\nfor (var j = i; j < 7; j++) {\npiles[j].acquireCard(cards[cardToDeal--]);\n}\npiles[i].flipTopCard();\n}\nfor (var n = 0; n <= cardToDeal; n++) {\nstock.acquireCard(cards[n]);\n}\n}\n}\n\nSprite klondikeSprite(double x, double y, double width, double height) {\nreturn Sprite(\nFlame.images.fromCache('klondike-sprites.png'),\nsrcPosition: Vector2(x, y),\nsrcSize: Vector2(width, height),\n);\n}"}
{"prompt": "Create a Flutter Flame game component that 4. Moving a run of cards¶: Well, this is it! The game is now fully playable. Press the button below to see what the resulting code looks like, or to play it live. In the next section we will discuss how to make it more animated with the help of effects.", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'klondike_game.dart';\n\nvoid main() {\nfinal game = KlondikeGame();\nrunApp(GameWidget(game: game));\n}"}
{"prompt": "Show me how to implement 4. Moving a run of cards¶: Well, this is it! The game is now fully playable. Press the button below to see what the resulting code looks like, or to play it live. In the next section we will discuss how to make it more animated with the help of effects. using Flutter Flame", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'klondike_game.dart';\n\nvoid main() {\nfinal game = KlondikeGame();\nrunApp(GameWidget(game: game));\n}"}
{"prompt": "Write Flutter Flame code to 4. Moving a run of cards¶: Well, this is it! The game is now fully playable. Press the button below to see what the resulting code looks like, or to play it live. In the next section we will discuss how to make it more animated with the help of effects.", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'klondike_game.dart';\n\nvoid main() {\nfinal game = KlondikeGame();\nrunApp(GameWidget(game: game));\n}"}
{"prompt": "Create a Flutter Flame game component that 4. Moving a run of cards¶: Well, this is it! The game is now fully playable. Press the button below to see what the resulting code looks like, or to play it live. In the next section we will discuss how to make it more animated with the help of effects.", "completion": "import 'components/card.dart';\n\nabstract class Pile {\n/// Returns true if the [card] can be taken away from this pile and moved\n/// somewhere else.\nbool canMoveCard(Card card);\n\n/// Returns true if the [card] can be placed on top of this pile. The [card]\n/// may have other cards \"attached\" to it.\nbool canAcceptCard(Card card);\n\n/// Removes [card] from this pile; this method will only be called for a card\n/// that both belong to this pile, and for which [canMoveCard] returns true.\nvoid removeCard(Card card);\n\n/// Places a single [card] on top of this pile. This method will only be\n/// called for a card for which [canAcceptCard] returns true.\nvoid acquireCard(Card card);\n\n/// Returns the [card] (which already belongs to this pile) in its proper\n/// place.\nvoid returnCard(Card card);\n}"}
{"prompt": "Show me how to implement 4. Moving a run of cards¶: Well, this is it! The game is now fully playable. Press the button below to see what the resulting code looks like, or to play it live. In the next section we will discuss how to make it more animated with the help of effects. using Flutter Flame", "completion": "import 'components/card.dart';\n\nabstract class Pile {\n/// Returns true if the [card] can be taken away from this pile and moved\n/// somewhere else.\nbool canMoveCard(Card card);\n\n/// Returns true if the [card] can be placed on top of this pile. The [card]\n/// may have other cards \"attached\" to it.\nbool canAcceptCard(Card card);\n\n/// Removes [card] from this pile; this method will only be called for a card\n/// that both belong to this pile, and for which [canMoveCard] returns true.\nvoid removeCard(Card card);\n\n/// Places a single [card] on top of this pile. This method will only be\n/// called for a card for which [canAcceptCard] returns true.\nvoid acquireCard(Card card);\n\n/// Returns the [card] (which already belongs to this pile) in its proper\n/// place.\nvoid returnCard(Card card);\n}"}
{"prompt": "Write Flutter Flame code to 4. Moving a run of cards¶: Well, this is it! The game is now fully playable. Press the button below to see what the resulting code looks like, or to play it live. In the next section we will discuss how to make it more animated with the help of effects.", "completion": "import 'components/card.dart';\n\nabstract class Pile {\n/// Returns true if the [card] can be taken away from this pile and moved\n/// somewhere else.\nbool canMoveCard(Card card);\n\n/// Returns true if the [card] can be placed on top of this pile. The [card]\n/// may have other cards \"attached\" to it.\nbool canAcceptCard(Card card);\n\n/// Removes [card] from this pile; this method will only be called for a card\n/// that both belong to this pile, and for which [canMoveCard] returns true.\nvoid removeCard(Card card);\n\n/// Places a single [card] on top of this pile. This method will only be\n/// called for a card for which [canAcceptCard] returns true.\nvoid acquireCard(Card card);\n\n/// Returns the [card] (which already belongs to this pile) in its proper\n/// place.\nvoid returnCard(Card card);\n}"}
{"prompt": "Create a Flutter Flame game component that 4. Moving a run of cards¶: Well, this is it! The game is now fully playable. Press the button below to see what the resulting code looks like, or to play it live. In the next section we will discuss how to make it more animated with the help of effects.", "completion": "import 'package:flame/components.dart';\nimport 'package:flutter/foundation.dart';\nimport 'klondike_game.dart';\n\n@immutable\nclass Rank {\nfactory Rank.fromInt(int value) {\nassert(\nvalue >= 1 && value <= 13,\n'value is outside of the bounds of what a rank can be',\n);\nreturn _singletons[value - 1];\n}\n\nRank._(\nthis.value,\nthis.label,\ndouble x1,\ndouble y1,\ndouble x2,\ndouble y2,\ndouble w,\ndouble h,\n)   : redSprite = klondikeSprite(x1, y1, w, h),\nblackSprite = klondikeSprite(x2, y2, w, h);\n\nfinal int value;\nfinal String label;\nfinal Sprite redSprite;\nfinal Sprite blackSprite;\n\nstatic final List<Rank> _singletons = [\nRank._(1, 'A', 335, 164, 789, 161, 120, 129),\nRank._(2, '2', 20, 19, 15, 322, 83, 125),\nRank._(3, '3', 122, 19, 117, 322, 80, 127),\nRank._(4, '4', 213, 12, 208, 315, 93, 132),\nRank._(5, '5', 314, 21, 309, 324, 85, 125),\nRank._(6, '6', 419, 17, 414, 320, 84, 129),\nRank._(7, '7', 509, 21, 505, 324, 92, 128),\nRank._(8, '8', 612, 19, 607, 322, 78, 127),\nRank._(9, '9', 709, 19, 704, 322, 84, 130),\nRank._(10, '10', 810, 20, 805, 322, 137, 127),\nRank._(11, 'J', 15, 170, 469, 167, 56, 126),\nRank._(12, 'Q', 92, 168, 547, 165, 132, 128),\nRank._(13, 'K', 243, 170, 696, 167, 92, 123),\n];\n}"}
{"prompt": "Show me how to implement 4. Moving a run of cards¶: Well, this is it! The game is now fully playable. Press the button below to see what the resulting code looks like, or to play it live. In the next section we will discuss how to make it more animated with the help of effects. using Flutter Flame", "completion": "import 'package:flame/components.dart';\nimport 'package:flutter/foundation.dart';\nimport 'klondike_game.dart';\n\n@immutable\nclass Rank {\nfactory Rank.fromInt(int value) {\nassert(\nvalue >= 1 && value <= 13,\n'value is outside of the bounds of what a rank can be',\n);\nreturn _singletons[value - 1];\n}\n\nRank._(\nthis.value,\nthis.label,\ndouble x1,\ndouble y1,\ndouble x2,\ndouble y2,\ndouble w,\ndouble h,\n)   : redSprite = klondikeSprite(x1, y1, w, h),\nblackSprite = klondikeSprite(x2, y2, w, h);\n\nfinal int value;\nfinal String label;\nfinal Sprite redSprite;\nfinal Sprite blackSprite;\n\nstatic final List<Rank> _singletons = [\nRank._(1, 'A', 335, 164, 789, 161, 120, 129),\nRank._(2, '2', 20, 19, 15, 322, 83, 125),\nRank._(3, '3', 122, 19, 117, 322, 80, 127),\nRank._(4, '4', 213, 12, 208, 315, 93, 132),\nRank._(5, '5', 314, 21, 309, 324, 85, 125),\nRank._(6, '6', 419, 17, 414, 320, 84, 129),\nRank._(7, '7', 509, 21, 505, 324, 92, 128),\nRank._(8, '8', 612, 19, 607, 322, 78, 127),\nRank._(9, '9', 709, 19, 704, 322, 84, 130),\nRank._(10, '10', 810, 20, 805, 322, 137, 127),\nRank._(11, 'J', 15, 170, 469, 167, 56, 126),\nRank._(12, 'Q', 92, 168, 547, 165, 132, 128),\nRank._(13, 'K', 243, 170, 696, 167, 92, 123),\n];\n}"}
{"prompt": "Write Flutter Flame code to 4. Moving a run of cards¶: Well, this is it! The game is now fully playable. Press the button below to see what the resulting code looks like, or to play it live. In the next section we will discuss how to make it more animated with the help of effects.", "completion": "import 'package:flame/components.dart';\nimport 'package:flutter/foundation.dart';\nimport 'klondike_game.dart';\n\n@immutable\nclass Rank {\nfactory Rank.fromInt(int value) {\nassert(\nvalue >= 1 && value <= 13,\n'value is outside of the bounds of what a rank can be',\n);\nreturn _singletons[value - 1];\n}\n\nRank._(\nthis.value,\nthis.label,\ndouble x1,\ndouble y1,\ndouble x2,\ndouble y2,\ndouble w,\ndouble h,\n)   : redSprite = klondikeSprite(x1, y1, w, h),\nblackSprite = klondikeSprite(x2, y2, w, h);\n\nfinal int value;\nfinal String label;\nfinal Sprite redSprite;\nfinal Sprite blackSprite;\n\nstatic final List<Rank> _singletons = [\nRank._(1, 'A', 335, 164, 789, 161, 120, 129),\nRank._(2, '2', 20, 19, 15, 322, 83, 125),\nRank._(3, '3', 122, 19, 117, 322, 80, 127),\nRank._(4, '4', 213, 12, 208, 315, 93, 132),\nRank._(5, '5', 314, 21, 309, 324, 85, 125),\nRank._(6, '6', 419, 17, 414, 320, 84, 129),\nRank._(7, '7', 509, 21, 505, 324, 92, 128),\nRank._(8, '8', 612, 19, 607, 322, 78, 127),\nRank._(9, '9', 709, 19, 704, 322, 84, 130),\nRank._(10, '10', 810, 20, 805, 322, 137, 127),\nRank._(11, 'J', 15, 170, 469, 167, 56, 126),\nRank._(12, 'Q', 92, 168, 547, 165, 132, 128),\nRank._(13, 'K', 243, 170, 696, 167, 92, 123),\n];\n}"}
{"prompt": "Create a Flutter Flame game component that 4. Moving a run of cards¶: Well, this is it! The game is now fully playable. Press the button below to see what the resulting code looks like, or to play it live. In the next section we will discuss how to make it more animated with the help of effects.", "completion": "import 'package:flame/sprite.dart';\nimport 'package:flutter/foundation.dart';\nimport 'klondike_game.dart';\n\n@immutable\nclass Suit {\nfactory Suit.fromInt(int index) {\nassert(\nindex >= 0 && index <= 3,\n'index is outside of the bounds of what a suit can be',\n);\nreturn _singletons[index];\n}\n\nSuit._(this.value, this.label, double x, double y, double w, double h)\n: sprite = klondikeSprite(x, y, w, h);\n\nfinal int value;\nfinal String label;\nfinal Sprite sprite;\n\nstatic final List<Suit> _singletons = [\nSuit._(0, '♥', 1176, 17, 172, 183),\nSuit._(1, '♦', 973, 14, 177, 182),\nSuit._(2, '♣', 974, 226, 184, 172),\nSuit._(3, '♠', 1178, 220, 176, 182),\n];\n\n/// Hearts and Diamonds are red, while Clubs and Spades are black.\nbool get isRed => value <= 1;\nbool get isBlack => value >= 2;\n}"}
{"prompt": "Show me how to implement 4. Moving a run of cards¶: Well, this is it! The game is now fully playable. Press the button below to see what the resulting code looks like, or to play it live. In the next section we will discuss how to make it more animated with the help of effects. using Flutter Flame", "completion": "import 'package:flame/sprite.dart';\nimport 'package:flutter/foundation.dart';\nimport 'klondike_game.dart';\n\n@immutable\nclass Suit {\nfactory Suit.fromInt(int index) {\nassert(\nindex >= 0 && index <= 3,\n'index is outside of the bounds of what a suit can be',\n);\nreturn _singletons[index];\n}\n\nSuit._(this.value, this.label, double x, double y, double w, double h)\n: sprite = klondikeSprite(x, y, w, h);\n\nfinal int value;\nfinal String label;\nfinal Sprite sprite;\n\nstatic final List<Suit> _singletons = [\nSuit._(0, '♥', 1176, 17, 172, 183),\nSuit._(1, '♦', 973, 14, 177, 182),\nSuit._(2, '♣', 974, 226, 184, 172),\nSuit._(3, '♠', 1178, 220, 176, 182),\n];\n\n/// Hearts and Diamonds are red, while Clubs and Spades are black.\nbool get isRed => value <= 1;\nbool get isBlack => value >= 2;\n}"}
{"prompt": "Write Flutter Flame code to 4. Moving a run of cards¶: Well, this is it! The game is now fully playable. Press the button below to see what the resulting code looks like, or to play it live. In the next section we will discuss how to make it more animated with the help of effects.", "completion": "import 'package:flame/sprite.dart';\nimport 'package:flutter/foundation.dart';\nimport 'klondike_game.dart';\n\n@immutable\nclass Suit {\nfactory Suit.fromInt(int index) {\nassert(\nindex >= 0 && index <= 3,\n'index is outside of the bounds of what a suit can be',\n);\nreturn _singletons[index];\n}\n\nSuit._(this.value, this.label, double x, double y, double w, double h)\n: sprite = klondikeSprite(x, y, w, h);\n\nfinal int value;\nfinal String label;\nfinal Sprite sprite;\n\nstatic final List<Suit> _singletons = [\nSuit._(0, '♥', 1176, 17, 172, 183),\nSuit._(1, '♦', 973, 14, 177, 182),\nSuit._(2, '♣', 974, 226, 184, 172),\nSuit._(3, '♠', 1178, 220, 176, 182),\n];\n\n/// Hearts and Diamonds are red, while Clubs and Spades are black.\nbool get isRed => value <= 1;\nbool get isBlack => value >= 2;\n}"}
{"prompt": "Create a Flutter Flame game component that FlameGame tests¶: It is very common to want to have a FlameGame instance inside a test, so that you can add some components to it and verify various behaviors. The following approach is recommended:", "completion": "testWithFlameGame('the name of the test', (game) async {\n  game.add(...);\n  await game.ready();\n\n  expect(...);\n});"}
{"prompt": "Show me how to implement FlameGame tests¶: It is very common to want to have a FlameGame instance inside a test, so that you can add some components to it and verify various behaviors. The following approach is recommended: using Flutter Flame", "completion": "testWithFlameGame('the name of the test', (game) async {\n  game.add(...);\n  await game.ready();\n\n  expect(...);\n});"}
{"prompt": "Write Flutter Flame code to FlameGame tests¶: It is very common to want to have a FlameGame instance inside a test, so that you can add some components to it and verify various behaviors. The following approach is recommended:", "completion": "testWithFlameGame('the name of the test', (game) async {\n  game.add(...);\n  await game.ready();\n\n  expect(...);\n});"}
{"prompt": "Create a Flutter Flame game component that FlameGame tests¶: If you need to have a custom game inside this test (say, a game with some mixin), then use", "completion": "testWithGame<_MyGame>(\n  'the name of the test',\n  _MyGame.new,\n  (game) async {\n    // test body...\n  },\n);"}
{"prompt": "Show me how to implement FlameGame tests¶: If you need to have a custom game inside this test (say, a game with some mixin), then use using Flutter Flame", "completion": "testWithGame<_MyGame>(\n  'the name of the test',\n  _MyGame.new,\n  (game) async {\n    // test body...\n  },\n);"}
{"prompt": "Write Flutter Flame code to FlameGame tests¶: If you need to have a custom game inside this test (say, a game with some mixin), then use", "completion": "testWithGame<_MyGame>(\n  'the name of the test',\n  _MyGame.new,\n  (game) async {\n    // test body...\n  },\n);"}
{"prompt": "Create a Flutter Flame game component that Widget tests¶: Sometimes having a “naked” FlameGame is insufficient, and you want to have access to the Flutter infrastructure as well. That is, to have a game mounted into a real GameWidget embedded into an actual Flutter framework. In such cases, use", "completion": "testWidgets('test name', (tester) async {\n  final game = _MyGame();\n  await tester.pumpWidget(GameWidget(game: game));\n  await tester.pump();\n  await tester.pump();\n\n  // At this point the game is fully initialized, and you can run your checks\n  // against it.\n  expect(...);\n\n  // Equivalent to game.update(0)\n  await tester.pump();\n\n  // Advances in-game time by 20 milliseconds\n  await tester.pump(const Duration(milliseconds: 20));\n});"}
{"prompt": "Show me how to implement Widget tests¶: Sometimes having a “naked” FlameGame is insufficient, and you want to have access to the Flutter infrastructure as well. That is, to have a game mounted into a real GameWidget embedded into an actual Flutter framework. In such cases, use using Flutter Flame", "completion": "testWidgets('test name', (tester) async {\n  final game = _MyGame();\n  await tester.pumpWidget(GameWidget(game: game));\n  await tester.pump();\n  await tester.pump();\n\n  // At this point the game is fully initialized, and you can run your checks\n  // against it.\n  expect(...);\n\n  // Equivalent to game.update(0)\n  await tester.pump();\n\n  // Advances in-game time by 20 milliseconds\n  await tester.pump(const Duration(milliseconds: 20));\n});"}
{"prompt": "Write Flutter Flame code to Widget tests¶: Sometimes having a “naked” FlameGame is insufficient, and you want to have access to the Flutter infrastructure as well. That is, to have a game mounted into a real GameWidget embedded into an actual Flutter framework. In such cases, use", "completion": "testWidgets('test name', (tester) async {\n  final game = _MyGame();\n  await tester.pumpWidget(GameWidget(game: game));\n  await tester.pump();\n  await tester.pump();\n\n  // At this point the game is fully initialized, and you can run your checks\n  // against it.\n  expect(...);\n\n  // Equivalent to game.update(0)\n  await tester.pump();\n\n  // Advances in-game time by 20 milliseconds\n  await tester.pump(const Duration(milliseconds: 20));\n});"}
{"prompt": "Create a Flutter Flame game component that Golden tests¶: Write the test, using the following template:", "completion": "testGolden(\n  'the name of the test',\n  (game) async {\n     // Set up the game by adding the necessary components\n     // You can add `expect()` checks here too, if you want to\n  },\n  size: Vector2(300, 200),\n  goldenFile: '.../_goldens/my_test_file.png',\n);"}
{"prompt": "Show me how to implement Golden tests¶: Write the test, using the following template: using Flutter Flame", "completion": "testGolden(\n  'the name of the test',\n  (game) async {\n     // Set up the game by adding the necessary components\n     // You can add `expect()` checks here too, if you want to\n  },\n  size: Vector2(300, 200),\n  goldenFile: '.../_goldens/my_test_file.png',\n);"}
{"prompt": "Write Flutter Flame code to Golden tests¶: Write the test, using the following template:", "completion": "testGolden(\n  'the name of the test',\n  (game) async {\n     // Set up the game by adding the necessary components\n     // You can add `expect()` checks here too, if you want to\n  },\n  size: Vector2(300, 200),\n  goldenFile: '.../_goldens/my_test_file.png',\n);"}
{"prompt": "Create a Flutter Flame game component that Overlays¶: The feature can be used via the game.overlays.add and game.overlays.remove methods that mark an overlay to be shown or hidden, respectively, via a String argument that identifies the overlay. After that, you can map each overlay to their corresponding Widget in your GameWidget declaration by providing an overlayBuilderMap.", "completion": "// On the widget declaration\nfinal game = MyGame();\n\nWidget build(BuildContext context) {\n  return GameWidget(\n    game: game,\n    overlayBuilderMap: {\n      'PauseMenu': (BuildContext context, MyGame game) {\n        return Text('A pause menu');\n      },\n      'SecondaryMenu': (BuildContext context, MyGame game) {\n        return Text('A secondary menu');\n      },\n    },\n  );\n}"}
{"prompt": "Show me how to implement Overlays¶: The feature can be used via the game.overlays.add and game.overlays.remove methods that mark an overlay to be shown or hidden, respectively, via a String argument that identifies the overlay. After that, you can map each overlay to their corresponding Widget in your GameWidget declaration by providing an overlayBuilderMap. using Flutter Flame", "completion": "// On the widget declaration\nfinal game = MyGame();\n\nWidget build(BuildContext context) {\n  return GameWidget(\n    game: game,\n    overlayBuilderMap: {\n      'PauseMenu': (BuildContext context, MyGame game) {\n        return Text('A pause menu');\n      },\n      'SecondaryMenu': (BuildContext context, MyGame game) {\n        return Text('A secondary menu');\n      },\n    },\n  );\n}"}
{"prompt": "Write Flutter Flame code to Overlays¶: The feature can be used via the game.overlays.add and game.overlays.remove methods that mark an overlay to be shown or hidden, respectively, via a String argument that identifies the overlay. After that, you can map each overlay to their corresponding Widget in your GameWidget declaration by providing an overlayBuilderMap.", "completion": "// On the widget declaration\nfinal game = MyGame();\n\nWidget build(BuildContext context) {\n  return GameWidget(\n    game: game,\n    overlayBuilderMap: {\n      'PauseMenu': (BuildContext context, MyGame game) {\n        return Text('A pause menu');\n      },\n      'SecondaryMenu': (BuildContext context, MyGame game) {\n        return Text('A secondary menu');\n      },\n    },\n  );\n}"}
{"prompt": "Create a Flutter Flame game component that AlignComponent¶: Normally, this component’s size will match the size of its parent. However, if you provide properties widthFactor or heightFactor, then the size of this component in that direction will be equal to the size of the child times the corresponding factor. For example, if you set heightFactor to 1 then the width of this component will be equal to the width of the parent, but the height will match the height of the child.", "completion": "AlignComponent(\n  child: TextComponent('hello'),\n  alignment: Anchor.centerLeft,\n);"}
{"prompt": "Show me how to implement AlignComponent¶: Normally, this component’s size will match the size of its parent. However, if you provide properties widthFactor or heightFactor, then the size of this component in that direction will be equal to the size of the child times the corresponding factor. For example, if you set heightFactor to 1 then the width of this component will be equal to the width of the parent, but the height will match the height of the child. using Flutter Flame", "completion": "AlignComponent(\n  child: TextComponent('hello'),\n  alignment: Anchor.centerLeft,\n);"}
{"prompt": "Write Flutter Flame code to AlignComponent¶: Normally, this component’s size will match the size of its parent. However, if you provide properties widthFactor or heightFactor, then the size of this component in that direction will be equal to the size of the child times the corresponding factor. For example, if you set heightFactor to 1 then the width of this component will be equal to the width of the parent, but the height will match the height of the child.", "completion": "AlignComponent(\n  child: TextComponent('hello'),\n  alignment: Anchor.centerLeft,\n);"}
{"prompt": "Create a Flutter Flame game component that AlignComponent¶: By default, the child’s anchor is set equal to the alignment value. This achieves traditional alignment behavior: for example, the center of the child will be placed at the center of the current component, or bottom right corner of the child can be placed in the bottom right corner of the component. However, it is also possible to achieve more extravagant placement by giving the child a different anchor and setting keepChildAnchor to true. For example, if you set alignment to topCenter, and child’s anchor to bottomCenter, then the child will effectively be placed above the current component:", "completion": "PlayerSprite().add(\n  AlignComponent(\n    child: HealthBar()..anchor = Anchor.bottomCenter,\n    alignment: Anchor.topCenter,\n    keepChildAnchor: true,\n  ),\n);"}
{"prompt": "Show me how to implement AlignComponent¶: By default, the child’s anchor is set equal to the alignment value. This achieves traditional alignment behavior: for example, the center of the child will be placed at the center of the current component, or bottom right corner of the child can be placed in the bottom right corner of the component. However, it is also possible to achieve more extravagant placement by giving the child a different anchor and setting keepChildAnchor to true. For example, if you set alignment to topCenter, and child’s anchor to bottomCenter, then the child will effectively be placed above the current component: using Flutter Flame", "completion": "PlayerSprite().add(\n  AlignComponent(\n    child: HealthBar()..anchor = Anchor.bottomCenter,\n    alignment: Anchor.topCenter,\n    keepChildAnchor: true,\n  ),\n);"}
{"prompt": "Write Flutter Flame code to AlignComponent¶: By default, the child’s anchor is set equal to the alignment value. This achieves traditional alignment behavior: for example, the center of the child will be placed at the center of the current component, or bottom right corner of the child can be placed in the bottom right corner of the component. However, it is also possible to achieve more extravagant placement by giving the child a different anchor and setting keepChildAnchor to true. For example, if you set alignment to topCenter, and child’s anchor to bottomCenter, then the child will effectively be placed above the current component:", "completion": "PlayerSprite().add(\n  AlignComponent(\n    child: HealthBar()..anchor = Anchor.bottomCenter,\n    alignment: Anchor.topCenter,\n    keepChildAnchor: true,\n  ),\n);"}
{"prompt": "Create a Flutter Flame game component that Setting up the HUD¶: Start by creating a folder called lib/overlays, and in that folder, create a component called heart.dart. This is going to be the health monitoring component in the upper left-hand corner of the game. Add the following code:", "completion": "import 'package:ember_quest/ember_quest.dart';\nimport 'package:flame/components.dart';\n\nenum HeartState {\n  available,\n  unavailable,\n}\n\nclass HeartHealthComponent extends SpriteGroupComponent<HeartState>\n    with HasGameReference<EmberQuestGame> {\n  final int heartNumber;\n\n  HeartHealthComponent({\n    required this.heartNumber,\n    required super.position,\n    required super.size,\n    super.scale,\n    super.angle,\n    super.anchor,\n    super.priority,\n  });\n\n  @override\n  Future<void> onLoad() async {\n    await super.onLoad();\n    final availableSprite = await game.loadSprite(\n      'heart.png',\n      srcSize: Vector2.all(32),\n    );\n\n    final unavailableSprite = await game.loadSprite(\n      'heart_half.png',\n      srcSize: Vector2.all(32),\n    );\n\n    sprites = {\n      HeartState.available: availableSprite,\n      HeartState.unavailable: unavailableSprite,\n    };\n\n    current = HeartState.available;\n  }\n\n  @override\n  void update(double dt) {\n    if (game.health < heartNumber) {\n      current = HeartState.unavailable;\n    } else {\n      current = HeartState.available;\n    }\n    super.update(dt);\n  }\n}"}
{"prompt": "Show me how to implement Setting up the HUD¶: Start by creating a folder called lib/overlays, and in that folder, create a component called heart.dart. This is going to be the health monitoring component in the upper left-hand corner of the game. Add the following code: using Flutter Flame", "completion": "import 'package:ember_quest/ember_quest.dart';\nimport 'package:flame/components.dart';\n\nenum HeartState {\n  available,\n  unavailable,\n}\n\nclass HeartHealthComponent extends SpriteGroupComponent<HeartState>\n    with HasGameReference<EmberQuestGame> {\n  final int heartNumber;\n\n  HeartHealthComponent({\n    required this.heartNumber,\n    required super.position,\n    required super.size,\n    super.scale,\n    super.angle,\n    super.anchor,\n    super.priority,\n  });\n\n  @override\n  Future<void> onLoad() async {\n    await super.onLoad();\n    final availableSprite = await game.loadSprite(\n      'heart.png',\n      srcSize: Vector2.all(32),\n    );\n\n    final unavailableSprite = await game.loadSprite(\n      'heart_half.png',\n      srcSize: Vector2.all(32),\n    );\n\n    sprites = {\n      HeartState.available: availableSprite,\n      HeartState.unavailable: unavailableSprite,\n    };\n\n    current = HeartState.available;\n  }\n\n  @override\n  void update(double dt) {\n    if (game.health < heartNumber) {\n      current = HeartState.unavailable;\n    } else {\n      current = HeartState.available;\n    }\n    super.update(dt);\n  }\n}"}
{"prompt": "Write Flutter Flame code to Setting up the HUD¶: Start by creating a folder called lib/overlays, and in that folder, create a component called heart.dart. This is going to be the health monitoring component in the upper left-hand corner of the game. Add the following code:", "completion": "import 'package:ember_quest/ember_quest.dart';\nimport 'package:flame/components.dart';\n\nenum HeartState {\n  available,\n  unavailable,\n}\n\nclass HeartHealthComponent extends SpriteGroupComponent<HeartState>\n    with HasGameReference<EmberQuestGame> {\n  final int heartNumber;\n\n  HeartHealthComponent({\n    required this.heartNumber,\n    required super.position,\n    required super.size,\n    super.scale,\n    super.angle,\n    super.anchor,\n    super.priority,\n  });\n\n  @override\n  Future<void> onLoad() async {\n    await super.onLoad();\n    final availableSprite = await game.loadSprite(\n      'heart.png',\n      srcSize: Vector2.all(32),\n    );\n\n    final unavailableSprite = await game.loadSprite(\n      'heart_half.png',\n      srcSize: Vector2.all(32),\n    );\n\n    sprites = {\n      HeartState.available: availableSprite,\n      HeartState.unavailable: unavailableSprite,\n    };\n\n    current = HeartState.available;\n  }\n\n  @override\n  void update(double dt) {\n    if (game.health < heartNumber) {\n      current = HeartState.unavailable;\n    } else {\n      current = HeartState.available;\n    }\n    super.update(dt);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Setting up the HUD¶: To put this all together, create hud.dart in the same folder and add the following code:", "completion": "import 'package:flame/components.dart';\nimport 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\nimport 'heart.dart';\n\nclass Hud extends PositionComponent with HasGameReference<EmberQuestGame> {\n  Hud({\n    super.position,\n    super.size,\n    super.scale,\n    super.angle,\n    super.anchor,\n    super.children,\n    super.priority = 5,\n  });\n\n  late TextComponent _scoreTextComponent;\n\n  @override\n  Future<void> onLoad() async {\n    _scoreTextComponent = TextComponent(\n      text: '${game.starsCollected}',\n      textRenderer: TextPaint(\n        style: const TextStyle(\n          fontSize: 32,\n          color: Color.fromRGBO(10, 10, 10, 1),\n        ),\n      ),\n      anchor: Anchor.center,\n      position: Vector2(game.size.x - 60, 20),\n    );\n    add(_scoreTextComponent);\n\n    final starSprite = await game.loadSprite('star.png');\n    add(\n      SpriteComponent(\n        sprite: starSprite,\n        position: Vector2(game.size.x - 100, 20),\n        size: Vector2.all(32),\n        anchor: Anchor.center,\n      ),\n    );\n\n    for (var i = 1; i <= game.health; i++) {\n      final positionX = 40 * i;\n      await add(\n        HeartHealthComponent(\n          heartNumber: i,\n          position: Vector2(positionX.toDouble(), 20),\n          size: Vector2.all(32),\n        ),\n      );\n    }\n  }\n\n  @override\n  void update(double dt) {\n    _scoreTextComponent.text = '${game.starsCollected}';\n  }\n}"}
{"prompt": "Show me how to implement Setting up the HUD¶: To put this all together, create hud.dart in the same folder and add the following code: using Flutter Flame", "completion": "import 'package:flame/components.dart';\nimport 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\nimport 'heart.dart';\n\nclass Hud extends PositionComponent with HasGameReference<EmberQuestGame> {\n  Hud({\n    super.position,\n    super.size,\n    super.scale,\n    super.angle,\n    super.anchor,\n    super.children,\n    super.priority = 5,\n  });\n\n  late TextComponent _scoreTextComponent;\n\n  @override\n  Future<void> onLoad() async {\n    _scoreTextComponent = TextComponent(\n      text: '${game.starsCollected}',\n      textRenderer: TextPaint(\n        style: const TextStyle(\n          fontSize: 32,\n          color: Color.fromRGBO(10, 10, 10, 1),\n        ),\n      ),\n      anchor: Anchor.center,\n      position: Vector2(game.size.x - 60, 20),\n    );\n    add(_scoreTextComponent);\n\n    final starSprite = await game.loadSprite('star.png');\n    add(\n      SpriteComponent(\n        sprite: starSprite,\n        position: Vector2(game.size.x - 100, 20),\n        size: Vector2.all(32),\n        anchor: Anchor.center,\n      ),\n    );\n\n    for (var i = 1; i <= game.health; i++) {\n      final positionX = 40 * i;\n      await add(\n        HeartHealthComponent(\n          heartNumber: i,\n          position: Vector2(positionX.toDouble(), 20),\n          size: Vector2.all(32),\n        ),\n      );\n    }\n  }\n\n  @override\n  void update(double dt) {\n    _scoreTextComponent.text = '${game.starsCollected}';\n  }\n}"}
{"prompt": "Write Flutter Flame code to Setting up the HUD¶: To put this all together, create hud.dart in the same folder and add the following code:", "completion": "import 'package:flame/components.dart';\nimport 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\nimport 'heart.dart';\n\nclass Hud extends PositionComponent with HasGameReference<EmberQuestGame> {\n  Hud({\n    super.position,\n    super.size,\n    super.scale,\n    super.angle,\n    super.anchor,\n    super.children,\n    super.priority = 5,\n  });\n\n  late TextComponent _scoreTextComponent;\n\n  @override\n  Future<void> onLoad() async {\n    _scoreTextComponent = TextComponent(\n      text: '${game.starsCollected}',\n      textRenderer: TextPaint(\n        style: const TextStyle(\n          fontSize: 32,\n          color: Color.fromRGBO(10, 10, 10, 1),\n        ),\n      ),\n      anchor: Anchor.center,\n      position: Vector2(game.size.x - 60, 20),\n    );\n    add(_scoreTextComponent);\n\n    final starSprite = await game.loadSprite('star.png');\n    add(\n      SpriteComponent(\n        sprite: starSprite,\n        position: Vector2(game.size.x - 100, 20),\n        size: Vector2.all(32),\n        anchor: Anchor.center,\n      ),\n    );\n\n    for (var i = 1; i <= game.health; i++) {\n      final positionX = 40 * i;\n      await add(\n        HeartHealthComponent(\n          heartNumber: i,\n          position: Vector2(positionX.toDouble(), 20),\n          size: Vector2.all(32),\n        ),\n      );\n    }\n  }\n\n  @override\n  void update(double dt) {\n    _scoreTextComponent.text = '${game.starsCollected}';\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that ChildCounterComponent¶: So for example, the following will render the number of SpriteAnimationComponent that are children of the game world:", "completion": "add(\n  ChildCounterComponent<SpriteAnimationComponent>(\n    target: world,\n  ),\n);"}
{"prompt": "Show me how to implement ChildCounterComponent¶: So for example, the following will render the number of SpriteAnimationComponent that are children of the game world: using Flutter Flame", "completion": "add(\n  ChildCounterComponent<SpriteAnimationComponent>(\n    target: world,\n  ),\n);"}
{"prompt": "Write Flutter Flame code to ChildCounterComponent¶: So for example, the following will render the number of SpriteAnimationComponent that are children of the game world:", "completion": "add(\n  ChildCounterComponent<SpriteAnimationComponent>(\n    target: world,\n  ),\n);"}
{"prompt": "Create a Flutter Flame game component that TimeTrackComponent¶: Then in the code section that you want to track time, do the following:", "completion": "void update(double dt) {\n  TimeTrackComponent.start('MyComponent.update');\n  // ...\n  TimeTrackComponent.end('MyComponent.update');\n}"}
{"prompt": "Show me how to implement TimeTrackComponent¶: Then in the code section that you want to track time, do the following: using Flutter Flame", "completion": "void update(double dt) {\n  TimeTrackComponent.start('MyComponent.update');\n  // ...\n  TimeTrackComponent.end('MyComponent.update');\n}"}
{"prompt": "Write Flutter Flame code to TimeTrackComponent¶: Then in the code section that you want to track time, do the following:", "completion": "void update(double dt) {\n  TimeTrackComponent.start('MyComponent.update');\n  // ...\n  TimeTrackComponent.end('MyComponent.update');\n}"}
{"prompt": "Create a Flutter Flame game component that Main Menu¶: In the lib/overlays folder, create main_menu.dart and add the following code:", "completion": "import 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\n\nclass MainMenu extends StatelessWidget {\n  // Reference to parent game.\n  final EmberQuestGame game;\n\n  const MainMenu({super.key, required this.game});\n\n  @override\n  Widget build(BuildContext context) {\n    const blackTextColor = Color.fromRGBO(0, 0, 0, 1.0);\n    const whiteTextColor = Color.fromRGBO(255, 255, 255, 1.0);\n\n    return Material(\n      color: Colors.transparent,\n      child: Center(\n        child: Container(\n          padding: const EdgeInsets.all(10.0),\n          height: 250,\n          width: 300,\n          decoration: const BoxDecoration(\n            color: blackTextColor,\n            borderRadius: const BorderRadius.all(\n              Radius.circular(20),\n            ),\n          ),\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              const Text(\n                'Ember Quest',\n                style: TextStyle(\n                  color: whiteTextColor,\n                  fontSize: 24,\n                ),\n              ),\n              const SizedBox(height: 40),\n              SizedBox(\n                width: 200,\n                height: 75,\n                child: ElevatedButton(\n                  onPressed: () {\n                    game.overlays.remove('MainMenu');\n                  },\n                  style: ElevatedButton.styleFrom(\n                    backgroundColor: whiteTextColor,\n                  ),\n                  child: const Text(\n                    'Play',\n                    style: TextStyle(\n                      fontSize: 40.0,\n                      color: blackTextColor,\n                    ),\n                  ),\n                ),\n              ),\n              const SizedBox(height: 20),\n              const Text(\n'''Use WASD or Arrow Keys for movement.\nSpace bar to jump.\nCollect as many stars as you can and avoid enemies!''',\n                textAlign: TextAlign.center,\n                style: TextStyle(\n                  color: whiteTextColor,\n                  fontSize: 14,\n                ),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"prompt": "Show me how to implement Main Menu¶: In the lib/overlays folder, create main_menu.dart and add the following code: using Flutter Flame", "completion": "import 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\n\nclass MainMenu extends StatelessWidget {\n  // Reference to parent game.\n  final EmberQuestGame game;\n\n  const MainMenu({super.key, required this.game});\n\n  @override\n  Widget build(BuildContext context) {\n    const blackTextColor = Color.fromRGBO(0, 0, 0, 1.0);\n    const whiteTextColor = Color.fromRGBO(255, 255, 255, 1.0);\n\n    return Material(\n      color: Colors.transparent,\n      child: Center(\n        child: Container(\n          padding: const EdgeInsets.all(10.0),\n          height: 250,\n          width: 300,\n          decoration: const BoxDecoration(\n            color: blackTextColor,\n            borderRadius: const BorderRadius.all(\n              Radius.circular(20),\n            ),\n          ),\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              const Text(\n                'Ember Quest',\n                style: TextStyle(\n                  color: whiteTextColor,\n                  fontSize: 24,\n                ),\n              ),\n              const SizedBox(height: 40),\n              SizedBox(\n                width: 200,\n                height: 75,\n                child: ElevatedButton(\n                  onPressed: () {\n                    game.overlays.remove('MainMenu');\n                  },\n                  style: ElevatedButton.styleFrom(\n                    backgroundColor: whiteTextColor,\n                  ),\n                  child: const Text(\n                    'Play',\n                    style: TextStyle(\n                      fontSize: 40.0,\n                      color: blackTextColor,\n                    ),\n                  ),\n                ),\n              ),\n              const SizedBox(height: 20),\n              const Text(\n'''Use WASD or Arrow Keys for movement.\nSpace bar to jump.\nCollect as many stars as you can and avoid enemies!''',\n                textAlign: TextAlign.center,\n                style: TextStyle(\n                  color: whiteTextColor,\n                  fontSize: 14,\n                ),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"prompt": "Write Flutter Flame code to Main Menu¶: In the lib/overlays folder, create main_menu.dart and add the following code:", "completion": "import 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\n\nclass MainMenu extends StatelessWidget {\n  // Reference to parent game.\n  final EmberQuestGame game;\n\n  const MainMenu({super.key, required this.game});\n\n  @override\n  Widget build(BuildContext context) {\n    const blackTextColor = Color.fromRGBO(0, 0, 0, 1.0);\n    const whiteTextColor = Color.fromRGBO(255, 255, 255, 1.0);\n\n    return Material(\n      color: Colors.transparent,\n      child: Center(\n        child: Container(\n          padding: const EdgeInsets.all(10.0),\n          height: 250,\n          width: 300,\n          decoration: const BoxDecoration(\n            color: blackTextColor,\n            borderRadius: const BorderRadius.all(\n              Radius.circular(20),\n            ),\n          ),\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              const Text(\n                'Ember Quest',\n                style: TextStyle(\n                  color: whiteTextColor,\n                  fontSize: 24,\n                ),\n              ),\n              const SizedBox(height: 40),\n              SizedBox(\n                width: 200,\n                height: 75,\n                child: ElevatedButton(\n                  onPressed: () {\n                    game.overlays.remove('MainMenu');\n                  },\n                  style: ElevatedButton.styleFrom(\n                    backgroundColor: whiteTextColor,\n                  ),\n                  child: const Text(\n                    'Play',\n                    style: TextStyle(\n                      fontSize: 40.0,\n                      color: blackTextColor,\n                    ),\n                  ),\n                ),\n              ),\n              const SizedBox(height: 20),\n              const Text(\n'''Use WASD or Arrow Keys for movement.\nSpace bar to jump.\nCollect as many stars as you can and avoid enemies!''',\n                textAlign: TextAlign.center,\n                style: TextStyle(\n                  color: whiteTextColor,\n                  fontSize: 14,\n                ),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Game Over Menu¶: Next, create a file called lib/overlays/game_over.dart and add the following code:", "completion": "import 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\n\nclass GameOver extends StatelessWidget {\n  // Reference to parent game.\n  final EmberQuestGame game;\n  const GameOver({super.key, required this.game});\n\n  @override\n  Widget build(BuildContext context) {\n    const blackTextColor = Color.fromRGBO(0, 0, 0, 1.0);\n    const whiteTextColor = Color.fromRGBO(255, 255, 255, 1.0);\n\n    return Material(\n      color: Colors.transparent,\n      child: Center(\n        child: Container(\n          padding: const EdgeInsets.all(10.0),\n          height: 200,\n          width: 300,\n          decoration: const BoxDecoration(\n            color: blackTextColor,\n            borderRadius: const BorderRadius.all(\n              Radius.circular(20),\n            ),\n          ),\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              const Text(\n                'Game Over',\n                style: TextStyle(\n                  color: whiteTextColor,\n                  fontSize: 24,\n                ),\n              ),\n              const SizedBox(height: 40),\n              SizedBox(\n                width: 200,\n                height: 75,\n                child: ElevatedButton(\n                  onPressed: () {\n                    game.reset();\n                    game.overlays.remove('GameOver');\n                  },\n                  style: ElevatedButton.styleFrom(\n                    backgroundColor: whiteTextColor,\n                  ),\n                  child: const Text(\n                    'Play Again',\n                    style: TextStyle(\n                      fontSize: 28.0,\n                      color: blackTextColor,\n                    ),\n                  ),\n                ),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"prompt": "Show me how to implement Game Over Menu¶: Next, create a file called lib/overlays/game_over.dart and add the following code: using Flutter Flame", "completion": "import 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\n\nclass GameOver extends StatelessWidget {\n  // Reference to parent game.\n  final EmberQuestGame game;\n  const GameOver({super.key, required this.game});\n\n  @override\n  Widget build(BuildContext context) {\n    const blackTextColor = Color.fromRGBO(0, 0, 0, 1.0);\n    const whiteTextColor = Color.fromRGBO(255, 255, 255, 1.0);\n\n    return Material(\n      color: Colors.transparent,\n      child: Center(\n        child: Container(\n          padding: const EdgeInsets.all(10.0),\n          height: 200,\n          width: 300,\n          decoration: const BoxDecoration(\n            color: blackTextColor,\n            borderRadius: const BorderRadius.all(\n              Radius.circular(20),\n            ),\n          ),\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              const Text(\n                'Game Over',\n                style: TextStyle(\n                  color: whiteTextColor,\n                  fontSize: 24,\n                ),\n              ),\n              const SizedBox(height: 40),\n              SizedBox(\n                width: 200,\n                height: 75,\n                child: ElevatedButton(\n                  onPressed: () {\n                    game.reset();\n                    game.overlays.remove('GameOver');\n                  },\n                  style: ElevatedButton.styleFrom(\n                    backgroundColor: whiteTextColor,\n                  ),\n                  child: const Text(\n                    'Play Again',\n                    style: TextStyle(\n                      fontSize: 28.0,\n                      color: blackTextColor,\n                    ),\n                  ),\n                ),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"prompt": "Write Flutter Flame code to Game Over Menu¶: Next, create a file called lib/overlays/game_over.dart and add the following code:", "completion": "import 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\n\nclass GameOver extends StatelessWidget {\n  // Reference to parent game.\n  final EmberQuestGame game;\n  const GameOver({super.key, required this.game});\n\n  @override\n  Widget build(BuildContext context) {\n    const blackTextColor = Color.fromRGBO(0, 0, 0, 1.0);\n    const whiteTextColor = Color.fromRGBO(255, 255, 255, 1.0);\n\n    return Material(\n      color: Colors.transparent,\n      child: Center(\n        child: Container(\n          padding: const EdgeInsets.all(10.0),\n          height: 200,\n          width: 300,\n          decoration: const BoxDecoration(\n            color: blackTextColor,\n            borderRadius: const BorderRadius.all(\n              Radius.circular(20),\n            ),\n          ),\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              const Text(\n                'Game Over',\n                style: TextStyle(\n                  color: whiteTextColor,\n                  fontSize: 24,\n                ),\n              ),\n              const SizedBox(height: 40),\n              SizedBox(\n                width: 200,\n                height: 75,\n                child: ElevatedButton(\n                  onPressed: () {\n                    game.reset();\n                    game.overlays.remove('GameOver');\n                  },\n                  style: ElevatedButton.styleFrom(\n                    backgroundColor: whiteTextColor,\n                  ),\n                  child: const Text(\n                    'Play Again',\n                    style: TextStyle(\n                      fontSize: 28.0,\n                      color: blackTextColor,\n                    ),\n                  ),\n                ),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Game Over Menu¶: Open lib/ember_quest.dart and add / update the following code:", "completion": "@override\nFuture<void> onLoad() async {\n  await images.loadAll([\n      'block.png',\n      'ember.png',\n      'ground.png',\n      'heart_half.png',\n      'heart.png',\n      'star.png',\n      'water_enemy.png',\n  ]);\n  \n  camera.viewfinder.anchor = Anchor.topLeft;\n  initializeGame(true);\n}\n\nvoid initializeGame(bool loadHud) {\n  // Assume that size.x < 3200\n  final segmentsToLoad = (size.x / 640).ceil();\n  segmentsToLoad.clamp(0, segments.length);\n\n  for (var i = 0; i <= segmentsToLoad; i++) {\n    loadGameSegments(i, (640 * i).toDouble());\n  }\n\n  _ember = EmberPlayer(\n    position: Vector2(128, canvasSize.y - 128),\n  );\n  add(_ember);\n  if (loadHud) {\n    add(Hud());\n  }\n}\n\nvoid reset() {\n  starsCollected = 0;\n  health = 3;\n  initializeGame(false);\n}"}
{"prompt": "Show me how to implement Game Over Menu¶: Open lib/ember_quest.dart and add / update the following code: using Flutter Flame", "completion": "@override\nFuture<void> onLoad() async {\n  await images.loadAll([\n      'block.png',\n      'ember.png',\n      'ground.png',\n      'heart_half.png',\n      'heart.png',\n      'star.png',\n      'water_enemy.png',\n  ]);\n  \n  camera.viewfinder.anchor = Anchor.topLeft;\n  initializeGame(true);\n}\n\nvoid initializeGame(bool loadHud) {\n  // Assume that size.x < 3200\n  final segmentsToLoad = (size.x / 640).ceil();\n  segmentsToLoad.clamp(0, segments.length);\n\n  for (var i = 0; i <= segmentsToLoad; i++) {\n    loadGameSegments(i, (640 * i).toDouble());\n  }\n\n  _ember = EmberPlayer(\n    position: Vector2(128, canvasSize.y - 128),\n  );\n  add(_ember);\n  if (loadHud) {\n    add(Hud());\n  }\n}\n\nvoid reset() {\n  starsCollected = 0;\n  health = 3;\n  initializeGame(false);\n}"}
{"prompt": "Write Flutter Flame code to Game Over Menu¶: Open lib/ember_quest.dart and add / update the following code:", "completion": "@override\nFuture<void> onLoad() async {\n  await images.loadAll([\n      'block.png',\n      'ember.png',\n      'ground.png',\n      'heart_half.png',\n      'heart.png',\n      'star.png',\n      'water_enemy.png',\n  ]);\n  \n  camera.viewfinder.anchor = Anchor.topLeft;\n  initializeGame(true);\n}\n\nvoid initializeGame(bool loadHud) {\n  // Assume that size.x < 3200\n  final segmentsToLoad = (size.x / 640).ceil();\n  segmentsToLoad.clamp(0, segments.length);\n\n  for (var i = 0; i <= segmentsToLoad; i++) {\n    loadGameSegments(i, (640 * i).toDouble());\n  }\n\n  _ember = EmberPlayer(\n    position: Vector2(128, canvasSize.y - 128),\n  );\n  add(_ember);\n  if (loadHud) {\n    add(Hud());\n  }\n}\n\nvoid reset() {\n  starsCollected = 0;\n  health = 3;\n  initializeGame(false);\n}"}
{"prompt": "Create a Flutter Flame game component that Displaying the Menus¶: To display the menus, add the following code to lib/main.dart:", "completion": "void main() {\n  runApp(\n    GameWidget<EmberQuestGame>.controlled(\n      gameFactory: EmberQuestGame.new,\n      overlayBuilderMap: {\n        'MainMenu': (_, game) => MainMenu(game: game),\n        'GameOver': (_, game) => GameOver(game: game),\n      },\n      initialActiveOverlays: const ['MainMenu'],\n    ),\n  );\n}"}
{"prompt": "Show me how to implement Displaying the Menus¶: To display the menus, add the following code to lib/main.dart: using Flutter Flame", "completion": "void main() {\n  runApp(\n    GameWidget<EmberQuestGame>.controlled(\n      gameFactory: EmberQuestGame.new,\n      overlayBuilderMap: {\n        'MainMenu': (_, game) => MainMenu(game: game),\n        'GameOver': (_, game) => GameOver(game: game),\n      },\n      initialActiveOverlays: const ['MainMenu'],\n    ),\n  );\n}"}
{"prompt": "Write Flutter Flame code to Displaying the Menus¶: To display the menus, add the following code to lib/main.dart:", "completion": "void main() {\n  runApp(\n    GameWidget<EmberQuestGame>.controlled(\n      gameFactory: EmberQuestGame.new,\n      overlayBuilderMap: {\n        'MainMenu': (_, game) => MainMenu(game: game),\n        'GameOver': (_, game) => GameOver(game: game),\n      },\n      initialActiveOverlays: const ['MainMenu'],\n    ),\n  );\n}"}
{"prompt": "Create a Flutter Flame game component that Health Check for Game Over¶: Finally, in lib/ember_quest.dart, add the following update method:", "completion": "@override\nvoid update(double dt) {\n  if (health <= 0) {\n    overlays.add('GameOver');\n  }\n  super.update(dt);\n}"}
{"prompt": "Show me how to implement Health Check for Game Over¶: Finally, in lib/ember_quest.dart, add the following update method: using Flutter Flame", "completion": "@override\nvoid update(double dt) {\n  if (health <= 0) {\n    overlays.add('GameOver');\n  }\n  super.update(dt);\n}"}
{"prompt": "Write Flutter Flame code to Health Check for Game Over¶: Finally, in lib/ember_quest.dart, add the following update method:", "completion": "@override\nvoid update(double dt) {\n  if (health <= 0) {\n    overlays.add('GameOver');\n  }\n  super.update(dt);\n}"}
{"prompt": "Create a Flutter Flame game component that Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live.", "completion": "import 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flutter/services.dart';\n\nimport '../ember_quest.dart';\nimport '../objects/ground_block.dart';\nimport '../objects/platform_block.dart';\nimport '../objects/star.dart';\nimport 'water_enemy.dart';\n\nclass EmberPlayer extends SpriteAnimationComponent\nwith KeyboardHandler, CollisionCallbacks, HasGameReference<EmberQuestGame> {\nEmberPlayer({\nrequired super.position,\n}) : super(size: Vector2.all(64), anchor: Anchor.center);\n\nfinal Vector2 velocity = Vector2.zero();\nfinal Vector2 fromAbove = Vector2(0, -1);\nfinal double gravity = 15;\nfinal double jumpSpeed = 600;\nfinal double moveSpeed = 200;\nfinal double terminalVelocity = 150;\nint horizontalDirection = 0;\n\nbool hasJumped = false;\nbool isOnGround = false;\nbool hitByEnemy = false;\n\n@override\nFuture<void> onLoad() async {\nanimation = SpriteAnimation.fromFrameData(\ngame.images.fromCache('ember.png'),\nSpriteAnimationData.sequenced(\namount: 4,\ntextureSize: Vector2.all(16),\nstepTime: 0.12,\n),\n);\n\nadd(\nCircleHitbox(),\n);\n}\n\n@override\nbool onKeyEvent(KeyEvent event, Set<LogicalKeyboardKey> keysPressed) {\nhorizontalDirection = 0;\nhorizontalDirection += (keysPressed.contains(LogicalKeyboardKey.keyA) ||\nkeysPressed.contains(LogicalKeyboardKey.arrowLeft))\n? -1\n: 0;\nhorizontalDirection += (keysPressed.contains(LogicalKeyboardKey.keyD) ||\nkeysPressed.contains(LogicalKeyboardKey.arrowRight))\n? 1\n: 0;\n\nhasJumped = keysPressed.contains(LogicalKeyboardKey.space);\nreturn true;\n}\n\n@override\nvoid update(double dt) {\nvelocity.x = horizontalDirection * moveSpeed;\ngame.objectSpeed = 0;\n// Prevent ember from going backwards at screen edge.\nif (position.x - 36 <= 0 && horizontalDirection < 0) {\nvelocity.x = 0;\n}\n// Prevent ember from going beyond half screen.\nif (position.x + 64 >= game.size.x / 2 && horizontalDirection > 0) {\nvelocity.x = 0;\ngame.objectSpeed = -moveSpeed;\n}\n\n// Apply basic gravity.\nvelocity.y += gravity;\n\n// Determine if ember has jumped.\nif (hasJumped) {\nif (isOnGround) {\nvelocity.y = -jumpSpeed;\nisOnGround = false;\n}\nhasJumped = false;\n}\n\n// Prevent ember from jumping to crazy fast.\nvelocity.y = velocity.y.clamp(-jumpSpeed, terminalVelocity);\n\n// Adjust ember position.\nposition += velocity * dt;\n\n// If ember fell in pit, then game over.\nif (position.y > game.size.y + size.y) {\ngame.health = 0;\n}\n\nif (game.health <= 0) {\nremoveFromParent();\n}\n\n// Flip ember if needed.\nif (horizontalDirection < 0 && scale.x > 0) {\nflipHorizontally();\n} else if (horizontalDirection > 0 && scale.x < 0) {\nflipHorizontally();\n}\nsuper.update(dt);\n}\n\n@override\nvoid onCollision(Set<Vector2> intersectionPoints, PositionComponent other) {\nif (other is GroundBlock || other is PlatformBlock) {\nif (intersectionPoints.length == 2) {\n// Calculate the collision normal and separation distance.\nfinal mid = (intersectionPoints.elementAt(0) +\nintersectionPoints.elementAt(1)) /\n2;\n\nfinal collisionNormal = absoluteCenter - mid;\nfinal separationDistance = (size.x / 2) - collisionNormal.length;\ncollisionNormal.normalize();\n\n// If collision normal is almost upwards,\n// ember must be on ground.\nif (fromAbove.dot(collisionNormal) > 0.9) {\nisOnGround = true;\n}\n\n// Resolve collision by moving ember along\n// collision normal by separation distance.\nposition += collisionNormal.scaled(separationDistance);\n}\n}\n\nif (other is Star) {\nother.removeFromParent();\ngame.starsCollected++;\n}\n\nif (other is WaterEnemy) {\nhit();\n}\nsuper.onCollision(intersectionPoints, other);\n}\n\n// This method runs an opacity effect on ember\n// to make it blink.\nvoid hit() {\nif (!hitByEnemy) {\ngame.health--;\nhitByEnemy = true;\n}\nadd(\nOpacityEffect.fadeOut(\nEffectController(\nalternate: true,\nduration: 0.1,\nrepeatCount: 5,\n),\n)..onComplete = () {\nhitByEnemy = false;\n},\n);\n}\n}"}
{"prompt": "Show me how to implement Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live. using Flutter Flame", "completion": "import 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flutter/services.dart';\n\nimport '../ember_quest.dart';\nimport '../objects/ground_block.dart';\nimport '../objects/platform_block.dart';\nimport '../objects/star.dart';\nimport 'water_enemy.dart';\n\nclass EmberPlayer extends SpriteAnimationComponent\nwith KeyboardHandler, CollisionCallbacks, HasGameReference<EmberQuestGame> {\nEmberPlayer({\nrequired super.position,\n}) : super(size: Vector2.all(64), anchor: Anchor.center);\n\nfinal Vector2 velocity = Vector2.zero();\nfinal Vector2 fromAbove = Vector2(0, -1);\nfinal double gravity = 15;\nfinal double jumpSpeed = 600;\nfinal double moveSpeed = 200;\nfinal double terminalVelocity = 150;\nint horizontalDirection = 0;\n\nbool hasJumped = false;\nbool isOnGround = false;\nbool hitByEnemy = false;\n\n@override\nFuture<void> onLoad() async {\nanimation = SpriteAnimation.fromFrameData(\ngame.images.fromCache('ember.png'),\nSpriteAnimationData.sequenced(\namount: 4,\ntextureSize: Vector2.all(16),\nstepTime: 0.12,\n),\n);\n\nadd(\nCircleHitbox(),\n);\n}\n\n@override\nbool onKeyEvent(KeyEvent event, Set<LogicalKeyboardKey> keysPressed) {\nhorizontalDirection = 0;\nhorizontalDirection += (keysPressed.contains(LogicalKeyboardKey.keyA) ||\nkeysPressed.contains(LogicalKeyboardKey.arrowLeft))\n? -1\n: 0;\nhorizontalDirection += (keysPressed.contains(LogicalKeyboardKey.keyD) ||\nkeysPressed.contains(LogicalKeyboardKey.arrowRight))\n? 1\n: 0;\n\nhasJumped = keysPressed.contains(LogicalKeyboardKey.space);\nreturn true;\n}\n\n@override\nvoid update(double dt) {\nvelocity.x = horizontalDirection * moveSpeed;\ngame.objectSpeed = 0;\n// Prevent ember from going backwards at screen edge.\nif (position.x - 36 <= 0 && horizontalDirection < 0) {\nvelocity.x = 0;\n}\n// Prevent ember from going beyond half screen.\nif (position.x + 64 >= game.size.x / 2 && horizontalDirection > 0) {\nvelocity.x = 0;\ngame.objectSpeed = -moveSpeed;\n}\n\n// Apply basic gravity.\nvelocity.y += gravity;\n\n// Determine if ember has jumped.\nif (hasJumped) {\nif (isOnGround) {\nvelocity.y = -jumpSpeed;\nisOnGround = false;\n}\nhasJumped = false;\n}\n\n// Prevent ember from jumping to crazy fast.\nvelocity.y = velocity.y.clamp(-jumpSpeed, terminalVelocity);\n\n// Adjust ember position.\nposition += velocity * dt;\n\n// If ember fell in pit, then game over.\nif (position.y > game.size.y + size.y) {\ngame.health = 0;\n}\n\nif (game.health <= 0) {\nremoveFromParent();\n}\n\n// Flip ember if needed.\nif (horizontalDirection < 0 && scale.x > 0) {\nflipHorizontally();\n} else if (horizontalDirection > 0 && scale.x < 0) {\nflipHorizontally();\n}\nsuper.update(dt);\n}\n\n@override\nvoid onCollision(Set<Vector2> intersectionPoints, PositionComponent other) {\nif (other is GroundBlock || other is PlatformBlock) {\nif (intersectionPoints.length == 2) {\n// Calculate the collision normal and separation distance.\nfinal mid = (intersectionPoints.elementAt(0) +\nintersectionPoints.elementAt(1)) /\n2;\n\nfinal collisionNormal = absoluteCenter - mid;\nfinal separationDistance = (size.x / 2) - collisionNormal.length;\ncollisionNormal.normalize();\n\n// If collision normal is almost upwards,\n// ember must be on ground.\nif (fromAbove.dot(collisionNormal) > 0.9) {\nisOnGround = true;\n}\n\n// Resolve collision by moving ember along\n// collision normal by separation distance.\nposition += collisionNormal.scaled(separationDistance);\n}\n}\n\nif (other is Star) {\nother.removeFromParent();\ngame.starsCollected++;\n}\n\nif (other is WaterEnemy) {\nhit();\n}\nsuper.onCollision(intersectionPoints, other);\n}\n\n// This method runs an opacity effect on ember\n// to make it blink.\nvoid hit() {\nif (!hitByEnemy) {\ngame.health--;\nhitByEnemy = true;\n}\nadd(\nOpacityEffect.fadeOut(\nEffectController(\nalternate: true,\nduration: 0.1,\nrepeatCount: 5,\n),\n)..onComplete = () {\nhitByEnemy = false;\n},\n);\n}\n}"}
{"prompt": "Write Flutter Flame code to Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live.", "completion": "import 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flutter/services.dart';\n\nimport '../ember_quest.dart';\nimport '../objects/ground_block.dart';\nimport '../objects/platform_block.dart';\nimport '../objects/star.dart';\nimport 'water_enemy.dart';\n\nclass EmberPlayer extends SpriteAnimationComponent\nwith KeyboardHandler, CollisionCallbacks, HasGameReference<EmberQuestGame> {\nEmberPlayer({\nrequired super.position,\n}) : super(size: Vector2.all(64), anchor: Anchor.center);\n\nfinal Vector2 velocity = Vector2.zero();\nfinal Vector2 fromAbove = Vector2(0, -1);\nfinal double gravity = 15;\nfinal double jumpSpeed = 600;\nfinal double moveSpeed = 200;\nfinal double terminalVelocity = 150;\nint horizontalDirection = 0;\n\nbool hasJumped = false;\nbool isOnGround = false;\nbool hitByEnemy = false;\n\n@override\nFuture<void> onLoad() async {\nanimation = SpriteAnimation.fromFrameData(\ngame.images.fromCache('ember.png'),\nSpriteAnimationData.sequenced(\namount: 4,\ntextureSize: Vector2.all(16),\nstepTime: 0.12,\n),\n);\n\nadd(\nCircleHitbox(),\n);\n}\n\n@override\nbool onKeyEvent(KeyEvent event, Set<LogicalKeyboardKey> keysPressed) {\nhorizontalDirection = 0;\nhorizontalDirection += (keysPressed.contains(LogicalKeyboardKey.keyA) ||\nkeysPressed.contains(LogicalKeyboardKey.arrowLeft))\n? -1\n: 0;\nhorizontalDirection += (keysPressed.contains(LogicalKeyboardKey.keyD) ||\nkeysPressed.contains(LogicalKeyboardKey.arrowRight))\n? 1\n: 0;\n\nhasJumped = keysPressed.contains(LogicalKeyboardKey.space);\nreturn true;\n}\n\n@override\nvoid update(double dt) {\nvelocity.x = horizontalDirection * moveSpeed;\ngame.objectSpeed = 0;\n// Prevent ember from going backwards at screen edge.\nif (position.x - 36 <= 0 && horizontalDirection < 0) {\nvelocity.x = 0;\n}\n// Prevent ember from going beyond half screen.\nif (position.x + 64 >= game.size.x / 2 && horizontalDirection > 0) {\nvelocity.x = 0;\ngame.objectSpeed = -moveSpeed;\n}\n\n// Apply basic gravity.\nvelocity.y += gravity;\n\n// Determine if ember has jumped.\nif (hasJumped) {\nif (isOnGround) {\nvelocity.y = -jumpSpeed;\nisOnGround = false;\n}\nhasJumped = false;\n}\n\n// Prevent ember from jumping to crazy fast.\nvelocity.y = velocity.y.clamp(-jumpSpeed, terminalVelocity);\n\n// Adjust ember position.\nposition += velocity * dt;\n\n// If ember fell in pit, then game over.\nif (position.y > game.size.y + size.y) {\ngame.health = 0;\n}\n\nif (game.health <= 0) {\nremoveFromParent();\n}\n\n// Flip ember if needed.\nif (horizontalDirection < 0 && scale.x > 0) {\nflipHorizontally();\n} else if (horizontalDirection > 0 && scale.x < 0) {\nflipHorizontally();\n}\nsuper.update(dt);\n}\n\n@override\nvoid onCollision(Set<Vector2> intersectionPoints, PositionComponent other) {\nif (other is GroundBlock || other is PlatformBlock) {\nif (intersectionPoints.length == 2) {\n// Calculate the collision normal and separation distance.\nfinal mid = (intersectionPoints.elementAt(0) +\nintersectionPoints.elementAt(1)) /\n2;\n\nfinal collisionNormal = absoluteCenter - mid;\nfinal separationDistance = (size.x / 2) - collisionNormal.length;\ncollisionNormal.normalize();\n\n// If collision normal is almost upwards,\n// ember must be on ground.\nif (fromAbove.dot(collisionNormal) > 0.9) {\nisOnGround = true;\n}\n\n// Resolve collision by moving ember along\n// collision normal by separation distance.\nposition += collisionNormal.scaled(separationDistance);\n}\n}\n\nif (other is Star) {\nother.removeFromParent();\ngame.starsCollected++;\n}\n\nif (other is WaterEnemy) {\nhit();\n}\nsuper.onCollision(intersectionPoints, other);\n}\n\n// This method runs an opacity effect on ember\n// to make it blink.\nvoid hit() {\nif (!hitByEnemy) {\ngame.health--;\nhitByEnemy = true;\n}\nadd(\nOpacityEffect.fadeOut(\nEffectController(\nalternate: true,\nduration: 0.1,\nrepeatCount: 5,\n),\n)..onComplete = () {\nhitByEnemy = false;\n},\n);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live.", "completion": "import 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\n\nimport '../ember_quest.dart';\n\nclass WaterEnemy extends SpriteAnimationComponent\nwith HasGameReference<EmberQuestGame> {\nfinal Vector2 gridPosition;\ndouble xOffset;\n\nfinal Vector2 velocity = Vector2.zero();\n\nWaterEnemy({\nrequired this.gridPosition,\nrequired this.xOffset,\n}) : super(size: Vector2.all(64), anchor: Anchor.bottomLeft);\n\n@override\nFuture<void> onLoad() async {\nanimation = SpriteAnimation.fromFrameData(\ngame.images.fromCache('water_enemy.png'),\nSpriteAnimationData.sequenced(\namount: 2,\ntextureSize: Vector2.all(16),\nstepTime: 0.7,\n),\n);\nposition = Vector2(\n(gridPosition.x * size.x) + xOffset,\ngame.size.y - (gridPosition.y * size.y),\n);\nadd(RectangleHitbox(collisionType: CollisionType.passive));\nadd(\nMoveEffect.by(\nVector2(-2 * size.x, 0),\nEffectController(\nduration: 3,\nalternate: true,\ninfinite: true,\n),\n),\n);\n}\n\n@override\nvoid update(double dt) {\nvelocity.x = game.objectSpeed;\nposition += velocity * dt;\nif (position.x < -size.x || game.health <= 0) {\nremoveFromParent();\n}\nsuper.update(dt);\n}\n}"}
{"prompt": "Show me how to implement Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live. using Flutter Flame", "completion": "import 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\n\nimport '../ember_quest.dart';\n\nclass WaterEnemy extends SpriteAnimationComponent\nwith HasGameReference<EmberQuestGame> {\nfinal Vector2 gridPosition;\ndouble xOffset;\n\nfinal Vector2 velocity = Vector2.zero();\n\nWaterEnemy({\nrequired this.gridPosition,\nrequired this.xOffset,\n}) : super(size: Vector2.all(64), anchor: Anchor.bottomLeft);\n\n@override\nFuture<void> onLoad() async {\nanimation = SpriteAnimation.fromFrameData(\ngame.images.fromCache('water_enemy.png'),\nSpriteAnimationData.sequenced(\namount: 2,\ntextureSize: Vector2.all(16),\nstepTime: 0.7,\n),\n);\nposition = Vector2(\n(gridPosition.x * size.x) + xOffset,\ngame.size.y - (gridPosition.y * size.y),\n);\nadd(RectangleHitbox(collisionType: CollisionType.passive));\nadd(\nMoveEffect.by(\nVector2(-2 * size.x, 0),\nEffectController(\nduration: 3,\nalternate: true,\ninfinite: true,\n),\n),\n);\n}\n\n@override\nvoid update(double dt) {\nvelocity.x = game.objectSpeed;\nposition += velocity * dt;\nif (position.x < -size.x || game.health <= 0) {\nremoveFromParent();\n}\nsuper.update(dt);\n}\n}"}
{"prompt": "Write Flutter Flame code to Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live.", "completion": "import 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\n\nimport '../ember_quest.dart';\n\nclass WaterEnemy extends SpriteAnimationComponent\nwith HasGameReference<EmberQuestGame> {\nfinal Vector2 gridPosition;\ndouble xOffset;\n\nfinal Vector2 velocity = Vector2.zero();\n\nWaterEnemy({\nrequired this.gridPosition,\nrequired this.xOffset,\n}) : super(size: Vector2.all(64), anchor: Anchor.bottomLeft);\n\n@override\nFuture<void> onLoad() async {\nanimation = SpriteAnimation.fromFrameData(\ngame.images.fromCache('water_enemy.png'),\nSpriteAnimationData.sequenced(\namount: 2,\ntextureSize: Vector2.all(16),\nstepTime: 0.7,\n),\n);\nposition = Vector2(\n(gridPosition.x * size.x) + xOffset,\ngame.size.y - (gridPosition.y * size.y),\n);\nadd(RectangleHitbox(collisionType: CollisionType.passive));\nadd(\nMoveEffect.by(\nVector2(-2 * size.x, 0),\nEffectController(\nduration: 3,\nalternate: true,\ninfinite: true,\n),\n),\n);\n}\n\n@override\nvoid update(double dt) {\nvelocity.x = game.objectSpeed;\nposition += velocity * dt;\nif (position.x < -size.x || game.health <= 0) {\nremoveFromParent();\n}\nsuper.update(dt);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live.", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flutter/material.dart';\n\nimport 'actors/ember.dart';\nimport 'actors/water_enemy.dart';\nimport 'managers/segment_manager.dart';\nimport 'objects/ground_block.dart';\nimport 'objects/platform_block.dart';\nimport 'objects/star.dart';\nimport 'overlays/hud.dart';\n\nclass EmberQuestGame extends FlameGame\nwith HasCollisionDetection, HasKeyboardHandlerComponents {\nEmberQuestGame();\n\nlate EmberPlayer _ember;\nlate double lastBlockXPosition = 0.0;\nlate UniqueKey lastBlockKey;\n\nint starsCollected = 0;\nint health = 3;\ndouble cloudSpeed = 0.0;\ndouble objectSpeed = 0.0;\n\n@override\nFuture<void> onLoad() async {\n//debugMode = true; // Uncomment to see the bounding boxes\nawait images.loadAll([\n'block.png',\n'ember.png',\n'ground.png',\n'heart_half.png',\n'heart.png',\n'star.png',\n'water_enemy.png',\n]);\ncamera.viewfinder.anchor = Anchor.topLeft;\n\ninitializeGame(loadHud: true);\n}\n\n@override\nvoid update(double dt) {\nif (health <= 0) {\noverlays.add('GameOver');\n}\nsuper.update(dt);\n}\n\n@override\nColor backgroundColor() {\nreturn const Color.fromARGB(255, 173, 223, 247);\n}\n\nvoid loadGameSegments(int segmentIndex, double xPositionOffset) {\nfor (final block in segments[segmentIndex]) {\nfinal component = switch (block.blockType) {\nconst (GroundBlock) => GroundBlock(\ngridPosition: block.gridPosition,\nxOffset: xPositionOffset,\n),\nconst (PlatformBlock) => PlatformBlock(\ngridPosition: block.gridPosition,\nxOffset: xPositionOffset,\n),\nconst (Star) => Star(\ngridPosition: block.gridPosition,\nxOffset: xPositionOffset,\n),\nconst (WaterEnemy) => WaterEnemy(\ngridPosition: block.gridPosition,\nxOffset: xPositionOffset,\n),\n_ => throw UnimplementedError(),\n};\nworld.add(component);\n}\n}\n\nvoid initializeGame({required bool loadHud}) {\n// Assume that size.x < 3200\nfinal segmentsToLoad = (size.x / 640).ceil();\nsegmentsToLoad.clamp(0, segments.length);\n\nfor (var i = 0; i <= segmentsToLoad; i++) {\nloadGameSegments(i, (640 * i).toDouble());\n}\n\n_ember = EmberPlayer(\nposition: Vector2(128, canvasSize.y - 128),\n);\nworld.add(_ember);\nif (loadHud) {\ncamera.viewport.add(Hud());\n}\n}\n\nvoid reset() {\nstarsCollected = 0;\nhealth = 3;\ninitializeGame(loadHud: false);\n}\n}"}
{"prompt": "Show me how to implement Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live. using Flutter Flame", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flutter/material.dart';\n\nimport 'actors/ember.dart';\nimport 'actors/water_enemy.dart';\nimport 'managers/segment_manager.dart';\nimport 'objects/ground_block.dart';\nimport 'objects/platform_block.dart';\nimport 'objects/star.dart';\nimport 'overlays/hud.dart';\n\nclass EmberQuestGame extends FlameGame\nwith HasCollisionDetection, HasKeyboardHandlerComponents {\nEmberQuestGame();\n\nlate EmberPlayer _ember;\nlate double lastBlockXPosition = 0.0;\nlate UniqueKey lastBlockKey;\n\nint starsCollected = 0;\nint health = 3;\ndouble cloudSpeed = 0.0;\ndouble objectSpeed = 0.0;\n\n@override\nFuture<void> onLoad() async {\n//debugMode = true; // Uncomment to see the bounding boxes\nawait images.loadAll([\n'block.png',\n'ember.png',\n'ground.png',\n'heart_half.png',\n'heart.png',\n'star.png',\n'water_enemy.png',\n]);\ncamera.viewfinder.anchor = Anchor.topLeft;\n\ninitializeGame(loadHud: true);\n}\n\n@override\nvoid update(double dt) {\nif (health <= 0) {\noverlays.add('GameOver');\n}\nsuper.update(dt);\n}\n\n@override\nColor backgroundColor() {\nreturn const Color.fromARGB(255, 173, 223, 247);\n}\n\nvoid loadGameSegments(int segmentIndex, double xPositionOffset) {\nfor (final block in segments[segmentIndex]) {\nfinal component = switch (block.blockType) {\nconst (GroundBlock) => GroundBlock(\ngridPosition: block.gridPosition,\nxOffset: xPositionOffset,\n),\nconst (PlatformBlock) => PlatformBlock(\ngridPosition: block.gridPosition,\nxOffset: xPositionOffset,\n),\nconst (Star) => Star(\ngridPosition: block.gridPosition,\nxOffset: xPositionOffset,\n),\nconst (WaterEnemy) => WaterEnemy(\ngridPosition: block.gridPosition,\nxOffset: xPositionOffset,\n),\n_ => throw UnimplementedError(),\n};\nworld.add(component);\n}\n}\n\nvoid initializeGame({required bool loadHud}) {\n// Assume that size.x < 3200\nfinal segmentsToLoad = (size.x / 640).ceil();\nsegmentsToLoad.clamp(0, segments.length);\n\nfor (var i = 0; i <= segmentsToLoad; i++) {\nloadGameSegments(i, (640 * i).toDouble());\n}\n\n_ember = EmberPlayer(\nposition: Vector2(128, canvasSize.y - 128),\n);\nworld.add(_ember);\nif (loadHud) {\ncamera.viewport.add(Hud());\n}\n}\n\nvoid reset() {\nstarsCollected = 0;\nhealth = 3;\ninitializeGame(loadHud: false);\n}\n}"}
{"prompt": "Write Flutter Flame code to Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live.", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flutter/material.dart';\n\nimport 'actors/ember.dart';\nimport 'actors/water_enemy.dart';\nimport 'managers/segment_manager.dart';\nimport 'objects/ground_block.dart';\nimport 'objects/platform_block.dart';\nimport 'objects/star.dart';\nimport 'overlays/hud.dart';\n\nclass EmberQuestGame extends FlameGame\nwith HasCollisionDetection, HasKeyboardHandlerComponents {\nEmberQuestGame();\n\nlate EmberPlayer _ember;\nlate double lastBlockXPosition = 0.0;\nlate UniqueKey lastBlockKey;\n\nint starsCollected = 0;\nint health = 3;\ndouble cloudSpeed = 0.0;\ndouble objectSpeed = 0.0;\n\n@override\nFuture<void> onLoad() async {\n//debugMode = true; // Uncomment to see the bounding boxes\nawait images.loadAll([\n'block.png',\n'ember.png',\n'ground.png',\n'heart_half.png',\n'heart.png',\n'star.png',\n'water_enemy.png',\n]);\ncamera.viewfinder.anchor = Anchor.topLeft;\n\ninitializeGame(loadHud: true);\n}\n\n@override\nvoid update(double dt) {\nif (health <= 0) {\noverlays.add('GameOver');\n}\nsuper.update(dt);\n}\n\n@override\nColor backgroundColor() {\nreturn const Color.fromARGB(255, 173, 223, 247);\n}\n\nvoid loadGameSegments(int segmentIndex, double xPositionOffset) {\nfor (final block in segments[segmentIndex]) {\nfinal component = switch (block.blockType) {\nconst (GroundBlock) => GroundBlock(\ngridPosition: block.gridPosition,\nxOffset: xPositionOffset,\n),\nconst (PlatformBlock) => PlatformBlock(\ngridPosition: block.gridPosition,\nxOffset: xPositionOffset,\n),\nconst (Star) => Star(\ngridPosition: block.gridPosition,\nxOffset: xPositionOffset,\n),\nconst (WaterEnemy) => WaterEnemy(\ngridPosition: block.gridPosition,\nxOffset: xPositionOffset,\n),\n_ => throw UnimplementedError(),\n};\nworld.add(component);\n}\n}\n\nvoid initializeGame({required bool loadHud}) {\n// Assume that size.x < 3200\nfinal segmentsToLoad = (size.x / 640).ceil();\nsegmentsToLoad.clamp(0, segments.length);\n\nfor (var i = 0; i <= segmentsToLoad; i++) {\nloadGameSegments(i, (640 * i).toDouble());\n}\n\n_ember = EmberPlayer(\nposition: Vector2(128, canvasSize.y - 128),\n);\nworld.add(_ember);\nif (loadHud) {\ncamera.viewport.add(Hud());\n}\n}\n\nvoid reset() {\nstarsCollected = 0;\nhealth = 3;\ninitializeGame(loadHud: false);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live.", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/material.dart';\n\nimport 'ember_quest.dart';\nimport 'overlays/game_over.dart';\nimport 'overlays/main_menu.dart';\n\nvoid main() {\nrunApp(\nGameWidget<EmberQuestGame>.controlled(\ngameFactory: EmberQuestGame.new,\noverlayBuilderMap: {\n'MainMenu': (_, game) => MainMenu(game: game),\n'GameOver': (_, game) => GameOver(game: game),\n},\ninitialActiveOverlays: const ['MainMenu'],\n),\n);\n}"}
{"prompt": "Show me how to implement Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live. using Flutter Flame", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/material.dart';\n\nimport 'ember_quest.dart';\nimport 'overlays/game_over.dart';\nimport 'overlays/main_menu.dart';\n\nvoid main() {\nrunApp(\nGameWidget<EmberQuestGame>.controlled(\ngameFactory: EmberQuestGame.new,\noverlayBuilderMap: {\n'MainMenu': (_, game) => MainMenu(game: game),\n'GameOver': (_, game) => GameOver(game: game),\n},\ninitialActiveOverlays: const ['MainMenu'],\n),\n);\n}"}
{"prompt": "Write Flutter Flame code to Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live.", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/material.dart';\n\nimport 'ember_quest.dart';\nimport 'overlays/game_over.dart';\nimport 'overlays/main_menu.dart';\n\nvoid main() {\nrunApp(\nGameWidget<EmberQuestGame>.controlled(\ngameFactory: EmberQuestGame.new,\noverlayBuilderMap: {\n'MainMenu': (_, game) => MainMenu(game: game),\n'GameOver': (_, game) => GameOver(game: game),\n},\ninitialActiveOverlays: const ['MainMenu'],\n),\n);\n}"}
{"prompt": "Create a Flutter Flame game component that Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live.", "completion": "import 'package:flame/components.dart';\n\nimport '../actors/water_enemy.dart';\nimport '../objects/ground_block.dart';\nimport '../objects/platform_block.dart';\nimport '../objects/star.dart';\n\nclass Block {\n// gridPosition position is always segment based X,Y.\n// 0,0 is the bottom left corner.\n// 10,10 is the upper right corner.\nfinal Vector2 gridPosition;\nfinal Type blockType;\nBlock(this.gridPosition, this.blockType);\n}\n\nfinal segments = [\nsegment0,\nsegment1,\nsegment2,\nsegment3,\nsegment4,\n];\n\nfinal segment0 = [\nBlock(Vector2(0, 0), GroundBlock),\nBlock(Vector2(1, 0), GroundBlock),\nBlock(Vector2(2, 0), GroundBlock),\nBlock(Vector2(3, 0), GroundBlock),\nBlock(Vector2(4, 0), GroundBlock),\nBlock(Vector2(5, 0), GroundBlock),\nBlock(Vector2(5, 1), WaterEnemy),\nBlock(Vector2(5, 3), PlatformBlock),\nBlock(Vector2(6, 0), GroundBlock),\nBlock(Vector2(6, 3), PlatformBlock),\nBlock(Vector2(7, 0), GroundBlock),\nBlock(Vector2(7, 3), PlatformBlock),\nBlock(Vector2(8, 0), GroundBlock),\nBlock(Vector2(8, 3), PlatformBlock),\nBlock(Vector2(9, 0), GroundBlock),\n];\n\nfinal segment1 = [\nBlock(Vector2(0, 0), GroundBlock),\nBlock(Vector2(1, 0), GroundBlock),\nBlock(Vector2(1, 1), PlatformBlock),\nBlock(Vector2(1, 2), PlatformBlock),\nBlock(Vector2(1, 3), PlatformBlock),\nBlock(Vector2(2, 6), PlatformBlock),\nBlock(Vector2(3, 6), PlatformBlock),\nBlock(Vector2(6, 5), PlatformBlock),\nBlock(Vector2(7, 5), PlatformBlock),\nBlock(Vector2(7, 7), Star),\nBlock(Vector2(8, 0), GroundBlock),\nBlock(Vector2(8, 1), PlatformBlock),\nBlock(Vector2(8, 5), PlatformBlock),\nBlock(Vector2(8, 6), WaterEnemy),\nBlock(Vector2(9, 0), GroundBlock),\n];\n\nfinal segment2 = [\nBlock(Vector2(0, 0), GroundBlock),\nBlock(Vector2(1, 0), GroundBlock),\nBlock(Vector2(2, 0), GroundBlock),\nBlock(Vector2(3, 0), GroundBlock),\nBlock(Vector2(3, 3), PlatformBlock),\nBlock(Vector2(4, 0), GroundBlock),\nBlock(Vector2(4, 3), PlatformBlock),\nBlock(Vector2(5, 0), GroundBlock),\nBlock(Vector2(5, 3), PlatformBlock),\nBlock(Vector2(5, 4), WaterEnemy),\nBlock(Vector2(6, 0), GroundBlock),\nBlock(Vector2(6, 3), PlatformBlock),\nBlock(Vector2(6, 4), PlatformBlock),\nBlock(Vector2(6, 5), PlatformBlock),\nBlock(Vector2(6, 7), Star),\nBlock(Vector2(7, 0), GroundBlock),\nBlock(Vector2(8, 0), GroundBlock),\nBlock(Vector2(9, 0), GroundBlock),\n];\n\nfinal segment3 = [\nBlock(Vector2(0, 0), GroundBlock),\nBlock(Vector2(1, 0), GroundBlock),\nBlock(Vector2(1, 1), WaterEnemy),\nBlock(Vector2(2, 0), GroundBlock),\nBlock(Vector2(2, 1), PlatformBlock),\nBlock(Vector2(2, 2), PlatformBlock),\nBlock(Vector2(4, 4), PlatformBlock),\nBlock(Vector2(6, 6), PlatformBlock),\nBlock(Vector2(7, 0), GroundBlock),\nBlock(Vector2(7, 1), PlatformBlock),\nBlock(Vector2(8, 0), GroundBlock),\nBlock(Vector2(8, 8), Star),\nBlock(Vector2(9, 0), GroundBlock),\n];\n\nfinal segment4 = [\nBlock(Vector2(0, 0), GroundBlock),\nBlock(Vector2(1, 0), GroundBlock),\nBlock(Vector2(2, 0), GroundBlock),\nBlock(Vector2(2, 3), PlatformBlock),\nBlock(Vector2(3, 0), GroundBlock),\nBlock(Vector2(3, 1), WaterEnemy),\nBlock(Vector2(3, 3), PlatformBlock),\nBlock(Vector2(4, 0), GroundBlock),\nBlock(Vector2(5, 0), GroundBlock),\nBlock(Vector2(5, 5), PlatformBlock),\nBlock(Vector2(6, 0), GroundBlock),\nBlock(Vector2(6, 5), PlatformBlock),\nBlock(Vector2(6, 7), Star),\nBlock(Vector2(7, 0), GroundBlock),\nBlock(Vector2(8, 0), GroundBlock),\nBlock(Vector2(8, 3), PlatformBlock),\nBlock(Vector2(9, 0), GroundBlock),\nBlock(Vector2(9, 1), WaterEnemy),\nBlock(Vector2(9, 3), PlatformBlock),\n];"}
{"prompt": "Show me how to implement Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live. using Flutter Flame", "completion": "import 'package:flame/components.dart';\n\nimport '../actors/water_enemy.dart';\nimport '../objects/ground_block.dart';\nimport '../objects/platform_block.dart';\nimport '../objects/star.dart';\n\nclass Block {\n// gridPosition position is always segment based X,Y.\n// 0,0 is the bottom left corner.\n// 10,10 is the upper right corner.\nfinal Vector2 gridPosition;\nfinal Type blockType;\nBlock(this.gridPosition, this.blockType);\n}\n\nfinal segments = [\nsegment0,\nsegment1,\nsegment2,\nsegment3,\nsegment4,\n];\n\nfinal segment0 = [\nBlock(Vector2(0, 0), GroundBlock),\nBlock(Vector2(1, 0), GroundBlock),\nBlock(Vector2(2, 0), GroundBlock),\nBlock(Vector2(3, 0), GroundBlock),\nBlock(Vector2(4, 0), GroundBlock),\nBlock(Vector2(5, 0), GroundBlock),\nBlock(Vector2(5, 1), WaterEnemy),\nBlock(Vector2(5, 3), PlatformBlock),\nBlock(Vector2(6, 0), GroundBlock),\nBlock(Vector2(6, 3), PlatformBlock),\nBlock(Vector2(7, 0), GroundBlock),\nBlock(Vector2(7, 3), PlatformBlock),\nBlock(Vector2(8, 0), GroundBlock),\nBlock(Vector2(8, 3), PlatformBlock),\nBlock(Vector2(9, 0), GroundBlock),\n];\n\nfinal segment1 = [\nBlock(Vector2(0, 0), GroundBlock),\nBlock(Vector2(1, 0), GroundBlock),\nBlock(Vector2(1, 1), PlatformBlock),\nBlock(Vector2(1, 2), PlatformBlock),\nBlock(Vector2(1, 3), PlatformBlock),\nBlock(Vector2(2, 6), PlatformBlock),\nBlock(Vector2(3, 6), PlatformBlock),\nBlock(Vector2(6, 5), PlatformBlock),\nBlock(Vector2(7, 5), PlatformBlock),\nBlock(Vector2(7, 7), Star),\nBlock(Vector2(8, 0), GroundBlock),\nBlock(Vector2(8, 1), PlatformBlock),\nBlock(Vector2(8, 5), PlatformBlock),\nBlock(Vector2(8, 6), WaterEnemy),\nBlock(Vector2(9, 0), GroundBlock),\n];\n\nfinal segment2 = [\nBlock(Vector2(0, 0), GroundBlock),\nBlock(Vector2(1, 0), GroundBlock),\nBlock(Vector2(2, 0), GroundBlock),\nBlock(Vector2(3, 0), GroundBlock),\nBlock(Vector2(3, 3), PlatformBlock),\nBlock(Vector2(4, 0), GroundBlock),\nBlock(Vector2(4, 3), PlatformBlock),\nBlock(Vector2(5, 0), GroundBlock),\nBlock(Vector2(5, 3), PlatformBlock),\nBlock(Vector2(5, 4), WaterEnemy),\nBlock(Vector2(6, 0), GroundBlock),\nBlock(Vector2(6, 3), PlatformBlock),\nBlock(Vector2(6, 4), PlatformBlock),\nBlock(Vector2(6, 5), PlatformBlock),\nBlock(Vector2(6, 7), Star),\nBlock(Vector2(7, 0), GroundBlock),\nBlock(Vector2(8, 0), GroundBlock),\nBlock(Vector2(9, 0), GroundBlock),\n];\n\nfinal segment3 = [\nBlock(Vector2(0, 0), GroundBlock),\nBlock(Vector2(1, 0), GroundBlock),\nBlock(Vector2(1, 1), WaterEnemy),\nBlock(Vector2(2, 0), GroundBlock),\nBlock(Vector2(2, 1), PlatformBlock),\nBlock(Vector2(2, 2), PlatformBlock),\nBlock(Vector2(4, 4), PlatformBlock),\nBlock(Vector2(6, 6), PlatformBlock),\nBlock(Vector2(7, 0), GroundBlock),\nBlock(Vector2(7, 1), PlatformBlock),\nBlock(Vector2(8, 0), GroundBlock),\nBlock(Vector2(8, 8), Star),\nBlock(Vector2(9, 0), GroundBlock),\n];\n\nfinal segment4 = [\nBlock(Vector2(0, 0), GroundBlock),\nBlock(Vector2(1, 0), GroundBlock),\nBlock(Vector2(2, 0), GroundBlock),\nBlock(Vector2(2, 3), PlatformBlock),\nBlock(Vector2(3, 0), GroundBlock),\nBlock(Vector2(3, 1), WaterEnemy),\nBlock(Vector2(3, 3), PlatformBlock),\nBlock(Vector2(4, 0), GroundBlock),\nBlock(Vector2(5, 0), GroundBlock),\nBlock(Vector2(5, 5), PlatformBlock),\nBlock(Vector2(6, 0), GroundBlock),\nBlock(Vector2(6, 5), PlatformBlock),\nBlock(Vector2(6, 7), Star),\nBlock(Vector2(7, 0), GroundBlock),\nBlock(Vector2(8, 0), GroundBlock),\nBlock(Vector2(8, 3), PlatformBlock),\nBlock(Vector2(9, 0), GroundBlock),\nBlock(Vector2(9, 1), WaterEnemy),\nBlock(Vector2(9, 3), PlatformBlock),\n];"}
{"prompt": "Write Flutter Flame code to Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live.", "completion": "import 'package:flame/components.dart';\n\nimport '../actors/water_enemy.dart';\nimport '../objects/ground_block.dart';\nimport '../objects/platform_block.dart';\nimport '../objects/star.dart';\n\nclass Block {\n// gridPosition position is always segment based X,Y.\n// 0,0 is the bottom left corner.\n// 10,10 is the upper right corner.\nfinal Vector2 gridPosition;\nfinal Type blockType;\nBlock(this.gridPosition, this.blockType);\n}\n\nfinal segments = [\nsegment0,\nsegment1,\nsegment2,\nsegment3,\nsegment4,\n];\n\nfinal segment0 = [\nBlock(Vector2(0, 0), GroundBlock),\nBlock(Vector2(1, 0), GroundBlock),\nBlock(Vector2(2, 0), GroundBlock),\nBlock(Vector2(3, 0), GroundBlock),\nBlock(Vector2(4, 0), GroundBlock),\nBlock(Vector2(5, 0), GroundBlock),\nBlock(Vector2(5, 1), WaterEnemy),\nBlock(Vector2(5, 3), PlatformBlock),\nBlock(Vector2(6, 0), GroundBlock),\nBlock(Vector2(6, 3), PlatformBlock),\nBlock(Vector2(7, 0), GroundBlock),\nBlock(Vector2(7, 3), PlatformBlock),\nBlock(Vector2(8, 0), GroundBlock),\nBlock(Vector2(8, 3), PlatformBlock),\nBlock(Vector2(9, 0), GroundBlock),\n];\n\nfinal segment1 = [\nBlock(Vector2(0, 0), GroundBlock),\nBlock(Vector2(1, 0), GroundBlock),\nBlock(Vector2(1, 1), PlatformBlock),\nBlock(Vector2(1, 2), PlatformBlock),\nBlock(Vector2(1, 3), PlatformBlock),\nBlock(Vector2(2, 6), PlatformBlock),\nBlock(Vector2(3, 6), PlatformBlock),\nBlock(Vector2(6, 5), PlatformBlock),\nBlock(Vector2(7, 5), PlatformBlock),\nBlock(Vector2(7, 7), Star),\nBlock(Vector2(8, 0), GroundBlock),\nBlock(Vector2(8, 1), PlatformBlock),\nBlock(Vector2(8, 5), PlatformBlock),\nBlock(Vector2(8, 6), WaterEnemy),\nBlock(Vector2(9, 0), GroundBlock),\n];\n\nfinal segment2 = [\nBlock(Vector2(0, 0), GroundBlock),\nBlock(Vector2(1, 0), GroundBlock),\nBlock(Vector2(2, 0), GroundBlock),\nBlock(Vector2(3, 0), GroundBlock),\nBlock(Vector2(3, 3), PlatformBlock),\nBlock(Vector2(4, 0), GroundBlock),\nBlock(Vector2(4, 3), PlatformBlock),\nBlock(Vector2(5, 0), GroundBlock),\nBlock(Vector2(5, 3), PlatformBlock),\nBlock(Vector2(5, 4), WaterEnemy),\nBlock(Vector2(6, 0), GroundBlock),\nBlock(Vector2(6, 3), PlatformBlock),\nBlock(Vector2(6, 4), PlatformBlock),\nBlock(Vector2(6, 5), PlatformBlock),\nBlock(Vector2(6, 7), Star),\nBlock(Vector2(7, 0), GroundBlock),\nBlock(Vector2(8, 0), GroundBlock),\nBlock(Vector2(9, 0), GroundBlock),\n];\n\nfinal segment3 = [\nBlock(Vector2(0, 0), GroundBlock),\nBlock(Vector2(1, 0), GroundBlock),\nBlock(Vector2(1, 1), WaterEnemy),\nBlock(Vector2(2, 0), GroundBlock),\nBlock(Vector2(2, 1), PlatformBlock),\nBlock(Vector2(2, 2), PlatformBlock),\nBlock(Vector2(4, 4), PlatformBlock),\nBlock(Vector2(6, 6), PlatformBlock),\nBlock(Vector2(7, 0), GroundBlock),\nBlock(Vector2(7, 1), PlatformBlock),\nBlock(Vector2(8, 0), GroundBlock),\nBlock(Vector2(8, 8), Star),\nBlock(Vector2(9, 0), GroundBlock),\n];\n\nfinal segment4 = [\nBlock(Vector2(0, 0), GroundBlock),\nBlock(Vector2(1, 0), GroundBlock),\nBlock(Vector2(2, 0), GroundBlock),\nBlock(Vector2(2, 3), PlatformBlock),\nBlock(Vector2(3, 0), GroundBlock),\nBlock(Vector2(3, 1), WaterEnemy),\nBlock(Vector2(3, 3), PlatformBlock),\nBlock(Vector2(4, 0), GroundBlock),\nBlock(Vector2(5, 0), GroundBlock),\nBlock(Vector2(5, 5), PlatformBlock),\nBlock(Vector2(6, 0), GroundBlock),\nBlock(Vector2(6, 5), PlatformBlock),\nBlock(Vector2(6, 7), Star),\nBlock(Vector2(7, 0), GroundBlock),\nBlock(Vector2(8, 0), GroundBlock),\nBlock(Vector2(8, 3), PlatformBlock),\nBlock(Vector2(9, 0), GroundBlock),\nBlock(Vector2(9, 1), WaterEnemy),\nBlock(Vector2(9, 3), PlatformBlock),\n];"}
{"prompt": "Create a Flutter Flame game component that Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live.", "completion": "import 'dart:math';\n\nimport 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\nimport '../managers/segment_manager.dart';\n\nclass GroundBlock extends SpriteComponent\nwith HasGameReference<EmberQuestGame> {\nfinal Vector2 gridPosition;\ndouble xOffset;\n\nfinal UniqueKey _blockKey = UniqueKey();\nfinal Vector2 velocity = Vector2.zero();\n\nGroundBlock({\nrequired this.gridPosition,\nrequired this.xOffset,\n}) : super(size: Vector2.all(64), anchor: Anchor.bottomLeft);\n\n@override\nFuture<void> onLoad() async {\nfinal groundImage = game.images.fromCache('ground.png');\nsprite = Sprite(groundImage);\nposition = Vector2(\n(gridPosition.x * size.x) + xOffset,\ngame.size.y - (gridPosition.y * size.y),\n);\nadd(RectangleHitbox(collisionType: CollisionType.passive));\nif (gridPosition.x == 9 && position.x > game.lastBlockXPosition) {\ngame.lastBlockKey = _blockKey;\ngame.lastBlockXPosition = position.x + size.x;\n}\n}\n\n@override\nvoid update(double dt) {\nvelocity.x = game.objectSpeed;\nposition += velocity * dt;\n\nif (position.x < -size.x) {\nremoveFromParent();\nif (gridPosition.x == 0) {\ngame.loadGameSegments(\nRandom().nextInt(segments.length),\ngame.lastBlockXPosition,\n);\n}\n}\nif (gridPosition.x == 9) {\nif (game.lastBlockKey == _blockKey) {\ngame.lastBlockXPosition = position.x + size.x - 10;\n}\n}\nif (game.health <= 0) {\nremoveFromParent();\n}\n\nsuper.update(dt);\n}\n}"}
{"prompt": "Show me how to implement Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live. using Flutter Flame", "completion": "import 'dart:math';\n\nimport 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\nimport '../managers/segment_manager.dart';\n\nclass GroundBlock extends SpriteComponent\nwith HasGameReference<EmberQuestGame> {\nfinal Vector2 gridPosition;\ndouble xOffset;\n\nfinal UniqueKey _blockKey = UniqueKey();\nfinal Vector2 velocity = Vector2.zero();\n\nGroundBlock({\nrequired this.gridPosition,\nrequired this.xOffset,\n}) : super(size: Vector2.all(64), anchor: Anchor.bottomLeft);\n\n@override\nFuture<void> onLoad() async {\nfinal groundImage = game.images.fromCache('ground.png');\nsprite = Sprite(groundImage);\nposition = Vector2(\n(gridPosition.x * size.x) + xOffset,\ngame.size.y - (gridPosition.y * size.y),\n);\nadd(RectangleHitbox(collisionType: CollisionType.passive));\nif (gridPosition.x == 9 && position.x > game.lastBlockXPosition) {\ngame.lastBlockKey = _blockKey;\ngame.lastBlockXPosition = position.x + size.x;\n}\n}\n\n@override\nvoid update(double dt) {\nvelocity.x = game.objectSpeed;\nposition += velocity * dt;\n\nif (position.x < -size.x) {\nremoveFromParent();\nif (gridPosition.x == 0) {\ngame.loadGameSegments(\nRandom().nextInt(segments.length),\ngame.lastBlockXPosition,\n);\n}\n}\nif (gridPosition.x == 9) {\nif (game.lastBlockKey == _blockKey) {\ngame.lastBlockXPosition = position.x + size.x - 10;\n}\n}\nif (game.health <= 0) {\nremoveFromParent();\n}\n\nsuper.update(dt);\n}\n}"}
{"prompt": "Write Flutter Flame code to Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live.", "completion": "import 'dart:math';\n\nimport 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\nimport '../managers/segment_manager.dart';\n\nclass GroundBlock extends SpriteComponent\nwith HasGameReference<EmberQuestGame> {\nfinal Vector2 gridPosition;\ndouble xOffset;\n\nfinal UniqueKey _blockKey = UniqueKey();\nfinal Vector2 velocity = Vector2.zero();\n\nGroundBlock({\nrequired this.gridPosition,\nrequired this.xOffset,\n}) : super(size: Vector2.all(64), anchor: Anchor.bottomLeft);\n\n@override\nFuture<void> onLoad() async {\nfinal groundImage = game.images.fromCache('ground.png');\nsprite = Sprite(groundImage);\nposition = Vector2(\n(gridPosition.x * size.x) + xOffset,\ngame.size.y - (gridPosition.y * size.y),\n);\nadd(RectangleHitbox(collisionType: CollisionType.passive));\nif (gridPosition.x == 9 && position.x > game.lastBlockXPosition) {\ngame.lastBlockKey = _blockKey;\ngame.lastBlockXPosition = position.x + size.x;\n}\n}\n\n@override\nvoid update(double dt) {\nvelocity.x = game.objectSpeed;\nposition += velocity * dt;\n\nif (position.x < -size.x) {\nremoveFromParent();\nif (gridPosition.x == 0) {\ngame.loadGameSegments(\nRandom().nextInt(segments.length),\ngame.lastBlockXPosition,\n);\n}\n}\nif (gridPosition.x == 9) {\nif (game.lastBlockKey == _blockKey) {\ngame.lastBlockXPosition = position.x + size.x - 10;\n}\n}\nif (game.health <= 0) {\nremoveFromParent();\n}\n\nsuper.update(dt);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live.", "completion": "import 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\n\nimport '../ember_quest.dart';\n\nclass PlatformBlock extends SpriteComponent\nwith HasGameReference<EmberQuestGame> {\nfinal Vector2 gridPosition;\ndouble xOffset;\n\nfinal Vector2 velocity = Vector2.zero();\n\nPlatformBlock({\nrequired this.gridPosition,\nrequired this.xOffset,\n}) : super(size: Vector2.all(64), anchor: Anchor.bottomLeft);\n\n@override\nFuture<void> onLoad() async {\nfinal platformImage = game.images.fromCache('block.png');\nsprite = Sprite(platformImage);\nposition = Vector2(\n(gridPosition.x * size.x) + xOffset,\ngame.size.y - (gridPosition.y * size.y),\n);\nadd(RectangleHitbox(collisionType: CollisionType.passive));\n}\n\n@override\nvoid update(double dt) {\nvelocity.x = game.objectSpeed;\nposition += velocity * dt;\nif (position.x < -size.x || game.health <= 0) {\nremoveFromParent();\n}\nsuper.update(dt);\n}\n}"}
{"prompt": "Show me how to implement Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live. using Flutter Flame", "completion": "import 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\n\nimport '../ember_quest.dart';\n\nclass PlatformBlock extends SpriteComponent\nwith HasGameReference<EmberQuestGame> {\nfinal Vector2 gridPosition;\ndouble xOffset;\n\nfinal Vector2 velocity = Vector2.zero();\n\nPlatformBlock({\nrequired this.gridPosition,\nrequired this.xOffset,\n}) : super(size: Vector2.all(64), anchor: Anchor.bottomLeft);\n\n@override\nFuture<void> onLoad() async {\nfinal platformImage = game.images.fromCache('block.png');\nsprite = Sprite(platformImage);\nposition = Vector2(\n(gridPosition.x * size.x) + xOffset,\ngame.size.y - (gridPosition.y * size.y),\n);\nadd(RectangleHitbox(collisionType: CollisionType.passive));\n}\n\n@override\nvoid update(double dt) {\nvelocity.x = game.objectSpeed;\nposition += velocity * dt;\nif (position.x < -size.x || game.health <= 0) {\nremoveFromParent();\n}\nsuper.update(dt);\n}\n}"}
{"prompt": "Write Flutter Flame code to Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live.", "completion": "import 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\n\nimport '../ember_quest.dart';\n\nclass PlatformBlock extends SpriteComponent\nwith HasGameReference<EmberQuestGame> {\nfinal Vector2 gridPosition;\ndouble xOffset;\n\nfinal Vector2 velocity = Vector2.zero();\n\nPlatformBlock({\nrequired this.gridPosition,\nrequired this.xOffset,\n}) : super(size: Vector2.all(64), anchor: Anchor.bottomLeft);\n\n@override\nFuture<void> onLoad() async {\nfinal platformImage = game.images.fromCache('block.png');\nsprite = Sprite(platformImage);\nposition = Vector2(\n(gridPosition.x * size.x) + xOffset,\ngame.size.y - (gridPosition.y * size.y),\n);\nadd(RectangleHitbox(collisionType: CollisionType.passive));\n}\n\n@override\nvoid update(double dt) {\nvelocity.x = game.objectSpeed;\nposition += velocity * dt;\nif (position.x < -size.x || game.health <= 0) {\nremoveFromParent();\n}\nsuper.update(dt);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live.", "completion": "import 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\n\nclass Star extends SpriteComponent with HasGameReference<EmberQuestGame> {\nfinal Vector2 gridPosition;\ndouble xOffset;\n\nfinal Vector2 velocity = Vector2.zero();\n\nStar({\nrequired this.gridPosition,\nrequired this.xOffset,\n}) : super(size: Vector2.all(64), anchor: Anchor.center);\n\n@override\nFuture<void> onLoad() async {\nfinal starImage = game.images.fromCache('star.png');\nsprite = Sprite(starImage);\nposition = Vector2(\n(gridPosition.x * size.x) + xOffset + (size.x / 2),\ngame.size.y - (gridPosition.y * size.y) - (size.y / 2),\n);\nadd(RectangleHitbox(collisionType: CollisionType.passive));\nadd(\nSizeEffect.by(\nVector2.all(-24),\nEffectController(\nduration: 0.75,\nreverseDuration: 0.5,\ninfinite: true,\ncurve: Curves.easeOut,\n),\n),\n);\n}\n\n@override\nvoid update(double dt) {\nvelocity.x = game.objectSpeed;\nposition += velocity * dt;\nif (position.x < -size.x || game.health <= 0) {\nremoveFromParent();\n}\nsuper.update(dt);\n}\n}"}
{"prompt": "Show me how to implement Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live. using Flutter Flame", "completion": "import 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\n\nclass Star extends SpriteComponent with HasGameReference<EmberQuestGame> {\nfinal Vector2 gridPosition;\ndouble xOffset;\n\nfinal Vector2 velocity = Vector2.zero();\n\nStar({\nrequired this.gridPosition,\nrequired this.xOffset,\n}) : super(size: Vector2.all(64), anchor: Anchor.center);\n\n@override\nFuture<void> onLoad() async {\nfinal starImage = game.images.fromCache('star.png');\nsprite = Sprite(starImage);\nposition = Vector2(\n(gridPosition.x * size.x) + xOffset + (size.x / 2),\ngame.size.y - (gridPosition.y * size.y) - (size.y / 2),\n);\nadd(RectangleHitbox(collisionType: CollisionType.passive));\nadd(\nSizeEffect.by(\nVector2.all(-24),\nEffectController(\nduration: 0.75,\nreverseDuration: 0.5,\ninfinite: true,\ncurve: Curves.easeOut,\n),\n),\n);\n}\n\n@override\nvoid update(double dt) {\nvelocity.x = game.objectSpeed;\nposition += velocity * dt;\nif (position.x < -size.x || game.health <= 0) {\nremoveFromParent();\n}\nsuper.update(dt);\n}\n}"}
{"prompt": "Write Flutter Flame code to Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live.", "completion": "import 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\n\nclass Star extends SpriteComponent with HasGameReference<EmberQuestGame> {\nfinal Vector2 gridPosition;\ndouble xOffset;\n\nfinal Vector2 velocity = Vector2.zero();\n\nStar({\nrequired this.gridPosition,\nrequired this.xOffset,\n}) : super(size: Vector2.all(64), anchor: Anchor.center);\n\n@override\nFuture<void> onLoad() async {\nfinal starImage = game.images.fromCache('star.png');\nsprite = Sprite(starImage);\nposition = Vector2(\n(gridPosition.x * size.x) + xOffset + (size.x / 2),\ngame.size.y - (gridPosition.y * size.y) - (size.y / 2),\n);\nadd(RectangleHitbox(collisionType: CollisionType.passive));\nadd(\nSizeEffect.by(\nVector2.all(-24),\nEffectController(\nduration: 0.75,\nreverseDuration: 0.5,\ninfinite: true,\ncurve: Curves.easeOut,\n),\n),\n);\n}\n\n@override\nvoid update(double dt) {\nvelocity.x = game.objectSpeed;\nposition += velocity * dt;\nif (position.x < -size.x || game.health <= 0) {\nremoveFromParent();\n}\nsuper.update(dt);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live.", "completion": "import 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\n\nclass GameOver extends StatelessWidget {\n// Reference to parent game.\nfinal EmberQuestGame game;\nconst GameOver({required this.game, super.key});\n\n@override\nWidget build(BuildContext context) {\nconst blackTextColor = Color.fromRGBO(0, 0, 0, 1.0);\nconst whiteTextColor = Color.fromRGBO(255, 255, 255, 1.0);\n\nreturn Material(\ncolor: Colors.transparent,\nchild: Center(\nchild: Container(\npadding: const EdgeInsets.all(10.0),\nheight: 200,\nwidth: 300,\ndecoration: const BoxDecoration(\ncolor: blackTextColor,\nborderRadius: BorderRadius.all(\nRadius.circular(20),\n),\n),\nchild: Column(\nmainAxisAlignment: MainAxisAlignment.center,\nchildren: [\nconst Text(\n'Game Over',\nstyle: TextStyle(\ncolor: whiteTextColor,\nfontSize: 24,\n),\n),\nconst SizedBox(height: 40),\nSizedBox(\nwidth: 200,\nheight: 75,\nchild: ElevatedButton(\nonPressed: () {\ngame.reset();\ngame.overlays.remove('GameOver');\n},\nstyle: ElevatedButton.styleFrom(\nbackgroundColor: whiteTextColor,\n),\nchild: const Text(\n'Play Again',\nstyle: TextStyle(\nfontSize: 28.0,\ncolor: blackTextColor,\n),\n),\n),\n),\n],\n),\n),\n),\n);\n}\n}"}
{"prompt": "Show me how to implement Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live. using Flutter Flame", "completion": "import 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\n\nclass GameOver extends StatelessWidget {\n// Reference to parent game.\nfinal EmberQuestGame game;\nconst GameOver({required this.game, super.key});\n\n@override\nWidget build(BuildContext context) {\nconst blackTextColor = Color.fromRGBO(0, 0, 0, 1.0);\nconst whiteTextColor = Color.fromRGBO(255, 255, 255, 1.0);\n\nreturn Material(\ncolor: Colors.transparent,\nchild: Center(\nchild: Container(\npadding: const EdgeInsets.all(10.0),\nheight: 200,\nwidth: 300,\ndecoration: const BoxDecoration(\ncolor: blackTextColor,\nborderRadius: BorderRadius.all(\nRadius.circular(20),\n),\n),\nchild: Column(\nmainAxisAlignment: MainAxisAlignment.center,\nchildren: [\nconst Text(\n'Game Over',\nstyle: TextStyle(\ncolor: whiteTextColor,\nfontSize: 24,\n),\n),\nconst SizedBox(height: 40),\nSizedBox(\nwidth: 200,\nheight: 75,\nchild: ElevatedButton(\nonPressed: () {\ngame.reset();\ngame.overlays.remove('GameOver');\n},\nstyle: ElevatedButton.styleFrom(\nbackgroundColor: whiteTextColor,\n),\nchild: const Text(\n'Play Again',\nstyle: TextStyle(\nfontSize: 28.0,\ncolor: blackTextColor,\n),\n),\n),\n),\n],\n),\n),\n),\n);\n}\n}"}
{"prompt": "Write Flutter Flame code to Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live.", "completion": "import 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\n\nclass GameOver extends StatelessWidget {\n// Reference to parent game.\nfinal EmberQuestGame game;\nconst GameOver({required this.game, super.key});\n\n@override\nWidget build(BuildContext context) {\nconst blackTextColor = Color.fromRGBO(0, 0, 0, 1.0);\nconst whiteTextColor = Color.fromRGBO(255, 255, 255, 1.0);\n\nreturn Material(\ncolor: Colors.transparent,\nchild: Center(\nchild: Container(\npadding: const EdgeInsets.all(10.0),\nheight: 200,\nwidth: 300,\ndecoration: const BoxDecoration(\ncolor: blackTextColor,\nborderRadius: BorderRadius.all(\nRadius.circular(20),\n),\n),\nchild: Column(\nmainAxisAlignment: MainAxisAlignment.center,\nchildren: [\nconst Text(\n'Game Over',\nstyle: TextStyle(\ncolor: whiteTextColor,\nfontSize: 24,\n),\n),\nconst SizedBox(height: 40),\nSizedBox(\nwidth: 200,\nheight: 75,\nchild: ElevatedButton(\nonPressed: () {\ngame.reset();\ngame.overlays.remove('GameOver');\n},\nstyle: ElevatedButton.styleFrom(\nbackgroundColor: whiteTextColor,\n),\nchild: const Text(\n'Play Again',\nstyle: TextStyle(\nfontSize: 28.0,\ncolor: blackTextColor,\n),\n),\n),\n),\n],\n),\n),\n),\n);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live.", "completion": "import 'package:flame/components.dart';\n\nimport '../ember_quest.dart';\n\nenum HeartState {\navailable,\nunavailable,\n}\n\nclass HeartHealthComponent extends SpriteGroupComponent<HeartState>\nwith HasGameReference<EmberQuestGame> {\nfinal int heartNumber;\n\nHeartHealthComponent({\nrequired this.heartNumber,\nrequired super.position,\nrequired super.size,\nsuper.scale,\nsuper.angle,\nsuper.anchor,\nsuper.priority,\n});\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\nfinal availableSprite = await game.loadSprite(\n'heart.png',\nsrcSize: Vector2.all(32),\n);\n\nfinal unavailableSprite = await game.loadSprite(\n'heart_half.png',\nsrcSize: Vector2.all(32),\n);\n\nsprites = {\nHeartState.available: availableSprite,\nHeartState.unavailable: unavailableSprite,\n};\n\ncurrent = HeartState.available;\n}\n\n@override\nvoid update(double dt) {\nif (game.health < heartNumber) {\ncurrent = HeartState.unavailable;\n} else {\ncurrent = HeartState.available;\n}\nsuper.update(dt);\n}\n}"}
{"prompt": "Show me how to implement Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live. using Flutter Flame", "completion": "import 'package:flame/components.dart';\n\nimport '../ember_quest.dart';\n\nenum HeartState {\navailable,\nunavailable,\n}\n\nclass HeartHealthComponent extends SpriteGroupComponent<HeartState>\nwith HasGameReference<EmberQuestGame> {\nfinal int heartNumber;\n\nHeartHealthComponent({\nrequired this.heartNumber,\nrequired super.position,\nrequired super.size,\nsuper.scale,\nsuper.angle,\nsuper.anchor,\nsuper.priority,\n});\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\nfinal availableSprite = await game.loadSprite(\n'heart.png',\nsrcSize: Vector2.all(32),\n);\n\nfinal unavailableSprite = await game.loadSprite(\n'heart_half.png',\nsrcSize: Vector2.all(32),\n);\n\nsprites = {\nHeartState.available: availableSprite,\nHeartState.unavailable: unavailableSprite,\n};\n\ncurrent = HeartState.available;\n}\n\n@override\nvoid update(double dt) {\nif (game.health < heartNumber) {\ncurrent = HeartState.unavailable;\n} else {\ncurrent = HeartState.available;\n}\nsuper.update(dt);\n}\n}"}
{"prompt": "Write Flutter Flame code to Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live.", "completion": "import 'package:flame/components.dart';\n\nimport '../ember_quest.dart';\n\nenum HeartState {\navailable,\nunavailable,\n}\n\nclass HeartHealthComponent extends SpriteGroupComponent<HeartState>\nwith HasGameReference<EmberQuestGame> {\nfinal int heartNumber;\n\nHeartHealthComponent({\nrequired this.heartNumber,\nrequired super.position,\nrequired super.size,\nsuper.scale,\nsuper.angle,\nsuper.anchor,\nsuper.priority,\n});\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\nfinal availableSprite = await game.loadSprite(\n'heart.png',\nsrcSize: Vector2.all(32),\n);\n\nfinal unavailableSprite = await game.loadSprite(\n'heart_half.png',\nsrcSize: Vector2.all(32),\n);\n\nsprites = {\nHeartState.available: availableSprite,\nHeartState.unavailable: unavailableSprite,\n};\n\ncurrent = HeartState.available;\n}\n\n@override\nvoid update(double dt) {\nif (game.health < heartNumber) {\ncurrent = HeartState.unavailable;\n} else {\ncurrent = HeartState.available;\n}\nsuper.update(dt);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live.", "completion": "import 'package:flame/components.dart';\nimport 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\nimport 'heart.dart';\n\nclass Hud extends PositionComponent with HasGameReference<EmberQuestGame> {\nHud({\nsuper.position,\nsuper.size,\nsuper.scale,\nsuper.angle,\nsuper.anchor,\nsuper.children,\nsuper.priority = 5,\n});\n\nlate TextComponent _scoreTextComponent;\n\n@override\nFuture<void>? onLoad() async {\n_scoreTextComponent = TextComponent(\ntext: '${game.starsCollected}',\ntextRenderer: TextPaint(\nstyle: const TextStyle(\nfontSize: 32,\ncolor: Color.fromRGBO(10, 10, 10, 1),\n),\n),\nanchor: Anchor.center,\nposition: Vector2(game.size.x - 60, 20),\n);\nadd(_scoreTextComponent);\n\nfinal starSprite = await game.loadSprite('star.png');\nadd(\nSpriteComponent(\nsprite: starSprite,\nposition: Vector2(game.size.x - 100, 20),\nsize: Vector2.all(32),\nanchor: Anchor.center,\n),\n);\n\nfor (var i = 1; i <= game.health; i++) {\nfinal positionX = 40 * i;\nawait add(\nHeartHealthComponent(\nheartNumber: i,\nposition: Vector2(positionX.toDouble(), 20),\nsize: Vector2.all(32),\n),\n);\n}\n\nreturn super.onLoad();\n}\n\n@override\nvoid update(double dt) {\n_scoreTextComponent.text = '${game.starsCollected}';\nsuper.update(dt);\n}\n}"}
{"prompt": "Show me how to implement Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live. using Flutter Flame", "completion": "import 'package:flame/components.dart';\nimport 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\nimport 'heart.dart';\n\nclass Hud extends PositionComponent with HasGameReference<EmberQuestGame> {\nHud({\nsuper.position,\nsuper.size,\nsuper.scale,\nsuper.angle,\nsuper.anchor,\nsuper.children,\nsuper.priority = 5,\n});\n\nlate TextComponent _scoreTextComponent;\n\n@override\nFuture<void>? onLoad() async {\n_scoreTextComponent = TextComponent(\ntext: '${game.starsCollected}',\ntextRenderer: TextPaint(\nstyle: const TextStyle(\nfontSize: 32,\ncolor: Color.fromRGBO(10, 10, 10, 1),\n),\n),\nanchor: Anchor.center,\nposition: Vector2(game.size.x - 60, 20),\n);\nadd(_scoreTextComponent);\n\nfinal starSprite = await game.loadSprite('star.png');\nadd(\nSpriteComponent(\nsprite: starSprite,\nposition: Vector2(game.size.x - 100, 20),\nsize: Vector2.all(32),\nanchor: Anchor.center,\n),\n);\n\nfor (var i = 1; i <= game.health; i++) {\nfinal positionX = 40 * i;\nawait add(\nHeartHealthComponent(\nheartNumber: i,\nposition: Vector2(positionX.toDouble(), 20),\nsize: Vector2.all(32),\n),\n);\n}\n\nreturn super.onLoad();\n}\n\n@override\nvoid update(double dt) {\n_scoreTextComponent.text = '${game.starsCollected}';\nsuper.update(dt);\n}\n}"}
{"prompt": "Write Flutter Flame code to Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live.", "completion": "import 'package:flame/components.dart';\nimport 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\nimport 'heart.dart';\n\nclass Hud extends PositionComponent with HasGameReference<EmberQuestGame> {\nHud({\nsuper.position,\nsuper.size,\nsuper.scale,\nsuper.angle,\nsuper.anchor,\nsuper.children,\nsuper.priority = 5,\n});\n\nlate TextComponent _scoreTextComponent;\n\n@override\nFuture<void>? onLoad() async {\n_scoreTextComponent = TextComponent(\ntext: '${game.starsCollected}',\ntextRenderer: TextPaint(\nstyle: const TextStyle(\nfontSize: 32,\ncolor: Color.fromRGBO(10, 10, 10, 1),\n),\n),\nanchor: Anchor.center,\nposition: Vector2(game.size.x - 60, 20),\n);\nadd(_scoreTextComponent);\n\nfinal starSprite = await game.loadSprite('star.png');\nadd(\nSpriteComponent(\nsprite: starSprite,\nposition: Vector2(game.size.x - 100, 20),\nsize: Vector2.all(32),\nanchor: Anchor.center,\n),\n);\n\nfor (var i = 1; i <= game.health; i++) {\nfinal positionX = 40 * i;\nawait add(\nHeartHealthComponent(\nheartNumber: i,\nposition: Vector2(positionX.toDouble(), 20),\nsize: Vector2.all(32),\n),\n);\n}\n\nreturn super.onLoad();\n}\n\n@override\nvoid update(double dt) {\n_scoreTextComponent.text = '${game.starsCollected}';\nsuper.update(dt);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live.", "completion": "import 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\n\nclass MainMenu extends StatelessWidget {\n// Reference to parent game.\nfinal EmberQuestGame game;\n\nconst MainMenu({required this.game, super.key});\n\n@override\nWidget build(BuildContext context) {\nconst blackTextColor = Color.fromRGBO(0, 0, 0, 1.0);\nconst whiteTextColor = Color.fromRGBO(255, 255, 255, 1.0);\n\nreturn Material(\ncolor: Colors.transparent,\nchild: Center(\nchild: Container(\npadding: const EdgeInsets.all(10.0),\nheight: 300,\nwidth: 300,\ndecoration: const BoxDecoration(\ncolor: blackTextColor,\nborderRadius: BorderRadius.all(\nRadius.circular(20),\n),\n),\nchild: Column(\nmainAxisAlignment: MainAxisAlignment.center,\nchildren: [\nconst Text(\n'Ember Quest',\nstyle: TextStyle(\ncolor: whiteTextColor,\nfontSize: 24,\n),\n),\nconst SizedBox(height: 40),\nSizedBox(\nwidth: 200,\nheight: 75,\nchild: ElevatedButton(\nonPressed: () {\ngame.overlays.remove('MainMenu');\n},\nstyle: ElevatedButton.styleFrom(\nbackgroundColor: whiteTextColor,\n),\nchild: const Text(\n'Play',\nstyle: TextStyle(\nfontSize: 40.0,\ncolor: blackTextColor,\n),\n),\n),\n),\nconst SizedBox(height: 20),\nconst Text(\n'''Use WASD or Arrow Keys for movement.\nSpace bar to jump.\nCollect as many stars as you can and avoid enemies!''',\ntextAlign: TextAlign.center,\nstyle: TextStyle(\ncolor: whiteTextColor,\nfontSize: 14,\n),\n),\n],\n),\n),\n),\n);\n}\n}"}
{"prompt": "Show me how to implement Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live. using Flutter Flame", "completion": "import 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\n\nclass MainMenu extends StatelessWidget {\n// Reference to parent game.\nfinal EmberQuestGame game;\n\nconst MainMenu({required this.game, super.key});\n\n@override\nWidget build(BuildContext context) {\nconst blackTextColor = Color.fromRGBO(0, 0, 0, 1.0);\nconst whiteTextColor = Color.fromRGBO(255, 255, 255, 1.0);\n\nreturn Material(\ncolor: Colors.transparent,\nchild: Center(\nchild: Container(\npadding: const EdgeInsets.all(10.0),\nheight: 300,\nwidth: 300,\ndecoration: const BoxDecoration(\ncolor: blackTextColor,\nborderRadius: BorderRadius.all(\nRadius.circular(20),\n),\n),\nchild: Column(\nmainAxisAlignment: MainAxisAlignment.center,\nchildren: [\nconst Text(\n'Ember Quest',\nstyle: TextStyle(\ncolor: whiteTextColor,\nfontSize: 24,\n),\n),\nconst SizedBox(height: 40),\nSizedBox(\nwidth: 200,\nheight: 75,\nchild: ElevatedButton(\nonPressed: () {\ngame.overlays.remove('MainMenu');\n},\nstyle: ElevatedButton.styleFrom(\nbackgroundColor: whiteTextColor,\n),\nchild: const Text(\n'Play',\nstyle: TextStyle(\nfontSize: 40.0,\ncolor: blackTextColor,\n),\n),\n),\n),\nconst SizedBox(height: 20),\nconst Text(\n'''Use WASD or Arrow Keys for movement.\nSpace bar to jump.\nCollect as many stars as you can and avoid enemies!''',\ntextAlign: TextAlign.center,\nstyle: TextStyle(\ncolor: whiteTextColor,\nfontSize: 14,\n),\n),\n],\n),\n),\n),\n);\n}\n}"}
{"prompt": "Write Flutter Flame code to Congratulations¶: You made it! You have a working Ember Quest. Press the button below to see what the resulting code looks like or to play it live.", "completion": "import 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\n\nclass MainMenu extends StatelessWidget {\n// Reference to parent game.\nfinal EmberQuestGame game;\n\nconst MainMenu({required this.game, super.key});\n\n@override\nWidget build(BuildContext context) {\nconst blackTextColor = Color.fromRGBO(0, 0, 0, 1.0);\nconst whiteTextColor = Color.fromRGBO(255, 255, 255, 1.0);\n\nreturn Material(\ncolor: Colors.transparent,\nchild: Center(\nchild: Container(\npadding: const EdgeInsets.all(10.0),\nheight: 300,\nwidth: 300,\ndecoration: const BoxDecoration(\ncolor: blackTextColor,\nborderRadius: BorderRadius.all(\nRadius.circular(20),\n),\n),\nchild: Column(\nmainAxisAlignment: MainAxisAlignment.center,\nchildren: [\nconst Text(\n'Ember Quest',\nstyle: TextStyle(\ncolor: whiteTextColor,\nfontSize: 24,\n),\n),\nconst SizedBox(height: 40),\nSizedBox(\nwidth: 200,\nheight: 75,\nchild: ElevatedButton(\nonPressed: () {\ngame.overlays.remove('MainMenu');\n},\nstyle: ElevatedButton.styleFrom(\nbackgroundColor: whiteTextColor,\n),\nchild: const Text(\n'Play',\nstyle: TextStyle(\nfontSize: 40.0,\ncolor: blackTextColor,\n),\n),\n),\n),\nconst SizedBox(height: 20),\nconst Text(\n'''Use WASD or Arrow Keys for movement.\nSpace bar to jump.\nCollect as many stars as you can and avoid enemies!''',\ntextAlign: TextAlign.center,\nstyle: TextStyle(\ncolor: whiteTextColor,\nfontSize: 14,\n),\n),\n],\n),\n),\n),\n);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that Particles¶: The most basic usage of a Particle with FlameGame would look as in the following:", "completion": "import 'package:flame/components.dart';\n\n// ...\n\ngame.add(\n  // Wrapping a Particle with ParticleSystemComponent\n  // which maps Component lifecycle hooks to Particle ones\n  // and embeds a trigger for removing the component.\n  ParticleSystemComponent(\n    particle: CircleParticle(),\n  ),\n);"}
{"prompt": "Show me how to implement Particles¶: The most basic usage of a Particle with FlameGame would look as in the following: using Flutter Flame", "completion": "import 'package:flame/components.dart';\n\n// ...\n\ngame.add(\n  // Wrapping a Particle with ParticleSystemComponent\n  // which maps Component lifecycle hooks to Particle ones\n  // and embeds a trigger for removing the component.\n  ParticleSystemComponent(\n    particle: CircleParticle(),\n  ),\n);"}
{"prompt": "Write Flutter Flame code to Particles¶: The most basic usage of a Particle with FlameGame would look as in the following:", "completion": "import 'package:flame/components.dart';\n\n// ...\n\ngame.add(\n  // Wrapping a Particle with ParticleSystemComponent\n  // which maps Component lifecycle hooks to Particle ones\n  // and embeds a trigger for removing the component.\n  ParticleSystemComponent(\n    particle: CircleParticle(),\n  ),\n);"}
{"prompt": "Create a Flutter Flame game component that Particles¶: Composition works in a similar fashion to those of Flutter widgets by defining the effect from top to bottom. Chaining allows to express the same composition trees more fluently by defining behaviors from bottom to top. Computed particles in their turn fully delegate implementation of the behavior to your code. Any of the approaches could be used in conjunction with existing behaviors where needed.", "completion": "Random rnd = Random();\n\nVector2 randomVector2() => (Vector2.random(rnd) - Vector2.random(rnd)) * 200;\n\n// Composition.\n//\n// Defining a particle effect as a set of nested behaviors from top to bottom,\n// one within another:\n//\n// ParticleSystemComponent\n//   > ComposedParticle\n//     > AcceleratedParticle\n//       > CircleParticle\ngame.add(\n  ParticleSystemComponent(\n    particle: Particle.generate(\n      count: 10,\n      generator: (i) => AcceleratedParticle(\n        acceleration: randomVector2(),\n        child: CircleParticle(\n          paint: Paint()..color = Colors.red,\n        ),\n      ),\n    ),\n  ),\n);\n\n// Chaining.\n//\n// Expresses the same behavior as above, but with a more fluent API.\n// Only Particles with SingleChildParticle mixin can be used as chainable behaviors.\ngame.add(\n  ParticleSystemComponent(\n    particle: Particle.generate(\n      count: 10,\n      generator: (i) => pt.CircleParticle(paint: Paint()..color = Colors.red)\n    )\n  )\n);\n\n// Computed Particle.\n//\n// All the behaviors are defined explicitly. Offers greater flexibility\n// compared to built-in behaviors.\ngame.add(\n  ParticleSystemComponent(\n      particle: Particle.generate(\n        count: 10,\n        generator: (i) {\n          Vector2 position = Vector2.zero();\n          Vector2 speed = Vector2.zero();\n          final acceleration = randomVector2();\n          final paint = Paint()..color = Colors.red;\n\n          return ComputedParticle(\n            renderer: (canvas, _) {\n              speed += acceleration;\n              position += speed;\n              canvas.drawCircle(Offset(position.x, position.y), 1, paint);\n            }\n        );\n      }\n    )\n  )\n);"}
{"prompt": "Show me how to implement Particles¶: Composition works in a similar fashion to those of Flutter widgets by defining the effect from top to bottom. Chaining allows to express the same composition trees more fluently by defining behaviors from bottom to top. Computed particles in their turn fully delegate implementation of the behavior to your code. Any of the approaches could be used in conjunction with existing behaviors where needed. using Flutter Flame", "completion": "Random rnd = Random();\n\nVector2 randomVector2() => (Vector2.random(rnd) - Vector2.random(rnd)) * 200;\n\n// Composition.\n//\n// Defining a particle effect as a set of nested behaviors from top to bottom,\n// one within another:\n//\n// ParticleSystemComponent\n//   > ComposedParticle\n//     > AcceleratedParticle\n//       > CircleParticle\ngame.add(\n  ParticleSystemComponent(\n    particle: Particle.generate(\n      count: 10,\n      generator: (i) => AcceleratedParticle(\n        acceleration: randomVector2(),\n        child: CircleParticle(\n          paint: Paint()..color = Colors.red,\n        ),\n      ),\n    ),\n  ),\n);\n\n// Chaining.\n//\n// Expresses the same behavior as above, but with a more fluent API.\n// Only Particles with SingleChildParticle mixin can be used as chainable behaviors.\ngame.add(\n  ParticleSystemComponent(\n    particle: Particle.generate(\n      count: 10,\n      generator: (i) => pt.CircleParticle(paint: Paint()..color = Colors.red)\n    )\n  )\n);\n\n// Computed Particle.\n//\n// All the behaviors are defined explicitly. Offers greater flexibility\n// compared to built-in behaviors.\ngame.add(\n  ParticleSystemComponent(\n      particle: Particle.generate(\n        count: 10,\n        generator: (i) {\n          Vector2 position = Vector2.zero();\n          Vector2 speed = Vector2.zero();\n          final acceleration = randomVector2();\n          final paint = Paint()..color = Colors.red;\n\n          return ComputedParticle(\n            renderer: (canvas, _) {\n              speed += acceleration;\n              position += speed;\n              canvas.drawCircle(Offset(position.x, position.y), 1, paint);\n            }\n        );\n      }\n    )\n  )\n);"}
{"prompt": "Write Flutter Flame code to Particles¶: Composition works in a similar fashion to those of Flutter widgets by defining the effect from top to bottom. Chaining allows to express the same composition trees more fluently by defining behaviors from bottom to top. Computed particles in their turn fully delegate implementation of the behavior to your code. Any of the approaches could be used in conjunction with existing behaviors where needed.", "completion": "Random rnd = Random();\n\nVector2 randomVector2() => (Vector2.random(rnd) - Vector2.random(rnd)) * 200;\n\n// Composition.\n//\n// Defining a particle effect as a set of nested behaviors from top to bottom,\n// one within another:\n//\n// ParticleSystemComponent\n//   > ComposedParticle\n//     > AcceleratedParticle\n//       > CircleParticle\ngame.add(\n  ParticleSystemComponent(\n    particle: Particle.generate(\n      count: 10,\n      generator: (i) => AcceleratedParticle(\n        acceleration: randomVector2(),\n        child: CircleParticle(\n          paint: Paint()..color = Colors.red,\n        ),\n      ),\n    ),\n  ),\n);\n\n// Chaining.\n//\n// Expresses the same behavior as above, but with a more fluent API.\n// Only Particles with SingleChildParticle mixin can be used as chainable behaviors.\ngame.add(\n  ParticleSystemComponent(\n    particle: Particle.generate(\n      count: 10,\n      generator: (i) => pt.CircleParticle(paint: Paint()..color = Colors.red)\n    )\n  )\n);\n\n// Computed Particle.\n//\n// All the behaviors are defined explicitly. Offers greater flexibility\n// compared to built-in behaviors.\ngame.add(\n  ParticleSystemComponent(\n      particle: Particle.generate(\n        count: 10,\n        generator: (i) {\n          Vector2 position = Vector2.zero();\n          Vector2 speed = Vector2.zero();\n          final acceleration = randomVector2();\n          final paint = Paint()..color = Colors.red;\n\n          return ComputedParticle(\n            renderer: (canvas, _) {\n              speed += acceleration;\n              position += speed;\n              canvas.drawCircle(Offset(position.x, position.y), 1, paint);\n            }\n        );\n      }\n    )\n  )\n);"}
{"prompt": "Create a Flutter Flame game component that Lifecycle¶: During its lifetime, a Particle tracks the time it was alive and exposes it through the progress getter, which returns a value between 0.0 and 1.0. This value can be used in a similar fashion as the value property of the AnimationController class in Flutter.", "completion": "final particle = Particle(lifespan: 2.0);\n\ngame.add(ParticleSystemComponent(particle: particle));\n\n// Will print values from 0 to 1 with step of .1: 0, 0.1, 0.2 ... 0.9, 1.0.\nTimer.periodic(duration * .1, () => print(particle.progress));"}
{"prompt": "Show me how to implement Lifecycle¶: During its lifetime, a Particle tracks the time it was alive and exposes it through the progress getter, which returns a value between 0.0 and 1.0. This value can be used in a similar fashion as the value property of the AnimationController class in Flutter. using Flutter Flame", "completion": "final particle = Particle(lifespan: 2.0);\n\ngame.add(ParticleSystemComponent(particle: particle));\n\n// Will print values from 0 to 1 with step of .1: 0, 0.1, 0.2 ... 0.9, 1.0.\nTimer.periodic(duration * .1, () => print(particle.progress));"}
{"prompt": "Write Flutter Flame code to Lifecycle¶: During its lifetime, a Particle tracks the time it was alive and exposes it through the progress getter, which returns a value between 0.0 and 1.0. This value can be used in a similar fashion as the value property of the AnimationController class in Flutter.", "completion": "final particle = Particle(lifespan: 2.0);\n\ngame.add(ParticleSystemComponent(particle: particle));\n\n// Will print values from 0 to 1 with step of .1: 0, 0.1, 0.2 ... 0.9, 1.0.\nTimer.periodic(duration * .1, () => print(particle.progress));"}
{"prompt": "Create a Flutter Flame game component that TranslatedParticle¶: Simply translates the underlying Particle to a specified Vector2 within the rendering Canvas. Does not change or alter its position, consider using MovingParticle or AcceleratedParticle where change of position is required. Same effect could be achieved by translating the Canvas layer.", "completion": "game.add(\n  ParticleSystemComponent(\n    particle: TranslatedParticle(\n      // Will translate the child Particle effect to the center of game canvas.\n      offset: game.size / 2,\n      child: Particle(),\n    ),\n  ),\n);"}
{"prompt": "Show me how to implement TranslatedParticle¶: Simply translates the underlying Particle to a specified Vector2 within the rendering Canvas. Does not change or alter its position, consider using MovingParticle or AcceleratedParticle where change of position is required. Same effect could be achieved by translating the Canvas layer. using Flutter Flame", "completion": "game.add(\n  ParticleSystemComponent(\n    particle: TranslatedParticle(\n      // Will translate the child Particle effect to the center of game canvas.\n      offset: game.size / 2,\n      child: Particle(),\n    ),\n  ),\n);"}
{"prompt": "Write Flutter Flame code to TranslatedParticle¶: Simply translates the underlying Particle to a specified Vector2 within the rendering Canvas. Does not change or alter its position, consider using MovingParticle or AcceleratedParticle where change of position is required. Same effect could be achieved by translating the Canvas layer.", "completion": "game.add(\n  ParticleSystemComponent(\n    particle: TranslatedParticle(\n      // Will translate the child Particle effect to the center of game canvas.\n      offset: game.size / 2,\n      child: Particle(),\n    ),\n  ),\n);"}
{"prompt": "Create a Flutter Flame game component that MovingParticle¶: Moves the child Particle between the from and to Vector2s during its lifespan. Supports Curve via CurvedParticle.", "completion": "game.add(\n  ParticleSystemComponent(\n    particle: MovingParticle(\n      // Will move from corner to corner of the game canvas.\n      from: Vector2.zero(),\n      to: game.size,\n      child: CircleParticle(\n        radius: 2.0,\n        paint: Paint()..color = Colors.red,\n      ),\n    ),\n  ),\n);"}
{"prompt": "Show me how to implement MovingParticle¶: Moves the child Particle between the from and to Vector2s during its lifespan. Supports Curve via CurvedParticle. using Flutter Flame", "completion": "game.add(\n  ParticleSystemComponent(\n    particle: MovingParticle(\n      // Will move from corner to corner of the game canvas.\n      from: Vector2.zero(),\n      to: game.size,\n      child: CircleParticle(\n        radius: 2.0,\n        paint: Paint()..color = Colors.red,\n      ),\n    ),\n  ),\n);"}
{"prompt": "Write Flutter Flame code to MovingParticle¶: Moves the child Particle between the from and to Vector2s during its lifespan. Supports Curve via CurvedParticle.", "completion": "game.add(\n  ParticleSystemComponent(\n    particle: MovingParticle(\n      // Will move from corner to corner of the game canvas.\n      from: Vector2.zero(),\n      to: game.size,\n      child: CircleParticle(\n        radius: 2.0,\n        paint: Paint()..color = Colors.red,\n      ),\n    ),\n  ),\n);"}
{"prompt": "Create a Flutter Flame game component that AcceleratedParticle¶: A basic physics particle which allows you to specify its initial position, speed and acceleration and lets the update cycle do the rest. All three are specified as Vector2s, which you can think of as vectors. It works especially well for physics-based “bursts”, but it is not limited to that. Unit of the Vector2 value is logical px/s. So a speed of Vector2(0, 100) will move a child Particle by 100 logical pixels of the device every second of game time.", "completion": "final rnd = Random();\nVector2 randomVector2() => (Vector2.random(rnd) - Vector2.random(rnd)) * 100;\n\ngame.add(\n  ParticleSystemComponent(\n    particle: AcceleratedParticle(\n      // Will fire off in the center of game canvas\n      position: game.canvasSize/2,\n      // With random initial speed of Vector2(-100..100, 0..-100)\n      speed: Vector2(rnd.nextDouble() * 200 - 100, -rnd.nextDouble() * 100),\n      // Accelerating downwards, simulating \"gravity\"\n      // speed: Vector2(0, 100),\n      child: CircleParticle(\n        radius: 2.0,\n        paint: Paint()..color = Colors.red,\n      ),\n    ),\n  ),\n);"}
{"prompt": "Show me how to implement AcceleratedParticle¶: A basic physics particle which allows you to specify its initial position, speed and acceleration and lets the update cycle do the rest. All three are specified as Vector2s, which you can think of as vectors. It works especially well for physics-based “bursts”, but it is not limited to that. Unit of the Vector2 value is logical px/s. So a speed of Vector2(0, 100) will move a child Particle by 100 logical pixels of the device every second of game time. using Flutter Flame", "completion": "final rnd = Random();\nVector2 randomVector2() => (Vector2.random(rnd) - Vector2.random(rnd)) * 100;\n\ngame.add(\n  ParticleSystemComponent(\n    particle: AcceleratedParticle(\n      // Will fire off in the center of game canvas\n      position: game.canvasSize/2,\n      // With random initial speed of Vector2(-100..100, 0..-100)\n      speed: Vector2(rnd.nextDouble() * 200 - 100, -rnd.nextDouble() * 100),\n      // Accelerating downwards, simulating \"gravity\"\n      // speed: Vector2(0, 100),\n      child: CircleParticle(\n        radius: 2.0,\n        paint: Paint()..color = Colors.red,\n      ),\n    ),\n  ),\n);"}
{"prompt": "Write Flutter Flame code to AcceleratedParticle¶: A basic physics particle which allows you to specify its initial position, speed and acceleration and lets the update cycle do the rest. All three are specified as Vector2s, which you can think of as vectors. It works especially well for physics-based “bursts”, but it is not limited to that. Unit of the Vector2 value is logical px/s. So a speed of Vector2(0, 100) will move a child Particle by 100 logical pixels of the device every second of game time.", "completion": "final rnd = Random();\nVector2 randomVector2() => (Vector2.random(rnd) - Vector2.random(rnd)) * 100;\n\ngame.add(\n  ParticleSystemComponent(\n    particle: AcceleratedParticle(\n      // Will fire off in the center of game canvas\n      position: game.canvasSize/2,\n      // With random initial speed of Vector2(-100..100, 0..-100)\n      speed: Vector2(rnd.nextDouble() * 200 - 100, -rnd.nextDouble() * 100),\n      // Accelerating downwards, simulating \"gravity\"\n      // speed: Vector2(0, 100),\n      child: CircleParticle(\n        radius: 2.0,\n        paint: Paint()..color = Colors.red,\n      ),\n    ),\n  ),\n);"}
{"prompt": "Create a Flutter Flame game component that CircleParticle¶: A Particle which renders a circle with given Paint at the zero offset of passed Canvas. Use in conjunction with TranslatedParticle, MovingParticle or AcceleratedParticle in order to achieve desired positioning.", "completion": "game.add(\n  ParticleSystemComponent(\n    particle: CircleParticle(\n      radius: game.size.x / 2,\n      paint: Paint()..color = Colors.red.withValues(alpha: .5),\n    ),\n  ),\n);"}
{"prompt": "Show me how to implement CircleParticle¶: A Particle which renders a circle with given Paint at the zero offset of passed Canvas. Use in conjunction with TranslatedParticle, MovingParticle or AcceleratedParticle in order to achieve desired positioning. using Flutter Flame", "completion": "game.add(\n  ParticleSystemComponent(\n    particle: CircleParticle(\n      radius: game.size.x / 2,\n      paint: Paint()..color = Colors.red.withValues(alpha: .5),\n    ),\n  ),\n);"}
{"prompt": "Write Flutter Flame code to CircleParticle¶: A Particle which renders a circle with given Paint at the zero offset of passed Canvas. Use in conjunction with TranslatedParticle, MovingParticle or AcceleratedParticle in order to achieve desired positioning.", "completion": "game.add(\n  ParticleSystemComponent(\n    particle: CircleParticle(\n      radius: game.size.x / 2,\n      paint: Paint()..color = Colors.red.withValues(alpha: .5),\n    ),\n  ),\n);"}
{"prompt": "Create a Flutter Flame game component that SpriteParticle¶: Allows you to embed a Sprite into your particle effects.", "completion": "game.add(\n  ParticleSystemComponent(\n    particle: SpriteParticle(\n      sprite: Sprite('sprite.png'),\n      size: Vector2(64, 64),\n    ),\n  ),\n);"}
{"prompt": "Show me how to implement SpriteParticle¶: Allows you to embed a Sprite into your particle effects. using Flutter Flame", "completion": "game.add(\n  ParticleSystemComponent(\n    particle: SpriteParticle(\n      sprite: Sprite('sprite.png'),\n      size: Vector2(64, 64),\n    ),\n  ),\n);"}
{"prompt": "Write Flutter Flame code to SpriteParticle¶: Allows you to embed a Sprite into your particle effects.", "completion": "game.add(\n  ParticleSystemComponent(\n    particle: SpriteParticle(\n      sprite: Sprite('sprite.png'),\n      size: Vector2(64, 64),\n    ),\n  ),\n);"}
{"prompt": "Create a Flutter Flame game component that ImageParticle¶: Renders given dart:ui image within the particle tree.", "completion": "// During game initialization\nawait Flame.images.loadAll(const [\n  'image.png',\n]);\n\n// ...\n\n// Somewhere during the game loop\nfinal image = await Flame.images.load('image.png');\n\ngame.add(\n  ParticleSystemComponent(\n    particle: ImageParticle(\n      size: Vector2.all(24),\n      image: image,\n    );\n  ),\n);"}
{"prompt": "Show me how to implement ImageParticle¶: Renders given dart:ui image within the particle tree. using Flutter Flame", "completion": "// During game initialization\nawait Flame.images.loadAll(const [\n  'image.png',\n]);\n\n// ...\n\n// Somewhere during the game loop\nfinal image = await Flame.images.load('image.png');\n\ngame.add(\n  ParticleSystemComponent(\n    particle: ImageParticle(\n      size: Vector2.all(24),\n      image: image,\n    );\n  ),\n);"}
{"prompt": "Write Flutter Flame code to ImageParticle¶: Renders given dart:ui image within the particle tree.", "completion": "// During game initialization\nawait Flame.images.loadAll(const [\n  'image.png',\n]);\n\n// ...\n\n// Somewhere during the game loop\nfinal image = await Flame.images.load('image.png');\n\ngame.add(\n  ParticleSystemComponent(\n    particle: ImageParticle(\n      size: Vector2.all(24),\n      image: image,\n    );\n  ),\n);"}
{"prompt": "Create a Flutter Flame game component that ScalingParticle¶: Scales the child Particle between 1 and to during its lifespan.", "completion": "game.add(\n  ParticleSystemComponent(\n    particle: ScalingParticle(\n      lifespan: 2,\n      to: 0,\n      curve: Curves.easeIn,\n      child: CircleParticle(\n        radius: 2.0,\n        paint: Paint()..color = Colors.red,\n      )\n    );\n  ),\n);"}
{"prompt": "Show me how to implement ScalingParticle¶: Scales the child Particle between 1 and to during its lifespan. using Flutter Flame", "completion": "game.add(\n  ParticleSystemComponent(\n    particle: ScalingParticle(\n      lifespan: 2,\n      to: 0,\n      curve: Curves.easeIn,\n      child: CircleParticle(\n        radius: 2.0,\n        paint: Paint()..color = Colors.red,\n      )\n    );\n  ),\n);"}
{"prompt": "Write Flutter Flame code to ScalingParticle¶: Scales the child Particle between 1 and to during its lifespan.", "completion": "game.add(\n  ParticleSystemComponent(\n    particle: ScalingParticle(\n      lifespan: 2,\n      to: 0,\n      curve: Curves.easeIn,\n      child: CircleParticle(\n        radius: 2.0,\n        paint: Paint()..color = Colors.red,\n      )\n    );\n  ),\n);"}
{"prompt": "Create a Flutter Flame game component that SpriteAnimationParticle¶: A Particle which embeds a SpriteAnimation. By default, aligns the SpriteAnimation’s stepTime so that it’s fully played during the Particle lifespan. It’s possible to override this behavior with the alignAnimationTime argument.", "completion": "final spriteSheet = SpriteSheet(\n  image: yourSpriteSheetImage,\n  srcSize: Vector2.all(16.0),\n);\n\ngame.add(\n  ParticleSystemComponent(\n    particle: SpriteAnimationParticle(\n      animation: spriteSheet.createAnimation(0, stepTime: 0.1),\n    );\n  ),\n);"}
{"prompt": "Show me how to implement SpriteAnimationParticle¶: A Particle which embeds a SpriteAnimation. By default, aligns the SpriteAnimation’s stepTime so that it’s fully played during the Particle lifespan. It’s possible to override this behavior with the alignAnimationTime argument. using Flutter Flame", "completion": "final spriteSheet = SpriteSheet(\n  image: yourSpriteSheetImage,\n  srcSize: Vector2.all(16.0),\n);\n\ngame.add(\n  ParticleSystemComponent(\n    particle: SpriteAnimationParticle(\n      animation: spriteSheet.createAnimation(0, stepTime: 0.1),\n    );\n  ),\n);"}
{"prompt": "Write Flutter Flame code to SpriteAnimationParticle¶: A Particle which embeds a SpriteAnimation. By default, aligns the SpriteAnimation’s stepTime so that it’s fully played during the Particle lifespan. It’s possible to override this behavior with the alignAnimationTime argument.", "completion": "final spriteSheet = SpriteSheet(\n  image: yourSpriteSheetImage,\n  srcSize: Vector2.all(16.0),\n);\n\ngame.add(\n  ParticleSystemComponent(\n    particle: SpriteAnimationParticle(\n      animation: spriteSheet.createAnimation(0, stepTime: 0.1),\n    );\n  ),\n);"}
{"prompt": "Create a Flutter Flame game component that ComponentParticle¶: This Particle allows you to embed a Component within the particle effects. The Component could have its own update lifecycle and could be reused across different effect trees. If the only thing you need is to add some dynamics to an instance of a certain Component, please consider adding it to the game directly, without the Particle in the middle.", "completion": "final longLivingRect = RectComponent();\n\ngame.add(\n  ParticleSystemComponent(\n    particle: ComponentParticle(\n      component: longLivingRect\n    );\n  ),\n);\n\nclass RectComponent extends Component {\n  void render(Canvas c) {\n    c.drawRect(\n      Rect.fromCenter(center: Offset.zero, width: 100, height: 100),\n      Paint()..color = Colors.red\n    );\n  }\n\n  void update(double dt) {\n    /// Will be called by parent [Particle]\n  }\n}"}
{"prompt": "Show me how to implement ComponentParticle¶: This Particle allows you to embed a Component within the particle effects. The Component could have its own update lifecycle and could be reused across different effect trees. If the only thing you need is to add some dynamics to an instance of a certain Component, please consider adding it to the game directly, without the Particle in the middle. using Flutter Flame", "completion": "final longLivingRect = RectComponent();\n\ngame.add(\n  ParticleSystemComponent(\n    particle: ComponentParticle(\n      component: longLivingRect\n    );\n  ),\n);\n\nclass RectComponent extends Component {\n  void render(Canvas c) {\n    c.drawRect(\n      Rect.fromCenter(center: Offset.zero, width: 100, height: 100),\n      Paint()..color = Colors.red\n    );\n  }\n\n  void update(double dt) {\n    /// Will be called by parent [Particle]\n  }\n}"}
{"prompt": "Write Flutter Flame code to ComponentParticle¶: This Particle allows you to embed a Component within the particle effects. The Component could have its own update lifecycle and could be reused across different effect trees. If the only thing you need is to add some dynamics to an instance of a certain Component, please consider adding it to the game directly, without the Particle in the middle.", "completion": "final longLivingRect = RectComponent();\n\ngame.add(\n  ParticleSystemComponent(\n    particle: ComponentParticle(\n      component: longLivingRect\n    );\n  ),\n);\n\nclass RectComponent extends Component {\n  void render(Canvas c) {\n    c.drawRect(\n      Rect.fromCenter(center: Offset.zero, width: 100, height: 100),\n      Paint()..color = Colors.red\n    );\n  }\n\n  void update(double dt) {\n    /// Will be called by parent [Particle]\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that ComputedParticle¶: When created, it delegates all the rendering to a supplied ParticleRenderDelegate which is called on each frame to perform necessary computations and render something to the Canvas.", "completion": "game.add(\n  ParticleSystemComponent(\n    // Renders a circle which gradually changes its color and size during the\n    // particle lifespan.\n    particle: ComputedParticle(\n      renderer: (canvas, particle) => canvas.drawCircle(\n        Offset.zero,\n        particle.progress * 10,\n        Paint()\n          ..color = Color.lerp(\n            Colors.red,\n            Colors.blue,\n            particle.progress,\n          ),\n      ),\n    ),\n  ),\n)"}
{"prompt": "Show me how to implement ComputedParticle¶: When created, it delegates all the rendering to a supplied ParticleRenderDelegate which is called on each frame to perform necessary computations and render something to the Canvas. using Flutter Flame", "completion": "game.add(\n  ParticleSystemComponent(\n    // Renders a circle which gradually changes its color and size during the\n    // particle lifespan.\n    particle: ComputedParticle(\n      renderer: (canvas, particle) => canvas.drawCircle(\n        Offset.zero,\n        particle.progress * 10,\n        Paint()\n          ..color = Color.lerp(\n            Colors.red,\n            Colors.blue,\n            particle.progress,\n          ),\n      ),\n    ),\n  ),\n)"}
{"prompt": "Write Flutter Flame code to ComputedParticle¶: When created, it delegates all the rendering to a supplied ParticleRenderDelegate which is called on each frame to perform necessary computations and render something to the Canvas.", "completion": "game.add(\n  ParticleSystemComponent(\n    // Renders a circle which gradually changes its color and size during the\n    // particle lifespan.\n    particle: ComputedParticle(\n      renderer: (canvas, particle) => canvas.drawCircle(\n        Offset.zero,\n        particle.progress * 10,\n        Paint()\n          ..color = Color.lerp(\n            Colors.red,\n            Colors.blue,\n            particle.progress,\n          ),\n      ),\n    ),\n  ),\n)"}
{"prompt": "Create a Flutter Flame game component that The Klondike draw¶: So how do we implement Klondike Draw 1? Clearly only the Stock and Waste piles are involved, so maybe we should have KlondikeGame provide a value 1 or 3 to each of them. They both have code for constructors, so we could just add an extra parameter to that code, but in Flame there is another way, which works even if your component has a default constructor (no code for it) or your game has many game-wide values. Let us call our value klondikeDraw. In your class declaration add the HasGameReference<MyGame> mixin, then write game.klondikeDraw wherever you need the value 1 or 3. For class StockPile we will have:", "completion": "class StockPile extends PositionComponent\n    with TapCallbacks, HasGameReference<KlondikeGame>\n    implements Pile {"}
{"prompt": "Show me how to implement The Klondike draw¶: So how do we implement Klondike Draw 1? Clearly only the Stock and Waste piles are involved, so maybe we should have KlondikeGame provide a value 1 or 3 to each of them. They both have code for constructors, so we could just add an extra parameter to that code, but in Flame there is another way, which works even if your component has a default constructor (no code for it) or your game has many game-wide values. Let us call our value klondikeDraw. In your class declaration add the HasGameReference<MyGame> mixin, then write game.klondikeDraw wherever you need the value 1 or 3. For class StockPile we will have: using Flutter Flame", "completion": "class StockPile extends PositionComponent\n    with TapCallbacks, HasGameReference<KlondikeGame>\n    implements Pile {"}
{"prompt": "Write Flutter Flame code to The Klondike draw¶: So how do we implement Klondike Draw 1? Clearly only the Stock and Waste piles are involved, so maybe we should have KlondikeGame provide a value 1 or 3 to each of them. They both have code for constructors, so we could just add an extra parameter to that code, but in Flame there is another way, which works even if your component has a default constructor (no code for it) or your game has many game-wide values. Let us call our value klondikeDraw. In your class declaration add the HasGameReference<MyGame> mixin, then write game.klondikeDraw wherever you need the value 1 or 3. For class StockPile we will have:", "completion": "class StockPile extends PositionComponent\n    with TapCallbacks, HasGameReference<KlondikeGame>\n    implements Pile {"}
{"prompt": "Create a Flutter Flame game component that The Klondike draw¶: For class WastePile we will have:", "completion": "class WastePile extends PositionComponent\n    with HasGameReference<KlondikeGame>\n    implements Pile {"}
{"prompt": "Show me how to implement The Klondike draw¶: For class WastePile we will have: using Flutter Flame", "completion": "class WastePile extends PositionComponent\n    with HasGameReference<KlondikeGame>\n    implements Pile {"}
{"prompt": "Write Flutter Flame code to The Klondike draw¶: For class WastePile we will have:", "completion": "class WastePile extends PositionComponent\n    with HasGameReference<KlondikeGame>\n    implements Pile {"}
{"prompt": "Create a Flutter Flame game component that Making cards move¶: To move a card, we will add a doMove() method to the Card class. It will require a to location to go to. Optional parameters are speed: (default 10.0), start: (default zero), curve: (default Curves.easeOutQuad) and onComplete: (default null, i.e. no callback when the move finishes). Speed is in card widths per second. Usually we will provide a callback, because a bit of gameplay must be done after the animated move. The default curve: parameter gives us a fast-in/slow-out move, much as a human player would do. So the following code is added to the end of the Card class:", "completion": "void doMove(\n    Vector2 to, {\n    double speed = 10.0,\n    double start = 0.0,\n    Curve curve = Curves.easeOutQuad,\n    VoidCallback? onComplete,\n  }) {\n    assert(speed > 0.0, 'Speed must be > 0 widths per second');\n    final dt = (to - position).length / (speed * size.x);\n    assert(dt > 0.0, 'Distance to move must be > 0');\n    priority = 100;\n    add(\n      MoveToEffect(\n        to,\n        EffectController(duration: dt, startDelay: start, curve: curve),\n        onComplete: () {\n          onComplete?.call();\n        },\n      ),\n    );\n  }"}
{"prompt": "Show me how to implement Making cards move¶: To move a card, we will add a doMove() method to the Card class. It will require a to location to go to. Optional parameters are speed: (default 10.0), start: (default zero), curve: (default Curves.easeOutQuad) and onComplete: (default null, i.e. no callback when the move finishes). Speed is in card widths per second. Usually we will provide a callback, because a bit of gameplay must be done after the animated move. The default curve: parameter gives us a fast-in/slow-out move, much as a human player would do. So the following code is added to the end of the Card class: using Flutter Flame", "completion": "void doMove(\n    Vector2 to, {\n    double speed = 10.0,\n    double start = 0.0,\n    Curve curve = Curves.easeOutQuad,\n    VoidCallback? onComplete,\n  }) {\n    assert(speed > 0.0, 'Speed must be > 0 widths per second');\n    final dt = (to - position).length / (speed * size.x);\n    assert(dt > 0.0, 'Distance to move must be > 0');\n    priority = 100;\n    add(\n      MoveToEffect(\n        to,\n        EffectController(duration: dt, startDelay: start, curve: curve),\n        onComplete: () {\n          onComplete?.call();\n        },\n      ),\n    );\n  }"}
{"prompt": "Write Flutter Flame code to Making cards move¶: To move a card, we will add a doMove() method to the Card class. It will require a to location to go to. Optional parameters are speed: (default 10.0), start: (default zero), curve: (default Curves.easeOutQuad) and onComplete: (default null, i.e. no callback when the move finishes). Speed is in card widths per second. Usually we will provide a callback, because a bit of gameplay must be done after the animated move. The default curve: parameter gives us a fast-in/slow-out move, much as a human player would do. So the following code is added to the end of the Card class:", "completion": "void doMove(\n    Vector2 to, {\n    double speed = 10.0,\n    double start = 0.0,\n    Curve curve = Curves.easeOutQuad,\n    VoidCallback? onComplete,\n  }) {\n    assert(speed > 0.0, 'Speed must be > 0 widths per second');\n    final dt = (to - position).length / (speed * size.x);\n    assert(dt > 0.0, 'Distance to move must be > 0');\n    priority = 100;\n    add(\n      MoveToEffect(\n        to,\n        EffectController(duration: dt, startDelay: start, curve: curve),\n        onComplete: () {\n          onComplete?.call();\n        },\n      ),\n    );\n  }"}
{"prompt": "Create a Flutter Flame game component that Making cards move¶: To make this code compile we need to import 'package:flame/effects.dart' and 'package:flutter/animation.dart' at the top of the components/card.dart file. That done, we can start using the new method to return the card(s) gracefully to where they came from, after being dropped in an invalid position. First, we need a private data item to store a card’s position when a drag-and-drop started. So let us insert new lines in two places as shown below:", "completion": "bool _isDragging = false;\n  Vector2 _whereCardStarted = Vector2(0, 0);\n\n  final List<Card> attachedCards = [];"}
{"prompt": "Show me how to implement Making cards move¶: To make this code compile we need to import 'package:flame/effects.dart' and 'package:flutter/animation.dart' at the top of the components/card.dart file. That done, we can start using the new method to return the card(s) gracefully to where they came from, after being dropped in an invalid position. First, we need a private data item to store a card’s position when a drag-and-drop started. So let us insert new lines in two places as shown below: using Flutter Flame", "completion": "bool _isDragging = false;\n  Vector2 _whereCardStarted = Vector2(0, 0);\n\n  final List<Card> attachedCards = [];"}
{"prompt": "Write Flutter Flame code to Making cards move¶: To make this code compile we need to import 'package:flame/effects.dart' and 'package:flutter/animation.dart' at the top of the components/card.dart file. That done, we can start using the new method to return the card(s) gracefully to where they came from, after being dropped in an invalid position. First, we need a private data item to store a card’s position when a drag-and-drop started. So let us insert new lines in two places as shown below:", "completion": "bool _isDragging = false;\n  Vector2 _whereCardStarted = Vector2(0, 0);\n\n  final List<Card> attachedCards = [];"}
{"prompt": "Create a Flutter Flame game component that Making cards move¶: To make this code compile we need to import 'package:flame/effects.dart' and 'package:flutter/animation.dart' at the top of the components/card.dart file. That done, we can start using the new method to return the card(s) gracefully to where they came from, after being dropped in an invalid position. First, we need a private data item to store a card’s position when a drag-and-drop started. So let us insert new lines in two places as shown below:", "completion": "_isDragging = true;\n      priority = 100;\n      // Copy each co-ord, else _whereCardStarted changes as the position does.\n      _whereCardStarted = Vector2(position.x, position.y);\n      if (pile is TableauPile) {"}
{"prompt": "Show me how to implement Making cards move¶: To make this code compile we need to import 'package:flame/effects.dart' and 'package:flutter/animation.dart' at the top of the components/card.dart file. That done, we can start using the new method to return the card(s) gracefully to where they came from, after being dropped in an invalid position. First, we need a private data item to store a card’s position when a drag-and-drop started. So let us insert new lines in two places as shown below: using Flutter Flame", "completion": "_isDragging = true;\n      priority = 100;\n      // Copy each co-ord, else _whereCardStarted changes as the position does.\n      _whereCardStarted = Vector2(position.x, position.y);\n      if (pile is TableauPile) {"}
{"prompt": "Write Flutter Flame code to Making cards move¶: To make this code compile we need to import 'package:flame/effects.dart' and 'package:flutter/animation.dart' at the top of the components/card.dart file. That done, we can start using the new method to return the card(s) gracefully to where they came from, after being dropped in an invalid position. First, we need a private data item to store a card’s position when a drag-and-drop started. So let us insert new lines in two places as shown below:", "completion": "_isDragging = true;\n      priority = 100;\n      // Copy each co-ord, else _whereCardStarted changes as the position does.\n      _whereCardStarted = Vector2(position.x, position.y);\n      if (pile is TableauPile) {"}
{"prompt": "Create a Flutter Flame game component that Animating a card-flip¶: Flutter and Flame do not yet support 3-D effects (as at October 2023), but we can emulate them. To make a card look as if it is turning over, we will shrink the width of the back-view, switch to the front view and expand back to full width. The code uses quite a few features of Effects and EffectControllers:", "completion": "void turnFaceUp({\n    double time = 0.3,\n    double start = 0.0,\n    VoidCallback? onComplete,\n  }) {\n    assert(!_isFaceUpView, 'Card must be face-down before turning face-up.');\n    assert(time > 0.0, 'Time to turn card over must be > 0');\n    _isAnimatedFlip = true;\n    anchor = Anchor.topCenter;\n    position += Vector2(width / 2, 0);\n    priority = 100;\n    add(\n      ScaleEffect.to(\n        Vector2(scale.x / 100, scale.y),\n        EffectController(\n          startDelay: start,\n          curve: Curves.easeOutSine,\n          duration: time / 2,\n          onMax: () {\n            _isFaceUpView = true;\n          },\n          reverseDuration: time / 2,\n          onMin: () {\n            _isAnimatedFlip = false;\n            _faceUp = true;\n            anchor = Anchor.topLeft;\n            position -= Vector2(width / 2, 0);\n          },\n        ),\n        onComplete: () {\n          onComplete?.call();\n        },\n      ),\n    );\n  }"}
{"prompt": "Show me how to implement Animating a card-flip¶: Flutter and Flame do not yet support 3-D effects (as at October 2023), but we can emulate them. To make a card look as if it is turning over, we will shrink the width of the back-view, switch to the front view and expand back to full width. The code uses quite a few features of Effects and EffectControllers: using Flutter Flame", "completion": "void turnFaceUp({\n    double time = 0.3,\n    double start = 0.0,\n    VoidCallback? onComplete,\n  }) {\n    assert(!_isFaceUpView, 'Card must be face-down before turning face-up.');\n    assert(time > 0.0, 'Time to turn card over must be > 0');\n    _isAnimatedFlip = true;\n    anchor = Anchor.topCenter;\n    position += Vector2(width / 2, 0);\n    priority = 100;\n    add(\n      ScaleEffect.to(\n        Vector2(scale.x / 100, scale.y),\n        EffectController(\n          startDelay: start,\n          curve: Curves.easeOutSine,\n          duration: time / 2,\n          onMax: () {\n            _isFaceUpView = true;\n          },\n          reverseDuration: time / 2,\n          onMin: () {\n            _isAnimatedFlip = false;\n            _faceUp = true;\n            anchor = Anchor.topLeft;\n            position -= Vector2(width / 2, 0);\n          },\n        ),\n        onComplete: () {\n          onComplete?.call();\n        },\n      ),\n    );\n  }"}
{"prompt": "Write Flutter Flame code to Animating a card-flip¶: Flutter and Flame do not yet support 3-D effects (as at October 2023), but we can emulate them. To make a card look as if it is turning over, we will shrink the width of the back-view, switch to the front view and expand back to full width. The code uses quite a few features of Effects and EffectControllers:", "completion": "void turnFaceUp({\n    double time = 0.3,\n    double start = 0.0,\n    VoidCallback? onComplete,\n  }) {\n    assert(!_isFaceUpView, 'Card must be face-down before turning face-up.');\n    assert(time > 0.0, 'Time to turn card over must be > 0');\n    _isAnimatedFlip = true;\n    anchor = Anchor.topCenter;\n    position += Vector2(width / 2, 0);\n    priority = 100;\n    add(\n      ScaleEffect.to(\n        Vector2(scale.x / 100, scale.y),\n        EffectController(\n          startDelay: start,\n          curve: Curves.easeOutSine,\n          duration: time / 2,\n          onMax: () {\n            _isFaceUpView = true;\n          },\n          reverseDuration: time / 2,\n          onMin: () {\n            _isAnimatedFlip = false;\n            _faceUp = true;\n            anchor = Anchor.topLeft;\n            position -= Vector2(width / 2, 0);\n          },\n        ),\n        onComplete: () {\n          onComplete?.call();\n        },\n      ),\n    );\n  }"}
{"prompt": "Create a Flutter Flame game component that A stripped-down KlondikeGame class¶: Here is the new code for the KlondikeGame class (what is left of it).", "completion": "enum Action { newDeal, sameDeal, changeDraw, haveFun }\n\nclass KlondikeGame extends FlameGame<KlondikeWorld> {\n  static const double cardGap = 175.0;\n  static const double topGap = 500.0;\n  static const double cardWidth = 1000.0;\n  static const double cardHeight = 1400.0;\n  static const double cardRadius = 100.0;\n  static const double cardSpaceWidth = cardWidth + cardGap;\n  static const double cardSpaceHeight = cardHeight + cardGap;\n  static final Vector2 cardSize = Vector2(cardWidth, cardHeight);\n  static final cardRRect = RRect.fromRectAndRadius(\n    const Rect.fromLTWH(0, 0, cardWidth, cardHeight),\n    const Radius.circular(cardRadius),\n  );\n\n  // Constant used when creating Random seed.\n  static const int maxInt = 0xFFFFFFFE; // = (2 to the power 32) - 1\n\n  // This KlondikeGame constructor also initiates the first KlondikeWorld.\n  KlondikeGame() : super(world: KlondikeWorld());\n\n  // These three values persist between games and are starting conditions\n  // for the next game to be played in KlondikeWorld. The actual seed is\n  // computed in KlondikeWorld but is held here in case the player chooses\n  // to replay a game by selecting Action.sameDeal.\n  int klondikeDraw = 1;\n  int seed = 1;\n  Action action = Action.newDeal;\n}"}
{"prompt": "Show me how to implement A stripped-down KlondikeGame class¶: Here is the new code for the KlondikeGame class (what is left of it). using Flutter Flame", "completion": "enum Action { newDeal, sameDeal, changeDraw, haveFun }\n\nclass KlondikeGame extends FlameGame<KlondikeWorld> {\n  static const double cardGap = 175.0;\n  static const double topGap = 500.0;\n  static const double cardWidth = 1000.0;\n  static const double cardHeight = 1400.0;\n  static const double cardRadius = 100.0;\n  static const double cardSpaceWidth = cardWidth + cardGap;\n  static const double cardSpaceHeight = cardHeight + cardGap;\n  static final Vector2 cardSize = Vector2(cardWidth, cardHeight);\n  static final cardRRect = RRect.fromRectAndRadius(\n    const Rect.fromLTWH(0, 0, cardWidth, cardHeight),\n    const Radius.circular(cardRadius),\n  );\n\n  // Constant used when creating Random seed.\n  static const int maxInt = 0xFFFFFFFE; // = (2 to the power 32) - 1\n\n  // This KlondikeGame constructor also initiates the first KlondikeWorld.\n  KlondikeGame() : super(world: KlondikeWorld());\n\n  // These three values persist between games and are starting conditions\n  // for the next game to be played in KlondikeWorld. The actual seed is\n  // computed in KlondikeWorld but is held here in case the player chooses\n  // to replay a game by selecting Action.sameDeal.\n  int klondikeDraw = 1;\n  int seed = 1;\n  Action action = Action.newDeal;\n}"}
{"prompt": "Write Flutter Flame code to A stripped-down KlondikeGame class¶: Here is the new code for the KlondikeGame class (what is left of it).", "completion": "enum Action { newDeal, sameDeal, changeDraw, haveFun }\n\nclass KlondikeGame extends FlameGame<KlondikeWorld> {\n  static const double cardGap = 175.0;\n  static const double topGap = 500.0;\n  static const double cardWidth = 1000.0;\n  static const double cardHeight = 1400.0;\n  static const double cardRadius = 100.0;\n  static const double cardSpaceWidth = cardWidth + cardGap;\n  static const double cardSpaceHeight = cardHeight + cardGap;\n  static final Vector2 cardSize = Vector2(cardWidth, cardHeight);\n  static final cardRRect = RRect.fromRectAndRadius(\n    const Rect.fromLTWH(0, 0, cardWidth, cardHeight),\n    const Radius.circular(cardRadius),\n  );\n\n  // Constant used when creating Random seed.\n  static const int maxInt = 0xFFFFFFFE; // = (2 to the power 32) - 1\n\n  // This KlondikeGame constructor also initiates the first KlondikeWorld.\n  KlondikeGame() : super(world: KlondikeWorld());\n\n  // These three values persist between games and are starting conditions\n  // for the next game to be played in KlondikeWorld. The actual seed is\n  // computed in KlondikeWorld but is held here in case the player chooses\n  // to replay a game by selecting Action.sameDeal.\n  int klondikeDraw = 1;\n  int seed = 1;\n  Action action = Action.newDeal;\n}"}
{"prompt": "Create a Flutter Flame game component that Buttons¶: We use the addButton() method, during our world’s onLoad(), to set up our four buttons and add them to our world.", "completion": "playAreaSize =\n        Vector2(7 * cardSpaceWidth + cardGap, 4 * cardSpaceHeight + topGap);\n    final gameMidX = playAreaSize.x / 2;\n\n    addButton('New deal', gameMidX, Action.newDeal);\n    addButton('Same deal', gameMidX + cardSpaceWidth, Action.sameDeal);\n    addButton('Draw 1 or 3', gameMidX + 2 * cardSpaceWidth, Action.changeDraw);\n    addButton('Have fun', gameMidX + 3 * cardSpaceWidth, Action.haveFun);"}
{"prompt": "Show me how to implement Buttons¶: We use the addButton() method, during our world’s onLoad(), to set up our four buttons and add them to our world. using Flutter Flame", "completion": "playAreaSize =\n        Vector2(7 * cardSpaceWidth + cardGap, 4 * cardSpaceHeight + topGap);\n    final gameMidX = playAreaSize.x / 2;\n\n    addButton('New deal', gameMidX, Action.newDeal);\n    addButton('Same deal', gameMidX + cardSpaceWidth, Action.sameDeal);\n    addButton('Draw 1 or 3', gameMidX + 2 * cardSpaceWidth, Action.changeDraw);\n    addButton('Have fun', gameMidX + 3 * cardSpaceWidth, Action.haveFun);"}
{"prompt": "Write Flutter Flame code to Buttons¶: We use the addButton() method, during our world’s onLoad(), to set up our four buttons and add them to our world.", "completion": "playAreaSize =\n        Vector2(7 * cardSpaceWidth + cardGap, 4 * cardSpaceHeight + topGap);\n    final gameMidX = playAreaSize.x / 2;\n\n    addButton('New deal', gameMidX, Action.newDeal);\n    addButton('Same deal', gameMidX + cardSpaceWidth, Action.sameDeal);\n    addButton('Draw 1 or 3', gameMidX + 2 * cardSpaceWidth, Action.changeDraw);\n    addButton('Have fun', gameMidX + 3 * cardSpaceWidth, Action.haveFun);"}
{"prompt": "Create a Flutter Flame game component that The deal() method¶: The last thing the KlondikeWorld’s onLoad() method does is call the deal() method to shuffle and deal the cards. This method is now in the KlondikeWorld class and so are the checkWin() and letsCelebrate() methods, but more about those later. The deal process is the same as before but now includes some animation:", "completion": "void deal() {\n    assert(cards.length == 52, 'There are ${cards.length} cards: should be 52');\n\n    if (game.action != Action.sameDeal) {\n      // New deal: change the Random Number Generator's seed.\n      game.seed = Random().nextInt(KlondikeGame.maxInt);\n      if (game.action == Action.changeDraw) {\n        game.klondikeDraw = (game.klondikeDraw == 3) ? 1 : 3;\n      }\n    }\n    // For the \"Same deal\" option, re-use the previous seed, else use a new one.\n    cards.shuffle(Random(game.seed));\n\n    var cardToDeal = cards.length - 1;\n    var nMovingCards = 0;\n    for (var i = 0; i < 7; i++) {\n      for (var j = i; j < 7; j++) {\n        final card = cards[cardToDeal--];\n        card.doMove(\n          tableauPiles[j].position,\n          start: nMovingCards * 0.15,\n          onComplete: () {\n            tableauPiles[j].acquireCard(card);\n            nMovingCards--;\n            if (nMovingCards == 0) {\n              var delayFactor = 0;\n              for (final tableauPile in tableauPiles) {\n                delayFactor++;\n                tableauPile.flipTopCard(start: delayFactor * 0.15);\n              }\n            }\n          },\n        );\n        nMovingCards++;\n      }\n    }\n    for (var n = 0; n <= cardToDeal; n++) {\n      stock.acquireCard(cards[n]);\n    }\n  }"}
{"prompt": "Show me how to implement The deal() method¶: The last thing the KlondikeWorld’s onLoad() method does is call the deal() method to shuffle and deal the cards. This method is now in the KlondikeWorld class and so are the checkWin() and letsCelebrate() methods, but more about those later. The deal process is the same as before but now includes some animation: using Flutter Flame", "completion": "void deal() {\n    assert(cards.length == 52, 'There are ${cards.length} cards: should be 52');\n\n    if (game.action != Action.sameDeal) {\n      // New deal: change the Random Number Generator's seed.\n      game.seed = Random().nextInt(KlondikeGame.maxInt);\n      if (game.action == Action.changeDraw) {\n        game.klondikeDraw = (game.klondikeDraw == 3) ? 1 : 3;\n      }\n    }\n    // For the \"Same deal\" option, re-use the previous seed, else use a new one.\n    cards.shuffle(Random(game.seed));\n\n    var cardToDeal = cards.length - 1;\n    var nMovingCards = 0;\n    for (var i = 0; i < 7; i++) {\n      for (var j = i; j < 7; j++) {\n        final card = cards[cardToDeal--];\n        card.doMove(\n          tableauPiles[j].position,\n          start: nMovingCards * 0.15,\n          onComplete: () {\n            tableauPiles[j].acquireCard(card);\n            nMovingCards--;\n            if (nMovingCards == 0) {\n              var delayFactor = 0;\n              for (final tableauPile in tableauPiles) {\n                delayFactor++;\n                tableauPile.flipTopCard(start: delayFactor * 0.15);\n              }\n            }\n          },\n        );\n        nMovingCards++;\n      }\n    }\n    for (var n = 0; n <= cardToDeal; n++) {\n      stock.acquireCard(cards[n]);\n    }\n  }"}
{"prompt": "Write Flutter Flame code to The deal() method¶: The last thing the KlondikeWorld’s onLoad() method does is call the deal() method to shuffle and deal the cards. This method is now in the KlondikeWorld class and so are the checkWin() and letsCelebrate() methods, but more about those later. The deal process is the same as before but now includes some animation:", "completion": "void deal() {\n    assert(cards.length == 52, 'There are ${cards.length} cards: should be 52');\n\n    if (game.action != Action.sameDeal) {\n      // New deal: change the Random Number Generator's seed.\n      game.seed = Random().nextInt(KlondikeGame.maxInt);\n      if (game.action == Action.changeDraw) {\n        game.klondikeDraw = (game.klondikeDraw == 3) ? 1 : 3;\n      }\n    }\n    // For the \"Same deal\" option, re-use the previous seed, else use a new one.\n    cards.shuffle(Random(game.seed));\n\n    var cardToDeal = cards.length - 1;\n    var nMovingCards = 0;\n    for (var i = 0; i < 7; i++) {\n      for (var j = i; j < 7; j++) {\n        final card = cards[cardToDeal--];\n        card.doMove(\n          tableauPiles[j].position,\n          start: nMovingCards * 0.15,\n          onComplete: () {\n            tableauPiles[j].acquireCard(card);\n            nMovingCards--;\n            if (nMovingCards == 0) {\n              var delayFactor = 0;\n              for (final tableauPile in tableauPiles) {\n                delayFactor++;\n                tableauPile.flipTopCard(start: delayFactor * 0.15);\n              }\n            }\n          },\n        );\n        nMovingCards++;\n      }\n    }\n    for (var n = 0; n <= cardToDeal; n++) {\n      stock.acquireCard(cards[n]);\n    }\n  }"}
{"prompt": "Create a Flutter Flame game component that Winning the game¶: You win the game when all cards in all suits, Ace to King, have been moved to the Foundation Piles, 13 cards in each pile. The game now has code to recognize that event — an isFull test added to the FoundationPile’s acquireCard() method, a callback to KlondikeWorld and a test as to whether all four Foundations are full. Here is the code:", "completion": "class FoundationPile extends PositionComponent implements Pile {\n  FoundationPile(int intSuit, this.checkWin, {super.position})\n      : suit = Suit.fromInt(intSuit),\n        super(size: KlondikeGame.cardSize);\n\n  final VoidCallback checkWin;\n\n  final Suit suit;\n  final List<Card> _cards = [];\n\n  //#region Pile API\n\n  bool get isFull => _cards.length == 13;"}
{"prompt": "Show me how to implement Winning the game¶: You win the game when all cards in all suits, Ace to King, have been moved to the Foundation Piles, 13 cards in each pile. The game now has code to recognize that event — an isFull test added to the FoundationPile’s acquireCard() method, a callback to KlondikeWorld and a test as to whether all four Foundations are full. Here is the code: using Flutter Flame", "completion": "class FoundationPile extends PositionComponent implements Pile {\n  FoundationPile(int intSuit, this.checkWin, {super.position})\n      : suit = Suit.fromInt(intSuit),\n        super(size: KlondikeGame.cardSize);\n\n  final VoidCallback checkWin;\n\n  final Suit suit;\n  final List<Card> _cards = [];\n\n  //#region Pile API\n\n  bool get isFull => _cards.length == 13;"}
{"prompt": "Write Flutter Flame code to Winning the game¶: You win the game when all cards in all suits, Ace to King, have been moved to the Foundation Piles, 13 cards in each pile. The game now has code to recognize that event — an isFull test added to the FoundationPile’s acquireCard() method, a callback to KlondikeWorld and a test as to whether all four Foundations are full. Here is the code:", "completion": "class FoundationPile extends PositionComponent implements Pile {\n  FoundationPile(int intSuit, this.checkWin, {super.position})\n      : suit = Suit.fromInt(intSuit),\n        super(size: KlondikeGame.cardSize);\n\n  final VoidCallback checkWin;\n\n  final Suit suit;\n  final List<Card> _cards = [];\n\n  //#region Pile API\n\n  bool get isFull => _cards.length == 13;"}
{"prompt": "Create a Flutter Flame game component that The Have fun button¶: But it is also time to have a look at the Ember Tutorial!", "completion": "import 'dart:math';\nimport 'dart:ui';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/events.dart';\nimport 'package:flutter/animation.dart';\n\nimport '../klondike_game.dart';\nimport '../klondike_world.dart';\nimport '../pile.dart';\nimport '../rank.dart';\nimport '../suit.dart';\nimport 'foundation_pile.dart';\nimport 'stock_pile.dart';\nimport 'tableau_pile.dart';\n\nclass Card extends PositionComponent\nwith DragCallbacks, TapCallbacks, HasWorldReference<KlondikeWorld> {\nCard(int intRank, int intSuit, {this.isBaseCard = false})\n: rank = Rank.fromInt(intRank),\nsuit = Suit.fromInt(intSuit),\nsuper(\nsize: KlondikeGame.cardSize,\n);\n\nfinal Rank rank;\nfinal Suit suit;\nPile? pile;\n\n// A Base Card is rendered in outline only and is NOT playable. It can be\n// added to the base of a Pile (e.g. the Stock Pile) to allow it to handle\n// taps and short drags (on an empty Pile) with the same behavior and\n// tolerances as for regular cards (see KlondikeGame.dragTolerance) and using\n// the same event-handling code, but with different handleTapUp() methods.\nfinal bool isBaseCard;\n\nbool _faceUp = false;\nbool _isAnimatedFlip = false;\nbool _isFaceUpView = false;\nbool _isDragging = false;\nVector2 _whereCardStarted = Vector2(0, 0);\n\nfinal List<Card> attachedCards = [];\n\nbool get isFaceUp => _faceUp;\nbool get isFaceDown => !_faceUp;\nvoid flip() {\nif (_isAnimatedFlip) {\n// Let the animation determine the FaceUp/FaceDown state.\n_faceUp = _isFaceUpView;\n} else {\n// No animation: flip and render the card immediately.\n_faceUp = !_faceUp;\n_isFaceUpView = _faceUp;\n}\n}\n\n@override\nString toString() => rank.label + suit.label; // e.g. \"Q♠\" or \"10♦\"\n\n//#region Rendering\n\n@override\nvoid render(Canvas canvas) {\nif (isBaseCard) {\n_renderBaseCard(canvas);\nreturn;\n}\nif (_isFaceUpView) {\n_renderFront(canvas);\n} else {\n_renderBack(canvas);\n}\n}\n\nstatic final Paint backBackgroundPaint = Paint()\n..color = const Color(0xff380c02);\nstatic final Paint backBorderPaint1 = Paint()\n..color = const Color(0xffdbaf58)\n..style = PaintingStyle.stroke\n..strokeWidth = 10;\nstatic final Paint backBorderPaint2 = Paint()\n..color = const Color(0x5CEF971B)\n..style = PaintingStyle.stroke\n..strokeWidth = 35;\nstatic final RRect cardRRect = RRect.fromRectAndRadius(\nKlondikeGame.cardSize.toRect(),\nconst Radius.circular(KlondikeGame.cardRadius),\n);\nstatic final RRect backRRectInner = cardRRect.deflate(40);\nstatic final Sprite flameSprite = klondikeSprite(1367, 6, 357, 501);\n\nvoid _renderBack(Canvas canvas) {\ncanvas.drawRRect(cardRRect, backBackgroundPaint);\ncanvas.drawRRect(cardRRect, backBorderPaint1);\ncanvas.drawRRect(backRRectInner, backBorderPaint2);\nflameSprite.render(canvas, position: size / 2, anchor: Anchor.center);\n}\n\nvoid _renderBaseCard(Canvas canvas) {\ncanvas.drawRRect(cardRRect, backBorderPaint1);\n}\n\nstatic final Paint frontBackgroundPaint = Paint()\n..color = const Color(0xff000000);\nstatic final Paint redBorderPaint = Paint()\n..color = const Color(0xffece8a3)\n..style = PaintingStyle.stroke\n..strokeWidth = 10;\nstatic final Paint blackBorderPaint = Paint()\n..color = const Color(0xff7ab2e8)\n..style = PaintingStyle.stroke\n..strokeWidth = 10;\nstatic final blueFilter = Paint()\n..colorFilter = const ColorFilter.mode(\nColor(0x880d8bff),\nBlendMode.srcATop,\n);\nstatic final Sprite redJack = klondikeSprite(81, 565, 562, 488);\nstatic final Sprite redQueen = klondikeSprite(717, 541, 486, 515);\nstatic final Sprite redKing = klondikeSprite(1305, 532, 407, 549);\nstatic final Sprite blackJack = klondikeSprite(81, 565, 562, 488)\n..paint = blueFilter;\nstatic final Sprite blackQueen = klondikeSprite(717, 541, 486, 515)\n..paint = blueFilter;\nstatic final Sprite blackKing = klondikeSprite(1305, 532, 407, 549)\n..paint = blueFilter;\n\nvoid _renderFront(Canvas canvas) {\ncanvas.drawRRect(cardRRect, frontBackgroundPaint);\ncanvas.drawRRect(\ncardRRect,\nsuit.isRed ? redBorderPaint : blackBorderPaint,\n);\n\nfinal rankSprite = suit.isBlack ? rank.blackSprite : rank.redSprite;\nfinal suitSprite = suit.sprite;\n_drawSprite(canvas, rankSprite, 0.1, 0.08);\n_drawSprite(canvas, suitSprite, 0.1, 0.18, scale: 0.5);\n_drawSprite(canvas, rankSprite, 0.1, 0.08, rotate: true);\n_drawSprite(canvas, suitSprite, 0.1, 0.18, scale: 0.5, rotate: true);\nswitch (rank.value) {\ncase 1:\n_drawSprite(canvas, suitSprite, 0.5, 0.5, scale: 2.5);\ncase 2:\n_drawSprite(canvas, suitSprite, 0.5, 0.25);\n_drawSprite(canvas, suitSprite, 0.5, 0.25, rotate: true);\ncase 3:\n_drawSprite(canvas, suitSprite, 0.5, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.5);\n_drawSprite(canvas, suitSprite, 0.5, 0.2, rotate: true);\ncase 4:\n_drawSprite(canvas, suitSprite, 0.3, 0.25);\n_drawSprite(canvas, suitSprite, 0.7, 0.25);\n_drawSprite(canvas, suitSprite, 0.3, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.25, rotate: true);\ncase 5:\n_drawSprite(canvas, suitSprite, 0.3, 0.25);\n_drawSprite(canvas, suitSprite, 0.7, 0.25);\n_drawSprite(canvas, suitSprite, 0.3, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.5, 0.5);\ncase 6:\n_drawSprite(canvas, suitSprite, 0.3, 0.25);\n_drawSprite(canvas, suitSprite, 0.7, 0.25);\n_drawSprite(canvas, suitSprite, 0.3, 0.5);\n_drawSprite(canvas, suitSprite, 0.7, 0.5);\n_drawSprite(canvas, suitSprite, 0.3, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.25, rotate: true);\ncase 7:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.35);\n_drawSprite(canvas, suitSprite, 0.3, 0.5);\n_drawSprite(canvas, suitSprite, 0.7, 0.5);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\ncase 8:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.35);\n_drawSprite(canvas, suitSprite, 0.3, 0.5);\n_drawSprite(canvas, suitSprite, 0.7, 0.5);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.5, 0.35, rotate: true);\ncase 9:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.3);\n_drawSprite(canvas, suitSprite, 0.3, 0.4);\n_drawSprite(canvas, suitSprite, 0.7, 0.4);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.3, 0.4, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.4, rotate: true);\ncase 10:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.3);\n_drawSprite(canvas, suitSprite, 0.3, 0.4);\n_drawSprite(canvas, suitSprite, 0.7, 0.4);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.5, 0.3, rotate: true);\n_drawSprite(canvas, suitSprite, 0.3, 0.4, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.4, rotate: true);\ncase 11:\n_drawSprite(canvas, suit.isRed ? redJack : blackJack, 0.5, 0.5);\ncase 12:\n_drawSprite(canvas, suit.isRed ? redQueen : blackQueen, 0.5, 0.5);\ncase 13:\n_drawSprite(canvas, suit.isRed ? redKing : blackKing, 0.5, 0.5);\n}\n}\n\nvoid _drawSprite(\nCanvas canvas,\nSprite sprite,\ndouble relativeX,\ndouble relativeY, {\ndouble scale = 1,\nbool rotate = false,\n}) {\nif (rotate) {\ncanvas.save();\ncanvas.translate(size.x / 2, size.y / 2);\ncanvas.rotate(pi);\ncanvas.translate(-size.x / 2, -size.y / 2);\n}\nsprite.render(\ncanvas,\nposition: Vector2(relativeX * size.x, relativeY * size.y),\nanchor: Anchor.center,\nsize: sprite.srcSize.scaled(scale),\n);\nif (rotate) {\ncanvas.restore();\n}\n}\n\n//#endregion\n\n//#region Card-Dragging\n\n@override\nvoid onTapCancel(TapCancelEvent event) {\nif (pile is StockPile) {\n_isDragging = false;\nhandleTapUp();\n}\n}\n\n@override\nvoid onDragStart(DragStartEvent event) {\nsuper.onDragStart(event);\nif (pile is StockPile) {\n_isDragging = false;\nreturn;\n}\n// Clone the position, else _whereCardStarted changes as the position does.\n_whereCardStarted = position.clone();\nattachedCards.clear();\nif (pile?.canMoveCard(this, MoveMethod.drag) ?? false) {\n_isDragging = true;\npriority = 100;\nif (pile is TableauPile) {\nfinal extraCards = (pile! as TableauPile).cardsOnTop(this);\nfor (final card in extraCards) {\ncard.priority = attachedCards.length + 101;\nattachedCards.add(card);\n}\n}\n}\n}\n\n@override\nvoid onDragUpdate(DragUpdateEvent event) {\nif (!_isDragging) {\nreturn;\n}\nfinal delta = event.localDelta;\nposition.add(delta);\nattachedCards.forEach((card) => card.position.add(delta));\n}\n\n@override\nvoid onDragEnd(DragEndEvent event) {\nsuper.onDragEnd(event);\nif (!_isDragging) {\nreturn;\n}\n_isDragging = false;\n\n// If short drag, return card to Pile and treat it as having been tapped.\nfinal shortDrag =\n(position - _whereCardStarted).length < KlondikeGame.dragTolerance;\nif (shortDrag && attachedCards.isEmpty) {\ndoMove(\n_whereCardStarted,\nonComplete: () {\npile!.returnCard(this);\n// Card moves to its Foundation Pile next, if valid, or it stays put.\nhandleTapUp();\n},\n);\nreturn;\n}\n\n// Find out what is under the center-point of this card when it is dropped.\nfinal dropPiles = parent!\n.componentsAtPoint(position + size / 2)\n.whereType<Pile>()\n.toList();\nif (dropPiles.isNotEmpty) {\nif (dropPiles.first.canAcceptCard(this)) {\n// Found a Pile: move card(s) the rest of the way onto it.\npile!.removeCard(this, MoveMethod.drag);\nif (dropPiles.first is TableauPile) {\n// Get TableauPile to handle positions, priorities and moves of cards.\n(dropPiles.first as TableauPile).dropCards(this, attachedCards);\nattachedCards.clear();\n} else {\n// Drop a single card onto a FoundationPile.\nfinal dropPosition = (dropPiles.first as FoundationPile).position;\ndoMove(\ndropPosition,\nonComplete: () {\ndropPiles.first.acquireCard(this);\n},\n);\n}\nreturn;\n}\n}\n\n// Invalid drop (middle of nowhere, invalid pile or invalid card for pile).\ndoMove(\n_whereCardStarted,\nonComplete: () {\npile!.returnCard(this);\n},\n);\nif (attachedCards.isNotEmpty) {\nattachedCards.forEach((card) {\nfinal offset = card.position - position;\ncard.doMove(\n_whereCardStarted + offset,\nonComplete: () {\npile!.returnCard(card);\n},\n);\n});\nattachedCards.clear();\n}\n}\n\n//#endregion\n\n//#region Card-Tapping\n\n// Tap a face-up card to make it auto-move and go out (if acceptable), but\n// if it is face-down and on the Stock Pile, pass the event to that pile.\n\n@override\nvoid onTapUp(TapUpEvent event) {\nhandleTapUp();\n}\n\nvoid handleTapUp() {\n// Can be called by onTapUp or after a very short (failed) drag-and-drop.\n// We need to be more user-friendly towards taps that include a short drag.\nif (pile?.canMoveCard(this, MoveMethod.tap) ?? false) {\nfinal suitIndex = suit.value;\nif (world.foundations[suitIndex].canAcceptCard(this)) {\npile!.removeCard(this, MoveMethod.tap);\ndoMove(\nworld.foundations[suitIndex].position,\nonComplete: () {\nworld.foundations[suitIndex].acquireCard(this);\n},\n);\n}\n} else if (pile is StockPile) {\nworld.stock.handleTapUp(this);\n}\n}\n\n//#endRegion\n\n//#region Effects\n\nvoid doMove(\nVector2 to, {\ndouble speed = 10.0,\ndouble start = 0.0,\nint startPriority = 100,\nCurve curve = Curves.easeOutQuad,\nVoidCallback? onComplete,\n}) {\nassert(speed > 0.0, 'Speed must be > 0 widths per second');\nfinal dt = (to - position).length / (speed * size.x);\nassert(dt > 0, 'Distance to move must be > 0');\nadd(\nCardMoveEffect(\nto,\nEffectController(duration: dt, startDelay: start, curve: curve),\ntransitPriority: startPriority,\nonComplete: () {\nonComplete?.call();\n},\n),\n);\n}\n\nvoid doMoveAndFlip(\nVector2 to, {\ndouble speed = 10.0,\ndouble start = 0.0,\nCurve curve = Curves.easeOutQuad,\nVoidCallback? whenDone,\n}) {\nassert(speed > 0.0, 'Speed must be > 0 widths per second');\nfinal dt = (to - position).length / (speed * size.x);\nassert(dt > 0, 'Distance to move must be > 0');\npriority = 100;\nadd(\nMoveToEffect(\nto,\nEffectController(duration: dt, startDelay: start, curve: curve),\nonComplete: () {\nturnFaceUp(\nonComplete: whenDone,\n);\n},\n),\n);\n}\n\nvoid turnFaceUp({\ndouble time = 0.3,\ndouble start = 0.0,\nVoidCallback? onComplete,\n}) {\nassert(!_isFaceUpView, 'Card must be face-down before turning face-up.');\nassert(time > 0.0, 'Time to turn card over must be > 0');\nassert(start >= 0.0, 'Start tim must be >= 0');\n_isAnimatedFlip = true;\nanchor = Anchor.topCenter;\nposition += Vector2(width / 2, 0);\npriority = 100;\nadd(\nScaleEffect.to(\nVector2(scale.x / 100, scale.y),\nEffectController(\nstartDelay: start,\ncurve: Curves.easeOutSine,\nduration: time / 2,\nonMax: () {\n_isFaceUpView = true;\n},\nreverseDuration: time / 2,\nonMin: () {\n_isAnimatedFlip = false;\n_faceUp = true;\nanchor = Anchor.topLeft;\nposition -= Vector2(width / 2, 0);\n},\n),\nonComplete: () {\nonComplete?.call();\n},\n),\n);\n}\n\n//#endregion\n}\n\nclass CardMoveEffect extends MoveToEffect {\nCardMoveEffect(\nsuper.destination,\nsuper.controller, {\nsuper.onComplete,\nthis.transitPriority = 100,\n});\n\nfinal int transitPriority;\n\n@override\nvoid onStart() {\nsuper.onStart(); // Flame connects MoveToEffect to EffectController.\nparent?.priority = transitPriority;\n}\n}"}
{"prompt": "Show me how to implement The Have fun button¶: But it is also time to have a look at the Ember Tutorial! using Flutter Flame", "completion": "import 'dart:math';\nimport 'dart:ui';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/events.dart';\nimport 'package:flutter/animation.dart';\n\nimport '../klondike_game.dart';\nimport '../klondike_world.dart';\nimport '../pile.dart';\nimport '../rank.dart';\nimport '../suit.dart';\nimport 'foundation_pile.dart';\nimport 'stock_pile.dart';\nimport 'tableau_pile.dart';\n\nclass Card extends PositionComponent\nwith DragCallbacks, TapCallbacks, HasWorldReference<KlondikeWorld> {\nCard(int intRank, int intSuit, {this.isBaseCard = false})\n: rank = Rank.fromInt(intRank),\nsuit = Suit.fromInt(intSuit),\nsuper(\nsize: KlondikeGame.cardSize,\n);\n\nfinal Rank rank;\nfinal Suit suit;\nPile? pile;\n\n// A Base Card is rendered in outline only and is NOT playable. It can be\n// added to the base of a Pile (e.g. the Stock Pile) to allow it to handle\n// taps and short drags (on an empty Pile) with the same behavior and\n// tolerances as for regular cards (see KlondikeGame.dragTolerance) and using\n// the same event-handling code, but with different handleTapUp() methods.\nfinal bool isBaseCard;\n\nbool _faceUp = false;\nbool _isAnimatedFlip = false;\nbool _isFaceUpView = false;\nbool _isDragging = false;\nVector2 _whereCardStarted = Vector2(0, 0);\n\nfinal List<Card> attachedCards = [];\n\nbool get isFaceUp => _faceUp;\nbool get isFaceDown => !_faceUp;\nvoid flip() {\nif (_isAnimatedFlip) {\n// Let the animation determine the FaceUp/FaceDown state.\n_faceUp = _isFaceUpView;\n} else {\n// No animation: flip and render the card immediately.\n_faceUp = !_faceUp;\n_isFaceUpView = _faceUp;\n}\n}\n\n@override\nString toString() => rank.label + suit.label; // e.g. \"Q♠\" or \"10♦\"\n\n//#region Rendering\n\n@override\nvoid render(Canvas canvas) {\nif (isBaseCard) {\n_renderBaseCard(canvas);\nreturn;\n}\nif (_isFaceUpView) {\n_renderFront(canvas);\n} else {\n_renderBack(canvas);\n}\n}\n\nstatic final Paint backBackgroundPaint = Paint()\n..color = const Color(0xff380c02);\nstatic final Paint backBorderPaint1 = Paint()\n..color = const Color(0xffdbaf58)\n..style = PaintingStyle.stroke\n..strokeWidth = 10;\nstatic final Paint backBorderPaint2 = Paint()\n..color = const Color(0x5CEF971B)\n..style = PaintingStyle.stroke\n..strokeWidth = 35;\nstatic final RRect cardRRect = RRect.fromRectAndRadius(\nKlondikeGame.cardSize.toRect(),\nconst Radius.circular(KlondikeGame.cardRadius),\n);\nstatic final RRect backRRectInner = cardRRect.deflate(40);\nstatic final Sprite flameSprite = klondikeSprite(1367, 6, 357, 501);\n\nvoid _renderBack(Canvas canvas) {\ncanvas.drawRRect(cardRRect, backBackgroundPaint);\ncanvas.drawRRect(cardRRect, backBorderPaint1);\ncanvas.drawRRect(backRRectInner, backBorderPaint2);\nflameSprite.render(canvas, position: size / 2, anchor: Anchor.center);\n}\n\nvoid _renderBaseCard(Canvas canvas) {\ncanvas.drawRRect(cardRRect, backBorderPaint1);\n}\n\nstatic final Paint frontBackgroundPaint = Paint()\n..color = const Color(0xff000000);\nstatic final Paint redBorderPaint = Paint()\n..color = const Color(0xffece8a3)\n..style = PaintingStyle.stroke\n..strokeWidth = 10;\nstatic final Paint blackBorderPaint = Paint()\n..color = const Color(0xff7ab2e8)\n..style = PaintingStyle.stroke\n..strokeWidth = 10;\nstatic final blueFilter = Paint()\n..colorFilter = const ColorFilter.mode(\nColor(0x880d8bff),\nBlendMode.srcATop,\n);\nstatic final Sprite redJack = klondikeSprite(81, 565, 562, 488);\nstatic final Sprite redQueen = klondikeSprite(717, 541, 486, 515);\nstatic final Sprite redKing = klondikeSprite(1305, 532, 407, 549);\nstatic final Sprite blackJack = klondikeSprite(81, 565, 562, 488)\n..paint = blueFilter;\nstatic final Sprite blackQueen = klondikeSprite(717, 541, 486, 515)\n..paint = blueFilter;\nstatic final Sprite blackKing = klondikeSprite(1305, 532, 407, 549)\n..paint = blueFilter;\n\nvoid _renderFront(Canvas canvas) {\ncanvas.drawRRect(cardRRect, frontBackgroundPaint);\ncanvas.drawRRect(\ncardRRect,\nsuit.isRed ? redBorderPaint : blackBorderPaint,\n);\n\nfinal rankSprite = suit.isBlack ? rank.blackSprite : rank.redSprite;\nfinal suitSprite = suit.sprite;\n_drawSprite(canvas, rankSprite, 0.1, 0.08);\n_drawSprite(canvas, suitSprite, 0.1, 0.18, scale: 0.5);\n_drawSprite(canvas, rankSprite, 0.1, 0.08, rotate: true);\n_drawSprite(canvas, suitSprite, 0.1, 0.18, scale: 0.5, rotate: true);\nswitch (rank.value) {\ncase 1:\n_drawSprite(canvas, suitSprite, 0.5, 0.5, scale: 2.5);\ncase 2:\n_drawSprite(canvas, suitSprite, 0.5, 0.25);\n_drawSprite(canvas, suitSprite, 0.5, 0.25, rotate: true);\ncase 3:\n_drawSprite(canvas, suitSprite, 0.5, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.5);\n_drawSprite(canvas, suitSprite, 0.5, 0.2, rotate: true);\ncase 4:\n_drawSprite(canvas, suitSprite, 0.3, 0.25);\n_drawSprite(canvas, suitSprite, 0.7, 0.25);\n_drawSprite(canvas, suitSprite, 0.3, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.25, rotate: true);\ncase 5:\n_drawSprite(canvas, suitSprite, 0.3, 0.25);\n_drawSprite(canvas, suitSprite, 0.7, 0.25);\n_drawSprite(canvas, suitSprite, 0.3, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.5, 0.5);\ncase 6:\n_drawSprite(canvas, suitSprite, 0.3, 0.25);\n_drawSprite(canvas, suitSprite, 0.7, 0.25);\n_drawSprite(canvas, suitSprite, 0.3, 0.5);\n_drawSprite(canvas, suitSprite, 0.7, 0.5);\n_drawSprite(canvas, suitSprite, 0.3, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.25, rotate: true);\ncase 7:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.35);\n_drawSprite(canvas, suitSprite, 0.3, 0.5);\n_drawSprite(canvas, suitSprite, 0.7, 0.5);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\ncase 8:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.35);\n_drawSprite(canvas, suitSprite, 0.3, 0.5);\n_drawSprite(canvas, suitSprite, 0.7, 0.5);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.5, 0.35, rotate: true);\ncase 9:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.3);\n_drawSprite(canvas, suitSprite, 0.3, 0.4);\n_drawSprite(canvas, suitSprite, 0.7, 0.4);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.3, 0.4, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.4, rotate: true);\ncase 10:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.3);\n_drawSprite(canvas, suitSprite, 0.3, 0.4);\n_drawSprite(canvas, suitSprite, 0.7, 0.4);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.5, 0.3, rotate: true);\n_drawSprite(canvas, suitSprite, 0.3, 0.4, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.4, rotate: true);\ncase 11:\n_drawSprite(canvas, suit.isRed ? redJack : blackJack, 0.5, 0.5);\ncase 12:\n_drawSprite(canvas, suit.isRed ? redQueen : blackQueen, 0.5, 0.5);\ncase 13:\n_drawSprite(canvas, suit.isRed ? redKing : blackKing, 0.5, 0.5);\n}\n}\n\nvoid _drawSprite(\nCanvas canvas,\nSprite sprite,\ndouble relativeX,\ndouble relativeY, {\ndouble scale = 1,\nbool rotate = false,\n}) {\nif (rotate) {\ncanvas.save();\ncanvas.translate(size.x / 2, size.y / 2);\ncanvas.rotate(pi);\ncanvas.translate(-size.x / 2, -size.y / 2);\n}\nsprite.render(\ncanvas,\nposition: Vector2(relativeX * size.x, relativeY * size.y),\nanchor: Anchor.center,\nsize: sprite.srcSize.scaled(scale),\n);\nif (rotate) {\ncanvas.restore();\n}\n}\n\n//#endregion\n\n//#region Card-Dragging\n\n@override\nvoid onTapCancel(TapCancelEvent event) {\nif (pile is StockPile) {\n_isDragging = false;\nhandleTapUp();\n}\n}\n\n@override\nvoid onDragStart(DragStartEvent event) {\nsuper.onDragStart(event);\nif (pile is StockPile) {\n_isDragging = false;\nreturn;\n}\n// Clone the position, else _whereCardStarted changes as the position does.\n_whereCardStarted = position.clone();\nattachedCards.clear();\nif (pile?.canMoveCard(this, MoveMethod.drag) ?? false) {\n_isDragging = true;\npriority = 100;\nif (pile is TableauPile) {\nfinal extraCards = (pile! as TableauPile).cardsOnTop(this);\nfor (final card in extraCards) {\ncard.priority = attachedCards.length + 101;\nattachedCards.add(card);\n}\n}\n}\n}\n\n@override\nvoid onDragUpdate(DragUpdateEvent event) {\nif (!_isDragging) {\nreturn;\n}\nfinal delta = event.localDelta;\nposition.add(delta);\nattachedCards.forEach((card) => card.position.add(delta));\n}\n\n@override\nvoid onDragEnd(DragEndEvent event) {\nsuper.onDragEnd(event);\nif (!_isDragging) {\nreturn;\n}\n_isDragging = false;\n\n// If short drag, return card to Pile and treat it as having been tapped.\nfinal shortDrag =\n(position - _whereCardStarted).length < KlondikeGame.dragTolerance;\nif (shortDrag && attachedCards.isEmpty) {\ndoMove(\n_whereCardStarted,\nonComplete: () {\npile!.returnCard(this);\n// Card moves to its Foundation Pile next, if valid, or it stays put.\nhandleTapUp();\n},\n);\nreturn;\n}\n\n// Find out what is under the center-point of this card when it is dropped.\nfinal dropPiles = parent!\n.componentsAtPoint(position + size / 2)\n.whereType<Pile>()\n.toList();\nif (dropPiles.isNotEmpty) {\nif (dropPiles.first.canAcceptCard(this)) {\n// Found a Pile: move card(s) the rest of the way onto it.\npile!.removeCard(this, MoveMethod.drag);\nif (dropPiles.first is TableauPile) {\n// Get TableauPile to handle positions, priorities and moves of cards.\n(dropPiles.first as TableauPile).dropCards(this, attachedCards);\nattachedCards.clear();\n} else {\n// Drop a single card onto a FoundationPile.\nfinal dropPosition = (dropPiles.first as FoundationPile).position;\ndoMove(\ndropPosition,\nonComplete: () {\ndropPiles.first.acquireCard(this);\n},\n);\n}\nreturn;\n}\n}\n\n// Invalid drop (middle of nowhere, invalid pile or invalid card for pile).\ndoMove(\n_whereCardStarted,\nonComplete: () {\npile!.returnCard(this);\n},\n);\nif (attachedCards.isNotEmpty) {\nattachedCards.forEach((card) {\nfinal offset = card.position - position;\ncard.doMove(\n_whereCardStarted + offset,\nonComplete: () {\npile!.returnCard(card);\n},\n);\n});\nattachedCards.clear();\n}\n}\n\n//#endregion\n\n//#region Card-Tapping\n\n// Tap a face-up card to make it auto-move and go out (if acceptable), but\n// if it is face-down and on the Stock Pile, pass the event to that pile.\n\n@override\nvoid onTapUp(TapUpEvent event) {\nhandleTapUp();\n}\n\nvoid handleTapUp() {\n// Can be called by onTapUp or after a very short (failed) drag-and-drop.\n// We need to be more user-friendly towards taps that include a short drag.\nif (pile?.canMoveCard(this, MoveMethod.tap) ?? false) {\nfinal suitIndex = suit.value;\nif (world.foundations[suitIndex].canAcceptCard(this)) {\npile!.removeCard(this, MoveMethod.tap);\ndoMove(\nworld.foundations[suitIndex].position,\nonComplete: () {\nworld.foundations[suitIndex].acquireCard(this);\n},\n);\n}\n} else if (pile is StockPile) {\nworld.stock.handleTapUp(this);\n}\n}\n\n//#endRegion\n\n//#region Effects\n\nvoid doMove(\nVector2 to, {\ndouble speed = 10.0,\ndouble start = 0.0,\nint startPriority = 100,\nCurve curve = Curves.easeOutQuad,\nVoidCallback? onComplete,\n}) {\nassert(speed > 0.0, 'Speed must be > 0 widths per second');\nfinal dt = (to - position).length / (speed * size.x);\nassert(dt > 0, 'Distance to move must be > 0');\nadd(\nCardMoveEffect(\nto,\nEffectController(duration: dt, startDelay: start, curve: curve),\ntransitPriority: startPriority,\nonComplete: () {\nonComplete?.call();\n},\n),\n);\n}\n\nvoid doMoveAndFlip(\nVector2 to, {\ndouble speed = 10.0,\ndouble start = 0.0,\nCurve curve = Curves.easeOutQuad,\nVoidCallback? whenDone,\n}) {\nassert(speed > 0.0, 'Speed must be > 0 widths per second');\nfinal dt = (to - position).length / (speed * size.x);\nassert(dt > 0, 'Distance to move must be > 0');\npriority = 100;\nadd(\nMoveToEffect(\nto,\nEffectController(duration: dt, startDelay: start, curve: curve),\nonComplete: () {\nturnFaceUp(\nonComplete: whenDone,\n);\n},\n),\n);\n}\n\nvoid turnFaceUp({\ndouble time = 0.3,\ndouble start = 0.0,\nVoidCallback? onComplete,\n}) {\nassert(!_isFaceUpView, 'Card must be face-down before turning face-up.');\nassert(time > 0.0, 'Time to turn card over must be > 0');\nassert(start >= 0.0, 'Start tim must be >= 0');\n_isAnimatedFlip = true;\nanchor = Anchor.topCenter;\nposition += Vector2(width / 2, 0);\npriority = 100;\nadd(\nScaleEffect.to(\nVector2(scale.x / 100, scale.y),\nEffectController(\nstartDelay: start,\ncurve: Curves.easeOutSine,\nduration: time / 2,\nonMax: () {\n_isFaceUpView = true;\n},\nreverseDuration: time / 2,\nonMin: () {\n_isAnimatedFlip = false;\n_faceUp = true;\nanchor = Anchor.topLeft;\nposition -= Vector2(width / 2, 0);\n},\n),\nonComplete: () {\nonComplete?.call();\n},\n),\n);\n}\n\n//#endregion\n}\n\nclass CardMoveEffect extends MoveToEffect {\nCardMoveEffect(\nsuper.destination,\nsuper.controller, {\nsuper.onComplete,\nthis.transitPriority = 100,\n});\n\nfinal int transitPriority;\n\n@override\nvoid onStart() {\nsuper.onStart(); // Flame connects MoveToEffect to EffectController.\nparent?.priority = transitPriority;\n}\n}"}
{"prompt": "Write Flutter Flame code to The Have fun button¶: But it is also time to have a look at the Ember Tutorial!", "completion": "import 'dart:math';\nimport 'dart:ui';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/events.dart';\nimport 'package:flutter/animation.dart';\n\nimport '../klondike_game.dart';\nimport '../klondike_world.dart';\nimport '../pile.dart';\nimport '../rank.dart';\nimport '../suit.dart';\nimport 'foundation_pile.dart';\nimport 'stock_pile.dart';\nimport 'tableau_pile.dart';\n\nclass Card extends PositionComponent\nwith DragCallbacks, TapCallbacks, HasWorldReference<KlondikeWorld> {\nCard(int intRank, int intSuit, {this.isBaseCard = false})\n: rank = Rank.fromInt(intRank),\nsuit = Suit.fromInt(intSuit),\nsuper(\nsize: KlondikeGame.cardSize,\n);\n\nfinal Rank rank;\nfinal Suit suit;\nPile? pile;\n\n// A Base Card is rendered in outline only and is NOT playable. It can be\n// added to the base of a Pile (e.g. the Stock Pile) to allow it to handle\n// taps and short drags (on an empty Pile) with the same behavior and\n// tolerances as for regular cards (see KlondikeGame.dragTolerance) and using\n// the same event-handling code, but with different handleTapUp() methods.\nfinal bool isBaseCard;\n\nbool _faceUp = false;\nbool _isAnimatedFlip = false;\nbool _isFaceUpView = false;\nbool _isDragging = false;\nVector2 _whereCardStarted = Vector2(0, 0);\n\nfinal List<Card> attachedCards = [];\n\nbool get isFaceUp => _faceUp;\nbool get isFaceDown => !_faceUp;\nvoid flip() {\nif (_isAnimatedFlip) {\n// Let the animation determine the FaceUp/FaceDown state.\n_faceUp = _isFaceUpView;\n} else {\n// No animation: flip and render the card immediately.\n_faceUp = !_faceUp;\n_isFaceUpView = _faceUp;\n}\n}\n\n@override\nString toString() => rank.label + suit.label; // e.g. \"Q♠\" or \"10♦\"\n\n//#region Rendering\n\n@override\nvoid render(Canvas canvas) {\nif (isBaseCard) {\n_renderBaseCard(canvas);\nreturn;\n}\nif (_isFaceUpView) {\n_renderFront(canvas);\n} else {\n_renderBack(canvas);\n}\n}\n\nstatic final Paint backBackgroundPaint = Paint()\n..color = const Color(0xff380c02);\nstatic final Paint backBorderPaint1 = Paint()\n..color = const Color(0xffdbaf58)\n..style = PaintingStyle.stroke\n..strokeWidth = 10;\nstatic final Paint backBorderPaint2 = Paint()\n..color = const Color(0x5CEF971B)\n..style = PaintingStyle.stroke\n..strokeWidth = 35;\nstatic final RRect cardRRect = RRect.fromRectAndRadius(\nKlondikeGame.cardSize.toRect(),\nconst Radius.circular(KlondikeGame.cardRadius),\n);\nstatic final RRect backRRectInner = cardRRect.deflate(40);\nstatic final Sprite flameSprite = klondikeSprite(1367, 6, 357, 501);\n\nvoid _renderBack(Canvas canvas) {\ncanvas.drawRRect(cardRRect, backBackgroundPaint);\ncanvas.drawRRect(cardRRect, backBorderPaint1);\ncanvas.drawRRect(backRRectInner, backBorderPaint2);\nflameSprite.render(canvas, position: size / 2, anchor: Anchor.center);\n}\n\nvoid _renderBaseCard(Canvas canvas) {\ncanvas.drawRRect(cardRRect, backBorderPaint1);\n}\n\nstatic final Paint frontBackgroundPaint = Paint()\n..color = const Color(0xff000000);\nstatic final Paint redBorderPaint = Paint()\n..color = const Color(0xffece8a3)\n..style = PaintingStyle.stroke\n..strokeWidth = 10;\nstatic final Paint blackBorderPaint = Paint()\n..color = const Color(0xff7ab2e8)\n..style = PaintingStyle.stroke\n..strokeWidth = 10;\nstatic final blueFilter = Paint()\n..colorFilter = const ColorFilter.mode(\nColor(0x880d8bff),\nBlendMode.srcATop,\n);\nstatic final Sprite redJack = klondikeSprite(81, 565, 562, 488);\nstatic final Sprite redQueen = klondikeSprite(717, 541, 486, 515);\nstatic final Sprite redKing = klondikeSprite(1305, 532, 407, 549);\nstatic final Sprite blackJack = klondikeSprite(81, 565, 562, 488)\n..paint = blueFilter;\nstatic final Sprite blackQueen = klondikeSprite(717, 541, 486, 515)\n..paint = blueFilter;\nstatic final Sprite blackKing = klondikeSprite(1305, 532, 407, 549)\n..paint = blueFilter;\n\nvoid _renderFront(Canvas canvas) {\ncanvas.drawRRect(cardRRect, frontBackgroundPaint);\ncanvas.drawRRect(\ncardRRect,\nsuit.isRed ? redBorderPaint : blackBorderPaint,\n);\n\nfinal rankSprite = suit.isBlack ? rank.blackSprite : rank.redSprite;\nfinal suitSprite = suit.sprite;\n_drawSprite(canvas, rankSprite, 0.1, 0.08);\n_drawSprite(canvas, suitSprite, 0.1, 0.18, scale: 0.5);\n_drawSprite(canvas, rankSprite, 0.1, 0.08, rotate: true);\n_drawSprite(canvas, suitSprite, 0.1, 0.18, scale: 0.5, rotate: true);\nswitch (rank.value) {\ncase 1:\n_drawSprite(canvas, suitSprite, 0.5, 0.5, scale: 2.5);\ncase 2:\n_drawSprite(canvas, suitSprite, 0.5, 0.25);\n_drawSprite(canvas, suitSprite, 0.5, 0.25, rotate: true);\ncase 3:\n_drawSprite(canvas, suitSprite, 0.5, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.5);\n_drawSprite(canvas, suitSprite, 0.5, 0.2, rotate: true);\ncase 4:\n_drawSprite(canvas, suitSprite, 0.3, 0.25);\n_drawSprite(canvas, suitSprite, 0.7, 0.25);\n_drawSprite(canvas, suitSprite, 0.3, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.25, rotate: true);\ncase 5:\n_drawSprite(canvas, suitSprite, 0.3, 0.25);\n_drawSprite(canvas, suitSprite, 0.7, 0.25);\n_drawSprite(canvas, suitSprite, 0.3, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.5, 0.5);\ncase 6:\n_drawSprite(canvas, suitSprite, 0.3, 0.25);\n_drawSprite(canvas, suitSprite, 0.7, 0.25);\n_drawSprite(canvas, suitSprite, 0.3, 0.5);\n_drawSprite(canvas, suitSprite, 0.7, 0.5);\n_drawSprite(canvas, suitSprite, 0.3, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.25, rotate: true);\ncase 7:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.35);\n_drawSprite(canvas, suitSprite, 0.3, 0.5);\n_drawSprite(canvas, suitSprite, 0.7, 0.5);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\ncase 8:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.35);\n_drawSprite(canvas, suitSprite, 0.3, 0.5);\n_drawSprite(canvas, suitSprite, 0.7, 0.5);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.5, 0.35, rotate: true);\ncase 9:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.3);\n_drawSprite(canvas, suitSprite, 0.3, 0.4);\n_drawSprite(canvas, suitSprite, 0.7, 0.4);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.3, 0.4, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.4, rotate: true);\ncase 10:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.3);\n_drawSprite(canvas, suitSprite, 0.3, 0.4);\n_drawSprite(canvas, suitSprite, 0.7, 0.4);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.5, 0.3, rotate: true);\n_drawSprite(canvas, suitSprite, 0.3, 0.4, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.4, rotate: true);\ncase 11:\n_drawSprite(canvas, suit.isRed ? redJack : blackJack, 0.5, 0.5);\ncase 12:\n_drawSprite(canvas, suit.isRed ? redQueen : blackQueen, 0.5, 0.5);\ncase 13:\n_drawSprite(canvas, suit.isRed ? redKing : blackKing, 0.5, 0.5);\n}\n}\n\nvoid _drawSprite(\nCanvas canvas,\nSprite sprite,\ndouble relativeX,\ndouble relativeY, {\ndouble scale = 1,\nbool rotate = false,\n}) {\nif (rotate) {\ncanvas.save();\ncanvas.translate(size.x / 2, size.y / 2);\ncanvas.rotate(pi);\ncanvas.translate(-size.x / 2, -size.y / 2);\n}\nsprite.render(\ncanvas,\nposition: Vector2(relativeX * size.x, relativeY * size.y),\nanchor: Anchor.center,\nsize: sprite.srcSize.scaled(scale),\n);\nif (rotate) {\ncanvas.restore();\n}\n}\n\n//#endregion\n\n//#region Card-Dragging\n\n@override\nvoid onTapCancel(TapCancelEvent event) {\nif (pile is StockPile) {\n_isDragging = false;\nhandleTapUp();\n}\n}\n\n@override\nvoid onDragStart(DragStartEvent event) {\nsuper.onDragStart(event);\nif (pile is StockPile) {\n_isDragging = false;\nreturn;\n}\n// Clone the position, else _whereCardStarted changes as the position does.\n_whereCardStarted = position.clone();\nattachedCards.clear();\nif (pile?.canMoveCard(this, MoveMethod.drag) ?? false) {\n_isDragging = true;\npriority = 100;\nif (pile is TableauPile) {\nfinal extraCards = (pile! as TableauPile).cardsOnTop(this);\nfor (final card in extraCards) {\ncard.priority = attachedCards.length + 101;\nattachedCards.add(card);\n}\n}\n}\n}\n\n@override\nvoid onDragUpdate(DragUpdateEvent event) {\nif (!_isDragging) {\nreturn;\n}\nfinal delta = event.localDelta;\nposition.add(delta);\nattachedCards.forEach((card) => card.position.add(delta));\n}\n\n@override\nvoid onDragEnd(DragEndEvent event) {\nsuper.onDragEnd(event);\nif (!_isDragging) {\nreturn;\n}\n_isDragging = false;\n\n// If short drag, return card to Pile and treat it as having been tapped.\nfinal shortDrag =\n(position - _whereCardStarted).length < KlondikeGame.dragTolerance;\nif (shortDrag && attachedCards.isEmpty) {\ndoMove(\n_whereCardStarted,\nonComplete: () {\npile!.returnCard(this);\n// Card moves to its Foundation Pile next, if valid, or it stays put.\nhandleTapUp();\n},\n);\nreturn;\n}\n\n// Find out what is under the center-point of this card when it is dropped.\nfinal dropPiles = parent!\n.componentsAtPoint(position + size / 2)\n.whereType<Pile>()\n.toList();\nif (dropPiles.isNotEmpty) {\nif (dropPiles.first.canAcceptCard(this)) {\n// Found a Pile: move card(s) the rest of the way onto it.\npile!.removeCard(this, MoveMethod.drag);\nif (dropPiles.first is TableauPile) {\n// Get TableauPile to handle positions, priorities and moves of cards.\n(dropPiles.first as TableauPile).dropCards(this, attachedCards);\nattachedCards.clear();\n} else {\n// Drop a single card onto a FoundationPile.\nfinal dropPosition = (dropPiles.first as FoundationPile).position;\ndoMove(\ndropPosition,\nonComplete: () {\ndropPiles.first.acquireCard(this);\n},\n);\n}\nreturn;\n}\n}\n\n// Invalid drop (middle of nowhere, invalid pile or invalid card for pile).\ndoMove(\n_whereCardStarted,\nonComplete: () {\npile!.returnCard(this);\n},\n);\nif (attachedCards.isNotEmpty) {\nattachedCards.forEach((card) {\nfinal offset = card.position - position;\ncard.doMove(\n_whereCardStarted + offset,\nonComplete: () {\npile!.returnCard(card);\n},\n);\n});\nattachedCards.clear();\n}\n}\n\n//#endregion\n\n//#region Card-Tapping\n\n// Tap a face-up card to make it auto-move and go out (if acceptable), but\n// if it is face-down and on the Stock Pile, pass the event to that pile.\n\n@override\nvoid onTapUp(TapUpEvent event) {\nhandleTapUp();\n}\n\nvoid handleTapUp() {\n// Can be called by onTapUp or after a very short (failed) drag-and-drop.\n// We need to be more user-friendly towards taps that include a short drag.\nif (pile?.canMoveCard(this, MoveMethod.tap) ?? false) {\nfinal suitIndex = suit.value;\nif (world.foundations[suitIndex].canAcceptCard(this)) {\npile!.removeCard(this, MoveMethod.tap);\ndoMove(\nworld.foundations[suitIndex].position,\nonComplete: () {\nworld.foundations[suitIndex].acquireCard(this);\n},\n);\n}\n} else if (pile is StockPile) {\nworld.stock.handleTapUp(this);\n}\n}\n\n//#endRegion\n\n//#region Effects\n\nvoid doMove(\nVector2 to, {\ndouble speed = 10.0,\ndouble start = 0.0,\nint startPriority = 100,\nCurve curve = Curves.easeOutQuad,\nVoidCallback? onComplete,\n}) {\nassert(speed > 0.0, 'Speed must be > 0 widths per second');\nfinal dt = (to - position).length / (speed * size.x);\nassert(dt > 0, 'Distance to move must be > 0');\nadd(\nCardMoveEffect(\nto,\nEffectController(duration: dt, startDelay: start, curve: curve),\ntransitPriority: startPriority,\nonComplete: () {\nonComplete?.call();\n},\n),\n);\n}\n\nvoid doMoveAndFlip(\nVector2 to, {\ndouble speed = 10.0,\ndouble start = 0.0,\nCurve curve = Curves.easeOutQuad,\nVoidCallback? whenDone,\n}) {\nassert(speed > 0.0, 'Speed must be > 0 widths per second');\nfinal dt = (to - position).length / (speed * size.x);\nassert(dt > 0, 'Distance to move must be > 0');\npriority = 100;\nadd(\nMoveToEffect(\nto,\nEffectController(duration: dt, startDelay: start, curve: curve),\nonComplete: () {\nturnFaceUp(\nonComplete: whenDone,\n);\n},\n),\n);\n}\n\nvoid turnFaceUp({\ndouble time = 0.3,\ndouble start = 0.0,\nVoidCallback? onComplete,\n}) {\nassert(!_isFaceUpView, 'Card must be face-down before turning face-up.');\nassert(time > 0.0, 'Time to turn card over must be > 0');\nassert(start >= 0.0, 'Start tim must be >= 0');\n_isAnimatedFlip = true;\nanchor = Anchor.topCenter;\nposition += Vector2(width / 2, 0);\npriority = 100;\nadd(\nScaleEffect.to(\nVector2(scale.x / 100, scale.y),\nEffectController(\nstartDelay: start,\ncurve: Curves.easeOutSine,\nduration: time / 2,\nonMax: () {\n_isFaceUpView = true;\n},\nreverseDuration: time / 2,\nonMin: () {\n_isAnimatedFlip = false;\n_faceUp = true;\nanchor = Anchor.topLeft;\nposition -= Vector2(width / 2, 0);\n},\n),\nonComplete: () {\nonComplete?.call();\n},\n),\n);\n}\n\n//#endregion\n}\n\nclass CardMoveEffect extends MoveToEffect {\nCardMoveEffect(\nsuper.destination,\nsuper.controller, {\nsuper.onComplete,\nthis.transitPriority = 100,\n});\n\nfinal int transitPriority;\n\n@override\nvoid onStart() {\nsuper.onStart(); // Flame connects MoveToEffect to EffectController.\nparent?.priority = transitPriority;\n}\n}"}
{"prompt": "Create a Flutter Flame game component that The Have fun button¶: But it is also time to have a look at the Ember Tutorial!", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/input.dart';\nimport 'package:flame/text.dart';\nimport 'package:flutter/material.dart';\n\nclass FlatButton extends ButtonComponent {\nFlatButton(\nString text, {\nsuper.size,\nsuper.onReleased,\nsuper.position,\n}) : super(\nbutton: ButtonBackground(const Color(0xffece8a3)),\nbuttonDown: ButtonBackground(Colors.red),\nchildren: [\nTextComponent(\ntext: text,\ntextRenderer: TextPaint(\nstyle: TextStyle(\nfontSize: 0.5 * size!.y,\nfontWeight: FontWeight.bold,\ncolor: const Color(0xffdbaf58),\n),\n),\nposition: size / 2.0,\nanchor: Anchor.center,\n),\n],\nanchor: Anchor.center,\n);\n}\n\nclass ButtonBackground extends PositionComponent with HasAncestor<FlatButton> {\nfinal _paint = Paint()..style = PaintingStyle.stroke;\n\nlate double cornerRadius;\n\nButtonBackground(Color color) {\n_paint.color = color;\n}\n\n@override\nvoid onMount() {\nsuper.onMount();\nsize = ancestor.size;\ncornerRadius = 0.3 * size.y;\n_paint.strokeWidth = 0.05 * size.y;\n}\n\nlate final _background = RRect.fromRectAndRadius(\nsize.toRect(),\nRadius.circular(cornerRadius),\n);\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRRect(_background, _paint);\n}\n}"}
{"prompt": "Show me how to implement The Have fun button¶: But it is also time to have a look at the Ember Tutorial! using Flutter Flame", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/input.dart';\nimport 'package:flame/text.dart';\nimport 'package:flutter/material.dart';\n\nclass FlatButton extends ButtonComponent {\nFlatButton(\nString text, {\nsuper.size,\nsuper.onReleased,\nsuper.position,\n}) : super(\nbutton: ButtonBackground(const Color(0xffece8a3)),\nbuttonDown: ButtonBackground(Colors.red),\nchildren: [\nTextComponent(\ntext: text,\ntextRenderer: TextPaint(\nstyle: TextStyle(\nfontSize: 0.5 * size!.y,\nfontWeight: FontWeight.bold,\ncolor: const Color(0xffdbaf58),\n),\n),\nposition: size / 2.0,\nanchor: Anchor.center,\n),\n],\nanchor: Anchor.center,\n);\n}\n\nclass ButtonBackground extends PositionComponent with HasAncestor<FlatButton> {\nfinal _paint = Paint()..style = PaintingStyle.stroke;\n\nlate double cornerRadius;\n\nButtonBackground(Color color) {\n_paint.color = color;\n}\n\n@override\nvoid onMount() {\nsuper.onMount();\nsize = ancestor.size;\ncornerRadius = 0.3 * size.y;\n_paint.strokeWidth = 0.05 * size.y;\n}\n\nlate final _background = RRect.fromRectAndRadius(\nsize.toRect(),\nRadius.circular(cornerRadius),\n);\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRRect(_background, _paint);\n}\n}"}
{"prompt": "Write Flutter Flame code to The Have fun button¶: But it is also time to have a look at the Ember Tutorial!", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/input.dart';\nimport 'package:flame/text.dart';\nimport 'package:flutter/material.dart';\n\nclass FlatButton extends ButtonComponent {\nFlatButton(\nString text, {\nsuper.size,\nsuper.onReleased,\nsuper.position,\n}) : super(\nbutton: ButtonBackground(const Color(0xffece8a3)),\nbuttonDown: ButtonBackground(Colors.red),\nchildren: [\nTextComponent(\ntext: text,\ntextRenderer: TextPaint(\nstyle: TextStyle(\nfontSize: 0.5 * size!.y,\nfontWeight: FontWeight.bold,\ncolor: const Color(0xffdbaf58),\n),\n),\nposition: size / 2.0,\nanchor: Anchor.center,\n),\n],\nanchor: Anchor.center,\n);\n}\n\nclass ButtonBackground extends PositionComponent with HasAncestor<FlatButton> {\nfinal _paint = Paint()..style = PaintingStyle.stroke;\n\nlate double cornerRadius;\n\nButtonBackground(Color color) {\n_paint.color = color;\n}\n\n@override\nvoid onMount() {\nsuper.onMount();\nsize = ancestor.size;\ncornerRadius = 0.3 * size.y;\n_paint.strokeWidth = 0.05 * size.y;\n}\n\nlate final _background = RRect.fromRectAndRadius(\nsize.toRect(),\nRadius.circular(cornerRadius),\n);\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRRect(_background, _paint);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that The Have fun button¶: But it is also time to have a look at the Ember Tutorial!", "completion": "import 'dart:ui';\n\nimport 'package:flame/components.dart';\n\nimport '../klondike_game.dart';\nimport '../pile.dart';\nimport '../suit.dart';\nimport 'card.dart';\n\nclass FoundationPile extends PositionComponent implements Pile {\nFoundationPile(int intSuit, this.checkWin, {super.position})\n: suit = Suit.fromInt(intSuit),\nsuper(size: KlondikeGame.cardSize);\n\nfinal VoidCallback checkWin;\n\nfinal Suit suit;\nfinal List<Card> _cards = [];\n\n//#region Pile API\n\nbool get isFull => _cards.length == 13;\n\n@override\nbool canMoveCard(Card card, MoveMethod method) =>\n_cards.isNotEmpty && card == _cards.last && method != MoveMethod.tap;\n\n@override\nbool canAcceptCard(Card card) {\nfinal topCardRank = _cards.isEmpty ? 0 : _cards.last.rank.value;\nreturn card.suit == suit &&\ncard.rank.value == topCardRank + 1 &&\ncard.attachedCards.isEmpty;\n}\n\n@override\nvoid removeCard(Card card, MoveMethod method) {\nassert(canMoveCard(card, method));\n_cards.removeLast();\n}\n\n@override\nvoid returnCard(Card card) {\ncard.position = position;\ncard.priority = _cards.indexOf(card);\n}\n\n@override\nvoid acquireCard(Card card) {\nassert(card.isFaceUp);\ncard.position = position;\ncard.priority = _cards.length;\ncard.pile = this;\n_cards.add(card);\nif (isFull) {\ncheckWin(); // Get KlondikeWorld to check all FoundationPiles.\n}\n}\n\n//#endregion\n\n//#region Rendering\n\nfinal _borderPaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 10\n..color = const Color(0x50ffffff);\nlate final _suitPaint = Paint()\n..color = suit.isRed ? const Color(0x3a000000) : const Color(0x64000000)\n..blendMode = BlendMode.luminosity;\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRRect(KlondikeGame.cardRRect, _borderPaint);\nsuit.sprite.render(\ncanvas,\nposition: size / 2,\nanchor: Anchor.center,\nsize: Vector2.all(KlondikeGame.cardWidth * 0.6),\noverridePaint: _suitPaint,\n);\n}\n\n//#endregion\n}"}
{"prompt": "Show me how to implement The Have fun button¶: But it is also time to have a look at the Ember Tutorial! using Flutter Flame", "completion": "import 'dart:ui';\n\nimport 'package:flame/components.dart';\n\nimport '../klondike_game.dart';\nimport '../pile.dart';\nimport '../suit.dart';\nimport 'card.dart';\n\nclass FoundationPile extends PositionComponent implements Pile {\nFoundationPile(int intSuit, this.checkWin, {super.position})\n: suit = Suit.fromInt(intSuit),\nsuper(size: KlondikeGame.cardSize);\n\nfinal VoidCallback checkWin;\n\nfinal Suit suit;\nfinal List<Card> _cards = [];\n\n//#region Pile API\n\nbool get isFull => _cards.length == 13;\n\n@override\nbool canMoveCard(Card card, MoveMethod method) =>\n_cards.isNotEmpty && card == _cards.last && method != MoveMethod.tap;\n\n@override\nbool canAcceptCard(Card card) {\nfinal topCardRank = _cards.isEmpty ? 0 : _cards.last.rank.value;\nreturn card.suit == suit &&\ncard.rank.value == topCardRank + 1 &&\ncard.attachedCards.isEmpty;\n}\n\n@override\nvoid removeCard(Card card, MoveMethod method) {\nassert(canMoveCard(card, method));\n_cards.removeLast();\n}\n\n@override\nvoid returnCard(Card card) {\ncard.position = position;\ncard.priority = _cards.indexOf(card);\n}\n\n@override\nvoid acquireCard(Card card) {\nassert(card.isFaceUp);\ncard.position = position;\ncard.priority = _cards.length;\ncard.pile = this;\n_cards.add(card);\nif (isFull) {\ncheckWin(); // Get KlondikeWorld to check all FoundationPiles.\n}\n}\n\n//#endregion\n\n//#region Rendering\n\nfinal _borderPaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 10\n..color = const Color(0x50ffffff);\nlate final _suitPaint = Paint()\n..color = suit.isRed ? const Color(0x3a000000) : const Color(0x64000000)\n..blendMode = BlendMode.luminosity;\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRRect(KlondikeGame.cardRRect, _borderPaint);\nsuit.sprite.render(\ncanvas,\nposition: size / 2,\nanchor: Anchor.center,\nsize: Vector2.all(KlondikeGame.cardWidth * 0.6),\noverridePaint: _suitPaint,\n);\n}\n\n//#endregion\n}"}
{"prompt": "Write Flutter Flame code to The Have fun button¶: But it is also time to have a look at the Ember Tutorial!", "completion": "import 'dart:ui';\n\nimport 'package:flame/components.dart';\n\nimport '../klondike_game.dart';\nimport '../pile.dart';\nimport '../suit.dart';\nimport 'card.dart';\n\nclass FoundationPile extends PositionComponent implements Pile {\nFoundationPile(int intSuit, this.checkWin, {super.position})\n: suit = Suit.fromInt(intSuit),\nsuper(size: KlondikeGame.cardSize);\n\nfinal VoidCallback checkWin;\n\nfinal Suit suit;\nfinal List<Card> _cards = [];\n\n//#region Pile API\n\nbool get isFull => _cards.length == 13;\n\n@override\nbool canMoveCard(Card card, MoveMethod method) =>\n_cards.isNotEmpty && card == _cards.last && method != MoveMethod.tap;\n\n@override\nbool canAcceptCard(Card card) {\nfinal topCardRank = _cards.isEmpty ? 0 : _cards.last.rank.value;\nreturn card.suit == suit &&\ncard.rank.value == topCardRank + 1 &&\ncard.attachedCards.isEmpty;\n}\n\n@override\nvoid removeCard(Card card, MoveMethod method) {\nassert(canMoveCard(card, method));\n_cards.removeLast();\n}\n\n@override\nvoid returnCard(Card card) {\ncard.position = position;\ncard.priority = _cards.indexOf(card);\n}\n\n@override\nvoid acquireCard(Card card) {\nassert(card.isFaceUp);\ncard.position = position;\ncard.priority = _cards.length;\ncard.pile = this;\n_cards.add(card);\nif (isFull) {\ncheckWin(); // Get KlondikeWorld to check all FoundationPiles.\n}\n}\n\n//#endregion\n\n//#region Rendering\n\nfinal _borderPaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 10\n..color = const Color(0x50ffffff);\nlate final _suitPaint = Paint()\n..color = suit.isRed ? const Color(0x3a000000) : const Color(0x64000000)\n..blendMode = BlendMode.luminosity;\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRRect(KlondikeGame.cardRRect, _borderPaint);\nsuit.sprite.render(\ncanvas,\nposition: size / 2,\nanchor: Anchor.center,\nsize: Vector2.all(KlondikeGame.cardWidth * 0.6),\noverridePaint: _suitPaint,\n);\n}\n\n//#endregion\n}"}
{"prompt": "Create a Flutter Flame game component that The Have fun button¶: But it is also time to have a look at the Ember Tutorial!", "completion": "import 'dart:ui';\n\nimport 'package:flame/components.dart';\n\nimport '../klondike_game.dart';\nimport '../pile.dart';\nimport 'card.dart';\nimport 'waste_pile.dart';\n\nclass StockPile extends PositionComponent\nwith HasGameReference<KlondikeGame>\nimplements Pile {\nStockPile({super.position}) : super(size: KlondikeGame.cardSize);\n\n/// Which cards are currently placed onto this pile. The first card in the\n/// list is at the bottom, the last card is on top.\nfinal List<Card> _cards = [];\n\n//#region Pile API\n\n@override\nbool canMoveCard(Card card, MoveMethod method) => false;\n// Can be moved by onTapUp callback (see below).\n\n@override\nbool canAcceptCard(Card card) => false;\n\n@override\nvoid removeCard(Card card, MoveMethod method) =>\nthrow StateError('cannot remove cards');\n\n@override\n// Card cannot be removed but could have been dragged out of place.\nvoid returnCard(Card card) => card.priority = _cards.indexOf(card);\n\n@override\nvoid acquireCard(Card card) {\nassert(card.isFaceDown);\ncard.pile = this;\ncard.position = position;\ncard.priority = _cards.length;\n_cards.add(card);\n}\n\n//#endregion\n\nvoid handleTapUp(Card card) {\nfinal wastePile = parent!.firstChild<WastePile>()!;\nif (_cards.isEmpty) {\nassert(card.isBaseCard, 'Stock Pile is empty, but no Base Card present');\ncard.position = position; // Force Base Card (back) into correct position.\nwastePile.removeAllCards().reversed.forEach((card) {\ncard.flip();\nacquireCard(card);\n});\n} else {\nfor (var i = 0; i < game.klondikeDraw; i++) {\nif (_cards.isNotEmpty) {\nfinal card = _cards.removeLast();\ncard.doMoveAndFlip(\nwastePile.position,\nwhenDone: () {\nwastePile.acquireCard(card);\n},\n);\n}\n}\n}\n}\n\n//#region Rendering\n\nfinal _borderPaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 10\n..color = const Color(0xFF3F5B5D);\nfinal _circlePaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 100\n..color = const Color(0x883F5B5D);\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRRect(KlondikeGame.cardRRect, _borderPaint);\ncanvas.drawCircle(\nOffset(width / 2, height / 2),\nKlondikeGame.cardWidth * 0.3,\n_circlePaint,\n);\n}\n\n//#endregion\n}"}
{"prompt": "Show me how to implement The Have fun button¶: But it is also time to have a look at the Ember Tutorial! using Flutter Flame", "completion": "import 'dart:ui';\n\nimport 'package:flame/components.dart';\n\nimport '../klondike_game.dart';\nimport '../pile.dart';\nimport 'card.dart';\nimport 'waste_pile.dart';\n\nclass StockPile extends PositionComponent\nwith HasGameReference<KlondikeGame>\nimplements Pile {\nStockPile({super.position}) : super(size: KlondikeGame.cardSize);\n\n/// Which cards are currently placed onto this pile. The first card in the\n/// list is at the bottom, the last card is on top.\nfinal List<Card> _cards = [];\n\n//#region Pile API\n\n@override\nbool canMoveCard(Card card, MoveMethod method) => false;\n// Can be moved by onTapUp callback (see below).\n\n@override\nbool canAcceptCard(Card card) => false;\n\n@override\nvoid removeCard(Card card, MoveMethod method) =>\nthrow StateError('cannot remove cards');\n\n@override\n// Card cannot be removed but could have been dragged out of place.\nvoid returnCard(Card card) => card.priority = _cards.indexOf(card);\n\n@override\nvoid acquireCard(Card card) {\nassert(card.isFaceDown);\ncard.pile = this;\ncard.position = position;\ncard.priority = _cards.length;\n_cards.add(card);\n}\n\n//#endregion\n\nvoid handleTapUp(Card card) {\nfinal wastePile = parent!.firstChild<WastePile>()!;\nif (_cards.isEmpty) {\nassert(card.isBaseCard, 'Stock Pile is empty, but no Base Card present');\ncard.position = position; // Force Base Card (back) into correct position.\nwastePile.removeAllCards().reversed.forEach((card) {\ncard.flip();\nacquireCard(card);\n});\n} else {\nfor (var i = 0; i < game.klondikeDraw; i++) {\nif (_cards.isNotEmpty) {\nfinal card = _cards.removeLast();\ncard.doMoveAndFlip(\nwastePile.position,\nwhenDone: () {\nwastePile.acquireCard(card);\n},\n);\n}\n}\n}\n}\n\n//#region Rendering\n\nfinal _borderPaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 10\n..color = const Color(0xFF3F5B5D);\nfinal _circlePaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 100\n..color = const Color(0x883F5B5D);\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRRect(KlondikeGame.cardRRect, _borderPaint);\ncanvas.drawCircle(\nOffset(width / 2, height / 2),\nKlondikeGame.cardWidth * 0.3,\n_circlePaint,\n);\n}\n\n//#endregion\n}"}
{"prompt": "Write Flutter Flame code to The Have fun button¶: But it is also time to have a look at the Ember Tutorial!", "completion": "import 'dart:ui';\n\nimport 'package:flame/components.dart';\n\nimport '../klondike_game.dart';\nimport '../pile.dart';\nimport 'card.dart';\nimport 'waste_pile.dart';\n\nclass StockPile extends PositionComponent\nwith HasGameReference<KlondikeGame>\nimplements Pile {\nStockPile({super.position}) : super(size: KlondikeGame.cardSize);\n\n/// Which cards are currently placed onto this pile. The first card in the\n/// list is at the bottom, the last card is on top.\nfinal List<Card> _cards = [];\n\n//#region Pile API\n\n@override\nbool canMoveCard(Card card, MoveMethod method) => false;\n// Can be moved by onTapUp callback (see below).\n\n@override\nbool canAcceptCard(Card card) => false;\n\n@override\nvoid removeCard(Card card, MoveMethod method) =>\nthrow StateError('cannot remove cards');\n\n@override\n// Card cannot be removed but could have been dragged out of place.\nvoid returnCard(Card card) => card.priority = _cards.indexOf(card);\n\n@override\nvoid acquireCard(Card card) {\nassert(card.isFaceDown);\ncard.pile = this;\ncard.position = position;\ncard.priority = _cards.length;\n_cards.add(card);\n}\n\n//#endregion\n\nvoid handleTapUp(Card card) {\nfinal wastePile = parent!.firstChild<WastePile>()!;\nif (_cards.isEmpty) {\nassert(card.isBaseCard, 'Stock Pile is empty, but no Base Card present');\ncard.position = position; // Force Base Card (back) into correct position.\nwastePile.removeAllCards().reversed.forEach((card) {\ncard.flip();\nacquireCard(card);\n});\n} else {\nfor (var i = 0; i < game.klondikeDraw; i++) {\nif (_cards.isNotEmpty) {\nfinal card = _cards.removeLast();\ncard.doMoveAndFlip(\nwastePile.position,\nwhenDone: () {\nwastePile.acquireCard(card);\n},\n);\n}\n}\n}\n}\n\n//#region Rendering\n\nfinal _borderPaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 10\n..color = const Color(0xFF3F5B5D);\nfinal _circlePaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 100\n..color = const Color(0x883F5B5D);\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRRect(KlondikeGame.cardRRect, _borderPaint);\ncanvas.drawCircle(\nOffset(width / 2, height / 2),\nKlondikeGame.cardWidth * 0.3,\n_circlePaint,\n);\n}\n\n//#endregion\n}"}
{"prompt": "Create a Flutter Flame game component that The Have fun button¶: But it is also time to have a look at the Ember Tutorial!", "completion": "import 'dart:ui';\n\nimport 'package:flame/components.dart';\n\nimport '../klondike_game.dart';\nimport '../pile.dart';\nimport 'card.dart';\n\nclass TableauPile extends PositionComponent implements Pile {\nTableauPile({super.position}) : super(size: KlondikeGame.cardSize);\n\n/// Which cards are currently placed onto this pile.\nfinal List<Card> _cards = [];\nfinal Vector2 _fanOffset1 = Vector2(0, KlondikeGame.cardHeight * 0.05);\nfinal Vector2 _fanOffset2 = Vector2(0, KlondikeGame.cardHeight * 0.2);\n\n//#region Pile API\n\n@override\nbool canMoveCard(Card card, MoveMethod method) =>\ncard.isFaceUp && (method == MoveMethod.drag || card == _cards.last);\n// Drag can move multiple cards: tap can move last card only (to Foundation).\n\n@override\nbool canAcceptCard(Card card) {\nif (_cards.isEmpty) {\nreturn card.rank.value == 13;\n} else {\nfinal topCard = _cards.last;\nreturn card.suit.isRed == !topCard.suit.isRed &&\ncard.rank.value == topCard.rank.value - 1;\n}\n}\n\n@override\nvoid removeCard(Card card, MoveMethod method) {\nassert(_cards.contains(card) && card.isFaceUp);\nfinal index = _cards.indexOf(card);\n_cards.removeRange(index, _cards.length);\nif (_cards.isNotEmpty && _cards.last.isFaceDown) {\nflipTopCard();\nreturn;\n}\nlayOutCards();\n}\n\n@override\nvoid returnCard(Card card) {\ncard.priority = _cards.indexOf(card);\nlayOutCards();\n}\n\n@override\nvoid acquireCard(Card card) {\ncard.pile = this;\ncard.priority = _cards.length;\n_cards.add(card);\nlayOutCards();\n}\n\n//#endregion\n\nvoid dropCards(Card firstCard, [List<Card> attachedCards = const []]) {\nfinal cardList = [firstCard];\ncardList.addAll(attachedCards);\nVector2 nextPosition = _cards.isEmpty ? position : _cards.last.position;\nvar nCardsToMove = cardList.length;\nfor (final card in cardList) {\ncard.pile = this;\ncard.priority = _cards.length;\nif (_cards.isNotEmpty) {\nnextPosition =\nnextPosition + (card.isFaceDown ? _fanOffset1 : _fanOffset2);\n}\n_cards.add(card);\ncard.doMove(\nnextPosition,\nstartPriority: card.priority,\nonComplete: () {\nnCardsToMove--;\nif (nCardsToMove == 0) {\ncalculateHitArea(); // Expand the hit-area.\n}\n},\n);\n}\n}\n\nvoid flipTopCard({double start = 0.1}) {\nassert(_cards.last.isFaceDown);\n_cards.last.turnFaceUp(\nstart: start,\nonComplete: layOutCards,\n);\n}\n\nvoid layOutCards() {\nif (_cards.isEmpty) {\ncalculateHitArea(); // Shrink hit-area when all cards have been removed.\nreturn;\n}\n_cards[0].position.setFrom(position);\n_cards[0].priority = 0;\nfor (var i = 1; i < _cards.length; i++) {\n_cards[i].priority = i;\n_cards[i].position\n..setFrom(_cards[i - 1].position)\n..add(_cards[i - 1].isFaceDown ? _fanOffset1 : _fanOffset2);\n}\ncalculateHitArea(); // Adjust hit-area to more cards or fewer cards.\n}\n\nvoid calculateHitArea() {\nheight = KlondikeGame.cardHeight * 1.5 +\n(_cards.length < 2 ? 0.0 : _cards.last.y - _cards.first.y);\n}\n\nList<Card> cardsOnTop(Card card) {\nassert(card.isFaceUp && _cards.contains(card));\nfinal index = _cards.indexOf(card);\nreturn _cards.getRange(index + 1, _cards.length).toList();\n}\n\n//#region Rendering\n\nfinal _borderPaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 10\n..color = const Color(0x50ffffff);\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRRect(KlondikeGame.cardRRect, _borderPaint);\n}\n\n//#endregion\n}"}
{"prompt": "Show me how to implement The Have fun button¶: But it is also time to have a look at the Ember Tutorial! using Flutter Flame", "completion": "import 'dart:ui';\n\nimport 'package:flame/components.dart';\n\nimport '../klondike_game.dart';\nimport '../pile.dart';\nimport 'card.dart';\n\nclass TableauPile extends PositionComponent implements Pile {\nTableauPile({super.position}) : super(size: KlondikeGame.cardSize);\n\n/// Which cards are currently placed onto this pile.\nfinal List<Card> _cards = [];\nfinal Vector2 _fanOffset1 = Vector2(0, KlondikeGame.cardHeight * 0.05);\nfinal Vector2 _fanOffset2 = Vector2(0, KlondikeGame.cardHeight * 0.2);\n\n//#region Pile API\n\n@override\nbool canMoveCard(Card card, MoveMethod method) =>\ncard.isFaceUp && (method == MoveMethod.drag || card == _cards.last);\n// Drag can move multiple cards: tap can move last card only (to Foundation).\n\n@override\nbool canAcceptCard(Card card) {\nif (_cards.isEmpty) {\nreturn card.rank.value == 13;\n} else {\nfinal topCard = _cards.last;\nreturn card.suit.isRed == !topCard.suit.isRed &&\ncard.rank.value == topCard.rank.value - 1;\n}\n}\n\n@override\nvoid removeCard(Card card, MoveMethod method) {\nassert(_cards.contains(card) && card.isFaceUp);\nfinal index = _cards.indexOf(card);\n_cards.removeRange(index, _cards.length);\nif (_cards.isNotEmpty && _cards.last.isFaceDown) {\nflipTopCard();\nreturn;\n}\nlayOutCards();\n}\n\n@override\nvoid returnCard(Card card) {\ncard.priority = _cards.indexOf(card);\nlayOutCards();\n}\n\n@override\nvoid acquireCard(Card card) {\ncard.pile = this;\ncard.priority = _cards.length;\n_cards.add(card);\nlayOutCards();\n}\n\n//#endregion\n\nvoid dropCards(Card firstCard, [List<Card> attachedCards = const []]) {\nfinal cardList = [firstCard];\ncardList.addAll(attachedCards);\nVector2 nextPosition = _cards.isEmpty ? position : _cards.last.position;\nvar nCardsToMove = cardList.length;\nfor (final card in cardList) {\ncard.pile = this;\ncard.priority = _cards.length;\nif (_cards.isNotEmpty) {\nnextPosition =\nnextPosition + (card.isFaceDown ? _fanOffset1 : _fanOffset2);\n}\n_cards.add(card);\ncard.doMove(\nnextPosition,\nstartPriority: card.priority,\nonComplete: () {\nnCardsToMove--;\nif (nCardsToMove == 0) {\ncalculateHitArea(); // Expand the hit-area.\n}\n},\n);\n}\n}\n\nvoid flipTopCard({double start = 0.1}) {\nassert(_cards.last.isFaceDown);\n_cards.last.turnFaceUp(\nstart: start,\nonComplete: layOutCards,\n);\n}\n\nvoid layOutCards() {\nif (_cards.isEmpty) {\ncalculateHitArea(); // Shrink hit-area when all cards have been removed.\nreturn;\n}\n_cards[0].position.setFrom(position);\n_cards[0].priority = 0;\nfor (var i = 1; i < _cards.length; i++) {\n_cards[i].priority = i;\n_cards[i].position\n..setFrom(_cards[i - 1].position)\n..add(_cards[i - 1].isFaceDown ? _fanOffset1 : _fanOffset2);\n}\ncalculateHitArea(); // Adjust hit-area to more cards or fewer cards.\n}\n\nvoid calculateHitArea() {\nheight = KlondikeGame.cardHeight * 1.5 +\n(_cards.length < 2 ? 0.0 : _cards.last.y - _cards.first.y);\n}\n\nList<Card> cardsOnTop(Card card) {\nassert(card.isFaceUp && _cards.contains(card));\nfinal index = _cards.indexOf(card);\nreturn _cards.getRange(index + 1, _cards.length).toList();\n}\n\n//#region Rendering\n\nfinal _borderPaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 10\n..color = const Color(0x50ffffff);\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRRect(KlondikeGame.cardRRect, _borderPaint);\n}\n\n//#endregion\n}"}
{"prompt": "Write Flutter Flame code to The Have fun button¶: But it is also time to have a look at the Ember Tutorial!", "completion": "import 'dart:ui';\n\nimport 'package:flame/components.dart';\n\nimport '../klondike_game.dart';\nimport '../pile.dart';\nimport 'card.dart';\n\nclass TableauPile extends PositionComponent implements Pile {\nTableauPile({super.position}) : super(size: KlondikeGame.cardSize);\n\n/// Which cards are currently placed onto this pile.\nfinal List<Card> _cards = [];\nfinal Vector2 _fanOffset1 = Vector2(0, KlondikeGame.cardHeight * 0.05);\nfinal Vector2 _fanOffset2 = Vector2(0, KlondikeGame.cardHeight * 0.2);\n\n//#region Pile API\n\n@override\nbool canMoveCard(Card card, MoveMethod method) =>\ncard.isFaceUp && (method == MoveMethod.drag || card == _cards.last);\n// Drag can move multiple cards: tap can move last card only (to Foundation).\n\n@override\nbool canAcceptCard(Card card) {\nif (_cards.isEmpty) {\nreturn card.rank.value == 13;\n} else {\nfinal topCard = _cards.last;\nreturn card.suit.isRed == !topCard.suit.isRed &&\ncard.rank.value == topCard.rank.value - 1;\n}\n}\n\n@override\nvoid removeCard(Card card, MoveMethod method) {\nassert(_cards.contains(card) && card.isFaceUp);\nfinal index = _cards.indexOf(card);\n_cards.removeRange(index, _cards.length);\nif (_cards.isNotEmpty && _cards.last.isFaceDown) {\nflipTopCard();\nreturn;\n}\nlayOutCards();\n}\n\n@override\nvoid returnCard(Card card) {\ncard.priority = _cards.indexOf(card);\nlayOutCards();\n}\n\n@override\nvoid acquireCard(Card card) {\ncard.pile = this;\ncard.priority = _cards.length;\n_cards.add(card);\nlayOutCards();\n}\n\n//#endregion\n\nvoid dropCards(Card firstCard, [List<Card> attachedCards = const []]) {\nfinal cardList = [firstCard];\ncardList.addAll(attachedCards);\nVector2 nextPosition = _cards.isEmpty ? position : _cards.last.position;\nvar nCardsToMove = cardList.length;\nfor (final card in cardList) {\ncard.pile = this;\ncard.priority = _cards.length;\nif (_cards.isNotEmpty) {\nnextPosition =\nnextPosition + (card.isFaceDown ? _fanOffset1 : _fanOffset2);\n}\n_cards.add(card);\ncard.doMove(\nnextPosition,\nstartPriority: card.priority,\nonComplete: () {\nnCardsToMove--;\nif (nCardsToMove == 0) {\ncalculateHitArea(); // Expand the hit-area.\n}\n},\n);\n}\n}\n\nvoid flipTopCard({double start = 0.1}) {\nassert(_cards.last.isFaceDown);\n_cards.last.turnFaceUp(\nstart: start,\nonComplete: layOutCards,\n);\n}\n\nvoid layOutCards() {\nif (_cards.isEmpty) {\ncalculateHitArea(); // Shrink hit-area when all cards have been removed.\nreturn;\n}\n_cards[0].position.setFrom(position);\n_cards[0].priority = 0;\nfor (var i = 1; i < _cards.length; i++) {\n_cards[i].priority = i;\n_cards[i].position\n..setFrom(_cards[i - 1].position)\n..add(_cards[i - 1].isFaceDown ? _fanOffset1 : _fanOffset2);\n}\ncalculateHitArea(); // Adjust hit-area to more cards or fewer cards.\n}\n\nvoid calculateHitArea() {\nheight = KlondikeGame.cardHeight * 1.5 +\n(_cards.length < 2 ? 0.0 : _cards.last.y - _cards.first.y);\n}\n\nList<Card> cardsOnTop(Card card) {\nassert(card.isFaceUp && _cards.contains(card));\nfinal index = _cards.indexOf(card);\nreturn _cards.getRange(index + 1, _cards.length).toList();\n}\n\n//#region Rendering\n\nfinal _borderPaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 10\n..color = const Color(0x50ffffff);\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRRect(KlondikeGame.cardRRect, _borderPaint);\n}\n\n//#endregion\n}"}
{"prompt": "Create a Flutter Flame game component that The Have fun button¶: But it is also time to have a look at the Ember Tutorial!", "completion": "import 'package:flame/components.dart';\n\nimport '../klondike_game.dart';\nimport '../pile.dart';\nimport 'card.dart';\n\nclass WastePile extends PositionComponent\nwith HasGameReference<KlondikeGame>\nimplements Pile {\nWastePile({super.position}) : super(size: KlondikeGame.cardSize);\n\nfinal List<Card> _cards = [];\nfinal Vector2 _fanOffset = Vector2(KlondikeGame.cardWidth * 0.2, 0);\n\n//#region Pile API\n\n@override\nbool canMoveCard(Card card, MoveMethod method) =>\n_cards.isNotEmpty && card == _cards.last; // Tap and drag are both OK.\n\n@override\nbool canAcceptCard(Card card) => false;\n\n@override\nvoid removeCard(Card card, MoveMethod method) {\nassert(canMoveCard(card, method));\n_cards.removeLast();\n_fanOutTopCards();\n}\n\n@override\nvoid returnCard(Card card) {\ncard.priority = _cards.indexOf(card);\n_fanOutTopCards();\n}\n\n@override\nvoid acquireCard(Card card) {\nassert(card.isFaceUp);\ncard.pile = this;\ncard.position = position;\ncard.priority = _cards.length;\n_cards.add(card);\n_fanOutTopCards();\n}\n\n//#endregion\n\nList<Card> removeAllCards() {\nfinal cards = _cards.toList();\n_cards.clear();\nreturn cards;\n}\n\nvoid _fanOutTopCards() {\nif (game.klondikeDraw == 1) {\n// No fan-out in Klondike Draw 1.\nreturn;\n}\nfinal n = _cards.length;\nfor (var i = 0; i < n; i++) {\n_cards[i].position = position;\n}\nif (n == 2) {\n_cards[1].position.add(_fanOffset);\n} else if (n >= 3) {\n_cards[n - 2].position.add(_fanOffset);\n_cards[n - 1].position.addScaled(_fanOffset, 2);\n}\n}\n}"}
{"prompt": "Show me how to implement The Have fun button¶: But it is also time to have a look at the Ember Tutorial! using Flutter Flame", "completion": "import 'package:flame/components.dart';\n\nimport '../klondike_game.dart';\nimport '../pile.dart';\nimport 'card.dart';\n\nclass WastePile extends PositionComponent\nwith HasGameReference<KlondikeGame>\nimplements Pile {\nWastePile({super.position}) : super(size: KlondikeGame.cardSize);\n\nfinal List<Card> _cards = [];\nfinal Vector2 _fanOffset = Vector2(KlondikeGame.cardWidth * 0.2, 0);\n\n//#region Pile API\n\n@override\nbool canMoveCard(Card card, MoveMethod method) =>\n_cards.isNotEmpty && card == _cards.last; // Tap and drag are both OK.\n\n@override\nbool canAcceptCard(Card card) => false;\n\n@override\nvoid removeCard(Card card, MoveMethod method) {\nassert(canMoveCard(card, method));\n_cards.removeLast();\n_fanOutTopCards();\n}\n\n@override\nvoid returnCard(Card card) {\ncard.priority = _cards.indexOf(card);\n_fanOutTopCards();\n}\n\n@override\nvoid acquireCard(Card card) {\nassert(card.isFaceUp);\ncard.pile = this;\ncard.position = position;\ncard.priority = _cards.length;\n_cards.add(card);\n_fanOutTopCards();\n}\n\n//#endregion\n\nList<Card> removeAllCards() {\nfinal cards = _cards.toList();\n_cards.clear();\nreturn cards;\n}\n\nvoid _fanOutTopCards() {\nif (game.klondikeDraw == 1) {\n// No fan-out in Klondike Draw 1.\nreturn;\n}\nfinal n = _cards.length;\nfor (var i = 0; i < n; i++) {\n_cards[i].position = position;\n}\nif (n == 2) {\n_cards[1].position.add(_fanOffset);\n} else if (n >= 3) {\n_cards[n - 2].position.add(_fanOffset);\n_cards[n - 1].position.addScaled(_fanOffset, 2);\n}\n}\n}"}
{"prompt": "Write Flutter Flame code to The Have fun button¶: But it is also time to have a look at the Ember Tutorial!", "completion": "import 'package:flame/components.dart';\n\nimport '../klondike_game.dart';\nimport '../pile.dart';\nimport 'card.dart';\n\nclass WastePile extends PositionComponent\nwith HasGameReference<KlondikeGame>\nimplements Pile {\nWastePile({super.position}) : super(size: KlondikeGame.cardSize);\n\nfinal List<Card> _cards = [];\nfinal Vector2 _fanOffset = Vector2(KlondikeGame.cardWidth * 0.2, 0);\n\n//#region Pile API\n\n@override\nbool canMoveCard(Card card, MoveMethod method) =>\n_cards.isNotEmpty && card == _cards.last; // Tap and drag are both OK.\n\n@override\nbool canAcceptCard(Card card) => false;\n\n@override\nvoid removeCard(Card card, MoveMethod method) {\nassert(canMoveCard(card, method));\n_cards.removeLast();\n_fanOutTopCards();\n}\n\n@override\nvoid returnCard(Card card) {\ncard.priority = _cards.indexOf(card);\n_fanOutTopCards();\n}\n\n@override\nvoid acquireCard(Card card) {\nassert(card.isFaceUp);\ncard.pile = this;\ncard.position = position;\ncard.priority = _cards.length;\n_cards.add(card);\n_fanOutTopCards();\n}\n\n//#endregion\n\nList<Card> removeAllCards() {\nfinal cards = _cards.toList();\n_cards.clear();\nreturn cards;\n}\n\nvoid _fanOutTopCards() {\nif (game.klondikeDraw == 1) {\n// No fan-out in Klondike Draw 1.\nreturn;\n}\nfinal n = _cards.length;\nfor (var i = 0; i < n; i++) {\n_cards[i].position = position;\n}\nif (n == 2) {\n_cards[1].position.add(_fanOffset);\n} else if (n >= 3) {\n_cards[n - 2].position.add(_fanOffset);\n_cards[n - 1].position.addScaled(_fanOffset, 2);\n}\n}\n}"}
{"prompt": "Create a Flutter Flame game component that The Have fun button¶: But it is also time to have a look at the Ember Tutorial!", "completion": "import 'dart:ui';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/flame.dart';\nimport 'package:flame/game.dart';\n\nimport 'klondike_world.dart';\n\nenum Action { newDeal, sameDeal, changeDraw, haveFun }\n\nclass KlondikeGame extends FlameGame<KlondikeWorld> {\nstatic const double cardGap = 175.0;\nstatic const double topGap = 500.0;\nstatic const double cardWidth = 1000.0;\nstatic const double cardHeight = 1400.0;\nstatic const double cardRadius = 100.0;\nstatic const double cardSpaceWidth = cardWidth + cardGap;\nstatic const double cardSpaceHeight = cardHeight + cardGap;\nstatic final Vector2 cardSize = Vector2(cardWidth, cardHeight);\nstatic final cardRRect = RRect.fromRectAndRadius(\nconst Rect.fromLTWH(0, 0, cardWidth, cardHeight),\nconst Radius.circular(cardRadius),\n);\n\n/// Constant used to decide when a short drag is treated as a TapUp event.\nstatic const double dragTolerance = cardWidth / 5;\n\n/// Constant used when creating Random seed.\nstatic const int maxInt = 0xFFFFFFFE; // = (2 to the power 32) - 1\n\n// This KlondikeGame constructor also initiates the first KlondikeWorld.\nKlondikeGame() : super(world: KlondikeWorld());\n\n// These three values persist between games and are starting conditions\n// for the next game to be played in KlondikeWorld. The actual seed is\n// computed in KlondikeWorld but is held here in case the player chooses\n// to replay a game by selecting Action.sameDeal.\nint klondikeDraw = 1;\nint seed = 1;\nAction action = Action.newDeal;\n}\n\nSprite klondikeSprite(double x, double y, double width, double height) {\nreturn Sprite(\nFlame.images.fromCache('klondike-sprites.png'),\nsrcPosition: Vector2(x, y),\nsrcSize: Vector2(width, height),\n);\n}"}
{"prompt": "Show me how to implement The Have fun button¶: But it is also time to have a look at the Ember Tutorial! using Flutter Flame", "completion": "import 'dart:ui';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/flame.dart';\nimport 'package:flame/game.dart';\n\nimport 'klondike_world.dart';\n\nenum Action { newDeal, sameDeal, changeDraw, haveFun }\n\nclass KlondikeGame extends FlameGame<KlondikeWorld> {\nstatic const double cardGap = 175.0;\nstatic const double topGap = 500.0;\nstatic const double cardWidth = 1000.0;\nstatic const double cardHeight = 1400.0;\nstatic const double cardRadius = 100.0;\nstatic const double cardSpaceWidth = cardWidth + cardGap;\nstatic const double cardSpaceHeight = cardHeight + cardGap;\nstatic final Vector2 cardSize = Vector2(cardWidth, cardHeight);\nstatic final cardRRect = RRect.fromRectAndRadius(\nconst Rect.fromLTWH(0, 0, cardWidth, cardHeight),\nconst Radius.circular(cardRadius),\n);\n\n/// Constant used to decide when a short drag is treated as a TapUp event.\nstatic const double dragTolerance = cardWidth / 5;\n\n/// Constant used when creating Random seed.\nstatic const int maxInt = 0xFFFFFFFE; // = (2 to the power 32) - 1\n\n// This KlondikeGame constructor also initiates the first KlondikeWorld.\nKlondikeGame() : super(world: KlondikeWorld());\n\n// These three values persist between games and are starting conditions\n// for the next game to be played in KlondikeWorld. The actual seed is\n// computed in KlondikeWorld but is held here in case the player chooses\n// to replay a game by selecting Action.sameDeal.\nint klondikeDraw = 1;\nint seed = 1;\nAction action = Action.newDeal;\n}\n\nSprite klondikeSprite(double x, double y, double width, double height) {\nreturn Sprite(\nFlame.images.fromCache('klondike-sprites.png'),\nsrcPosition: Vector2(x, y),\nsrcSize: Vector2(width, height),\n);\n}"}
{"prompt": "Write Flutter Flame code to The Have fun button¶: But it is also time to have a look at the Ember Tutorial!", "completion": "import 'dart:ui';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/flame.dart';\nimport 'package:flame/game.dart';\n\nimport 'klondike_world.dart';\n\nenum Action { newDeal, sameDeal, changeDraw, haveFun }\n\nclass KlondikeGame extends FlameGame<KlondikeWorld> {\nstatic const double cardGap = 175.0;\nstatic const double topGap = 500.0;\nstatic const double cardWidth = 1000.0;\nstatic const double cardHeight = 1400.0;\nstatic const double cardRadius = 100.0;\nstatic const double cardSpaceWidth = cardWidth + cardGap;\nstatic const double cardSpaceHeight = cardHeight + cardGap;\nstatic final Vector2 cardSize = Vector2(cardWidth, cardHeight);\nstatic final cardRRect = RRect.fromRectAndRadius(\nconst Rect.fromLTWH(0, 0, cardWidth, cardHeight),\nconst Radius.circular(cardRadius),\n);\n\n/// Constant used to decide when a short drag is treated as a TapUp event.\nstatic const double dragTolerance = cardWidth / 5;\n\n/// Constant used when creating Random seed.\nstatic const int maxInt = 0xFFFFFFFE; // = (2 to the power 32) - 1\n\n// This KlondikeGame constructor also initiates the first KlondikeWorld.\nKlondikeGame() : super(world: KlondikeWorld());\n\n// These three values persist between games and are starting conditions\n// for the next game to be played in KlondikeWorld. The actual seed is\n// computed in KlondikeWorld but is held here in case the player chooses\n// to replay a game by selecting Action.sameDeal.\nint klondikeDraw = 1;\nint seed = 1;\nAction action = Action.newDeal;\n}\n\nSprite klondikeSprite(double x, double y, double width, double height) {\nreturn Sprite(\nFlame.images.fromCache('klondike-sprites.png'),\nsrcPosition: Vector2(x, y),\nsrcSize: Vector2(width, height),\n);\n}"}
{"prompt": "Create a Flutter Flame game component that The Have fun button¶: But it is also time to have a look at the Ember Tutorial!", "completion": "import 'dart:math';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/flame.dart';\n\nimport 'components/card.dart';\nimport 'components/flat_button.dart';\nimport 'components/foundation_pile.dart';\nimport 'components/stock_pile.dart';\nimport 'components/tableau_pile.dart';\nimport 'components/waste_pile.dart';\n\nimport 'klondike_game.dart';\n\nclass KlondikeWorld extends World with HasGameReference<KlondikeGame> {\nfinal cardGap = KlondikeGame.cardGap;\nfinal topGap = KlondikeGame.topGap;\nfinal cardSpaceWidth = KlondikeGame.cardSpaceWidth;\nfinal cardSpaceHeight = KlondikeGame.cardSpaceHeight;\n\nfinal stock = StockPile(position: Vector2(0.0, 0.0));\nfinal waste = WastePile(position: Vector2(0.0, 0.0));\nfinal List<FoundationPile> foundations = [];\nfinal List<TableauPile> tableauPiles = [];\nfinal List<Card> cards = [];\nlate Vector2 playAreaSize;\n\n@override\nFuture<void> onLoad() async {\nawait Flame.images.load('klondike-sprites.png');\n\nstock.position = Vector2(cardGap, topGap);\nwaste.position = Vector2(cardSpaceWidth + cardGap, topGap);\n\nfor (var i = 0; i < 4; i++) {\nfoundations.add(\nFoundationPile(\ni,\ncheckWin,\nposition: Vector2((i + 3) * cardSpaceWidth + cardGap, topGap),\n),\n);\n}\nfor (var i = 0; i < 7; i++) {\ntableauPiles.add(\nTableauPile(\nposition: Vector2(\ni * cardSpaceWidth + cardGap,\ncardSpaceHeight + topGap,\n),\n),\n);\n}\n\n// Add a Base Card to the Stock Pile, above the pile and below other cards.\nfinal baseCard = Card(1, 0, isBaseCard: true);\nbaseCard.position = stock.position;\nbaseCard.priority = -1;\nbaseCard.pile = stock;\nstock.priority = -2;\n\nfor (var rank = 1; rank <= 13; rank++) {\nfor (var suit = 0; suit < 4; suit++) {\nfinal card = Card(rank, suit);\ncard.position = stock.position;\ncards.add(card);\n}\n}\n\nadd(stock);\nadd(waste);\naddAll(foundations);\naddAll(tableauPiles);\naddAll(cards);\nadd(baseCard);\n\nplayAreaSize =\nVector2(7 * cardSpaceWidth + cardGap, 4 * cardSpaceHeight + topGap);\nfinal gameMidX = playAreaSize.x / 2;\n\naddButton('New deal', gameMidX, Action.newDeal);\naddButton('Same deal', gameMidX + cardSpaceWidth, Action.sameDeal);\naddButton('Draw 1 or 3', gameMidX + 2 * cardSpaceWidth, Action.changeDraw);\naddButton('Have fun', gameMidX + 3 * cardSpaceWidth, Action.haveFun);\n\nfinal camera = game.camera;\ncamera.viewfinder.visibleGameSize = playAreaSize;\ncamera.viewfinder.position = Vector2(gameMidX, 0);\ncamera.viewfinder.anchor = Anchor.topCenter;\n\ndeal();\n}\n\nvoid addButton(String label, double buttonX, Action action) {\nfinal button = FlatButton(\nlabel,\nsize: Vector2(KlondikeGame.cardWidth, 0.6 * topGap),\nposition: Vector2(buttonX, topGap / 2),\nonReleased: () {\nif (action == Action.haveFun) {\n// Shortcut to the \"win\" sequence, for Tutorial purposes only.\nletsCelebrate();\n} else {\n// Restart with a new deal or the same deal as before.\ngame.action = action;\ngame.world = KlondikeWorld();\n}\n},\n);\nadd(button);\n}\n\nvoid deal() {\nassert(cards.length == 52, 'There are ${cards.length} cards: should be 52');\n\nif (game.action != Action.sameDeal) {\n// New deal: change the Random Number Generator's seed.\ngame.seed = Random().nextInt(KlondikeGame.maxInt);\nif (game.action == Action.changeDraw) {\ngame.klondikeDraw = (game.klondikeDraw == 3) ? 1 : 3;\n}\n}\n// For the \"Same deal\" option, re-use the previous seed, else use a new one.\ncards.shuffle(Random(game.seed));\n\n// Each card dealt must be seen to come from the top of the deck!\nvar dealPriority = 1;\nfor (final card in cards) {\ncard.priority = dealPriority++;\n}\n\n// Change priority as cards take off: so later cards fly above earlier ones.\nvar cardToDeal = cards.length - 1;\nvar nMovingCards = 0;\nfor (var i = 0; i < 7; i++) {\nfor (var j = i; j < 7; j++) {\nfinal card = cards[cardToDeal--];\ncard.doMove(\ntableauPiles[j].position,\nspeed: 15.0,\nstart: nMovingCards * 0.15,\nstartPriority: 100 + nMovingCards,\nonComplete: () {\ntableauPiles[j].acquireCard(card);\nnMovingCards--;\nif (nMovingCards == 0) {\nvar delayFactor = 0;\nfor (final tableauPile in tableauPiles) {\ndelayFactor++;\ntableauPile.flipTopCard(start: delayFactor * 0.15);\n}\n}\n},\n);\nnMovingCards++;\n}\n}\nfor (var n = 0; n <= cardToDeal; n++) {\nstock.acquireCard(cards[n]);\n}\n}\n\nvoid checkWin() {\n// Callback from a Foundation Pile when it is full (Ace to King).\nvar nComplete = 0;\nfor (final f in foundations) {\nif (f.isFull) {\nnComplete++;\n}\n}\nif (nComplete == foundations.length) {\nletsCelebrate();\n}\n}\n\nvoid letsCelebrate({int phase = 1}) {\n// Deal won: bring all cards to the middle of the screen (phase 1)\n// then scatter them to points just outside the screen (phase 2).\n//\n// First get the device's screen-size in game co-ordinates, then get the\n// top-left of the off-screen area that will accept the scattered cards.\n// Note: The play area is anchored at TopCenter, so topLeft.y is fixed.\n\nfinal cameraZoom = game.camera.viewfinder.zoom;\nfinal zoomedScreen = game.size / cameraZoom;\nfinal screenCenter = (playAreaSize - KlondikeGame.cardSize) / 2;\nfinal topLeft = Vector2(\n(playAreaSize.x - zoomedScreen.x) / 2 - KlondikeGame.cardWidth,\n-KlondikeGame.cardHeight,\n);\nfinal nCards = cards.length;\nfinal offscreenHeight = zoomedScreen.y + KlondikeGame.cardSize.y;\nfinal offscreenWidth = zoomedScreen.x + KlondikeGame.cardSize.x;\nfinal spacing = 2.0 * (offscreenHeight + offscreenWidth) / nCards;\n\n// Starting points, directions and lengths of offscreen rect's sides.\nfinal corner = [\nVector2(0.0, 0.0),\nVector2(0.0, offscreenHeight),\nVector2(offscreenWidth, offscreenHeight),\nVector2(offscreenWidth, 0.0),\n];\nfinal direction = [\nVector2(0.0, 1.0),\nVector2(1.0, 0.0),\nVector2(0.0, -1.0),\nVector2(-1.0, 0.0),\n];\nfinal length = [\noffscreenHeight,\noffscreenWidth,\noffscreenHeight,\noffscreenWidth,\n];\n\nvar side = 0;\nvar cardsToMove = nCards;\nvar offScreenPosition = corner[side] + topLeft;\nvar space = length[side];\nvar cardNum = 0;\n\nwhile (cardNum < nCards) {\nfinal cardIndex = phase == 1 ? cardNum : nCards - cardNum - 1;\nfinal card = cards[cardIndex];\ncard.priority = cardIndex + 1;\nif (card.isFaceDown) {\ncard.flip();\n}\n// Start cards a short time apart to give a riffle effect.\nfinal delay = phase == 1 ? cardNum * 0.02 : 0.5 + cardNum * 0.04;\nfinal destination = (phase == 1) ? screenCenter : offScreenPosition;\ncard.doMove(\ndestination,\nspeed: (phase == 1) ? 15.0 : 5.0,\nstart: delay,\nonComplete: () {\ncardsToMove--;\nif (cardsToMove == 0) {\nif (phase == 1) {\nletsCelebrate(phase: 2);\n} else {\n// Restart with a new deal after winning or pressing \"Have fun\".\ngame.action = Action.newDeal;\ngame.world = KlondikeWorld();\n}\n}\n},\n);\ncardNum++;\nif (phase == 1) {\ncontinue;\n}\n\n// Phase 2: next card goes to same side with full spacing, if possible.\noffScreenPosition = offScreenPosition + direction[side] * spacing;\nspace = space - spacing;\nif ((space < 0.0) && (side < 3)) {\n// Out of space: change to the next side and use excess spacing there.\nside++;\noffScreenPosition = corner[side] + topLeft - direction[side] * space;\nspace = length[side] + space;\n}\n}\n}\n}"}
{"prompt": "Show me how to implement The Have fun button¶: But it is also time to have a look at the Ember Tutorial! using Flutter Flame", "completion": "import 'dart:math';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/flame.dart';\n\nimport 'components/card.dart';\nimport 'components/flat_button.dart';\nimport 'components/foundation_pile.dart';\nimport 'components/stock_pile.dart';\nimport 'components/tableau_pile.dart';\nimport 'components/waste_pile.dart';\n\nimport 'klondike_game.dart';\n\nclass KlondikeWorld extends World with HasGameReference<KlondikeGame> {\nfinal cardGap = KlondikeGame.cardGap;\nfinal topGap = KlondikeGame.topGap;\nfinal cardSpaceWidth = KlondikeGame.cardSpaceWidth;\nfinal cardSpaceHeight = KlondikeGame.cardSpaceHeight;\n\nfinal stock = StockPile(position: Vector2(0.0, 0.0));\nfinal waste = WastePile(position: Vector2(0.0, 0.0));\nfinal List<FoundationPile> foundations = [];\nfinal List<TableauPile> tableauPiles = [];\nfinal List<Card> cards = [];\nlate Vector2 playAreaSize;\n\n@override\nFuture<void> onLoad() async {\nawait Flame.images.load('klondike-sprites.png');\n\nstock.position = Vector2(cardGap, topGap);\nwaste.position = Vector2(cardSpaceWidth + cardGap, topGap);\n\nfor (var i = 0; i < 4; i++) {\nfoundations.add(\nFoundationPile(\ni,\ncheckWin,\nposition: Vector2((i + 3) * cardSpaceWidth + cardGap, topGap),\n),\n);\n}\nfor (var i = 0; i < 7; i++) {\ntableauPiles.add(\nTableauPile(\nposition: Vector2(\ni * cardSpaceWidth + cardGap,\ncardSpaceHeight + topGap,\n),\n),\n);\n}\n\n// Add a Base Card to the Stock Pile, above the pile and below other cards.\nfinal baseCard = Card(1, 0, isBaseCard: true);\nbaseCard.position = stock.position;\nbaseCard.priority = -1;\nbaseCard.pile = stock;\nstock.priority = -2;\n\nfor (var rank = 1; rank <= 13; rank++) {\nfor (var suit = 0; suit < 4; suit++) {\nfinal card = Card(rank, suit);\ncard.position = stock.position;\ncards.add(card);\n}\n}\n\nadd(stock);\nadd(waste);\naddAll(foundations);\naddAll(tableauPiles);\naddAll(cards);\nadd(baseCard);\n\nplayAreaSize =\nVector2(7 * cardSpaceWidth + cardGap, 4 * cardSpaceHeight + topGap);\nfinal gameMidX = playAreaSize.x / 2;\n\naddButton('New deal', gameMidX, Action.newDeal);\naddButton('Same deal', gameMidX + cardSpaceWidth, Action.sameDeal);\naddButton('Draw 1 or 3', gameMidX + 2 * cardSpaceWidth, Action.changeDraw);\naddButton('Have fun', gameMidX + 3 * cardSpaceWidth, Action.haveFun);\n\nfinal camera = game.camera;\ncamera.viewfinder.visibleGameSize = playAreaSize;\ncamera.viewfinder.position = Vector2(gameMidX, 0);\ncamera.viewfinder.anchor = Anchor.topCenter;\n\ndeal();\n}\n\nvoid addButton(String label, double buttonX, Action action) {\nfinal button = FlatButton(\nlabel,\nsize: Vector2(KlondikeGame.cardWidth, 0.6 * topGap),\nposition: Vector2(buttonX, topGap / 2),\nonReleased: () {\nif (action == Action.haveFun) {\n// Shortcut to the \"win\" sequence, for Tutorial purposes only.\nletsCelebrate();\n} else {\n// Restart with a new deal or the same deal as before.\ngame.action = action;\ngame.world = KlondikeWorld();\n}\n},\n);\nadd(button);\n}\n\nvoid deal() {\nassert(cards.length == 52, 'There are ${cards.length} cards: should be 52');\n\nif (game.action != Action.sameDeal) {\n// New deal: change the Random Number Generator's seed.\ngame.seed = Random().nextInt(KlondikeGame.maxInt);\nif (game.action == Action.changeDraw) {\ngame.klondikeDraw = (game.klondikeDraw == 3) ? 1 : 3;\n}\n}\n// For the \"Same deal\" option, re-use the previous seed, else use a new one.\ncards.shuffle(Random(game.seed));\n\n// Each card dealt must be seen to come from the top of the deck!\nvar dealPriority = 1;\nfor (final card in cards) {\ncard.priority = dealPriority++;\n}\n\n// Change priority as cards take off: so later cards fly above earlier ones.\nvar cardToDeal = cards.length - 1;\nvar nMovingCards = 0;\nfor (var i = 0; i < 7; i++) {\nfor (var j = i; j < 7; j++) {\nfinal card = cards[cardToDeal--];\ncard.doMove(\ntableauPiles[j].position,\nspeed: 15.0,\nstart: nMovingCards * 0.15,\nstartPriority: 100 + nMovingCards,\nonComplete: () {\ntableauPiles[j].acquireCard(card);\nnMovingCards--;\nif (nMovingCards == 0) {\nvar delayFactor = 0;\nfor (final tableauPile in tableauPiles) {\ndelayFactor++;\ntableauPile.flipTopCard(start: delayFactor * 0.15);\n}\n}\n},\n);\nnMovingCards++;\n}\n}\nfor (var n = 0; n <= cardToDeal; n++) {\nstock.acquireCard(cards[n]);\n}\n}\n\nvoid checkWin() {\n// Callback from a Foundation Pile when it is full (Ace to King).\nvar nComplete = 0;\nfor (final f in foundations) {\nif (f.isFull) {\nnComplete++;\n}\n}\nif (nComplete == foundations.length) {\nletsCelebrate();\n}\n}\n\nvoid letsCelebrate({int phase = 1}) {\n// Deal won: bring all cards to the middle of the screen (phase 1)\n// then scatter them to points just outside the screen (phase 2).\n//\n// First get the device's screen-size in game co-ordinates, then get the\n// top-left of the off-screen area that will accept the scattered cards.\n// Note: The play area is anchored at TopCenter, so topLeft.y is fixed.\n\nfinal cameraZoom = game.camera.viewfinder.zoom;\nfinal zoomedScreen = game.size / cameraZoom;\nfinal screenCenter = (playAreaSize - KlondikeGame.cardSize) / 2;\nfinal topLeft = Vector2(\n(playAreaSize.x - zoomedScreen.x) / 2 - KlondikeGame.cardWidth,\n-KlondikeGame.cardHeight,\n);\nfinal nCards = cards.length;\nfinal offscreenHeight = zoomedScreen.y + KlondikeGame.cardSize.y;\nfinal offscreenWidth = zoomedScreen.x + KlondikeGame.cardSize.x;\nfinal spacing = 2.0 * (offscreenHeight + offscreenWidth) / nCards;\n\n// Starting points, directions and lengths of offscreen rect's sides.\nfinal corner = [\nVector2(0.0, 0.0),\nVector2(0.0, offscreenHeight),\nVector2(offscreenWidth, offscreenHeight),\nVector2(offscreenWidth, 0.0),\n];\nfinal direction = [\nVector2(0.0, 1.0),\nVector2(1.0, 0.0),\nVector2(0.0, -1.0),\nVector2(-1.0, 0.0),\n];\nfinal length = [\noffscreenHeight,\noffscreenWidth,\noffscreenHeight,\noffscreenWidth,\n];\n\nvar side = 0;\nvar cardsToMove = nCards;\nvar offScreenPosition = corner[side] + topLeft;\nvar space = length[side];\nvar cardNum = 0;\n\nwhile (cardNum < nCards) {\nfinal cardIndex = phase == 1 ? cardNum : nCards - cardNum - 1;\nfinal card = cards[cardIndex];\ncard.priority = cardIndex + 1;\nif (card.isFaceDown) {\ncard.flip();\n}\n// Start cards a short time apart to give a riffle effect.\nfinal delay = phase == 1 ? cardNum * 0.02 : 0.5 + cardNum * 0.04;\nfinal destination = (phase == 1) ? screenCenter : offScreenPosition;\ncard.doMove(\ndestination,\nspeed: (phase == 1) ? 15.0 : 5.0,\nstart: delay,\nonComplete: () {\ncardsToMove--;\nif (cardsToMove == 0) {\nif (phase == 1) {\nletsCelebrate(phase: 2);\n} else {\n// Restart with a new deal after winning or pressing \"Have fun\".\ngame.action = Action.newDeal;\ngame.world = KlondikeWorld();\n}\n}\n},\n);\ncardNum++;\nif (phase == 1) {\ncontinue;\n}\n\n// Phase 2: next card goes to same side with full spacing, if possible.\noffScreenPosition = offScreenPosition + direction[side] * spacing;\nspace = space - spacing;\nif ((space < 0.0) && (side < 3)) {\n// Out of space: change to the next side and use excess spacing there.\nside++;\noffScreenPosition = corner[side] + topLeft - direction[side] * space;\nspace = length[side] + space;\n}\n}\n}\n}"}
{"prompt": "Write Flutter Flame code to The Have fun button¶: But it is also time to have a look at the Ember Tutorial!", "completion": "import 'dart:math';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/flame.dart';\n\nimport 'components/card.dart';\nimport 'components/flat_button.dart';\nimport 'components/foundation_pile.dart';\nimport 'components/stock_pile.dart';\nimport 'components/tableau_pile.dart';\nimport 'components/waste_pile.dart';\n\nimport 'klondike_game.dart';\n\nclass KlondikeWorld extends World with HasGameReference<KlondikeGame> {\nfinal cardGap = KlondikeGame.cardGap;\nfinal topGap = KlondikeGame.topGap;\nfinal cardSpaceWidth = KlondikeGame.cardSpaceWidth;\nfinal cardSpaceHeight = KlondikeGame.cardSpaceHeight;\n\nfinal stock = StockPile(position: Vector2(0.0, 0.0));\nfinal waste = WastePile(position: Vector2(0.0, 0.0));\nfinal List<FoundationPile> foundations = [];\nfinal List<TableauPile> tableauPiles = [];\nfinal List<Card> cards = [];\nlate Vector2 playAreaSize;\n\n@override\nFuture<void> onLoad() async {\nawait Flame.images.load('klondike-sprites.png');\n\nstock.position = Vector2(cardGap, topGap);\nwaste.position = Vector2(cardSpaceWidth + cardGap, topGap);\n\nfor (var i = 0; i < 4; i++) {\nfoundations.add(\nFoundationPile(\ni,\ncheckWin,\nposition: Vector2((i + 3) * cardSpaceWidth + cardGap, topGap),\n),\n);\n}\nfor (var i = 0; i < 7; i++) {\ntableauPiles.add(\nTableauPile(\nposition: Vector2(\ni * cardSpaceWidth + cardGap,\ncardSpaceHeight + topGap,\n),\n),\n);\n}\n\n// Add a Base Card to the Stock Pile, above the pile and below other cards.\nfinal baseCard = Card(1, 0, isBaseCard: true);\nbaseCard.position = stock.position;\nbaseCard.priority = -1;\nbaseCard.pile = stock;\nstock.priority = -2;\n\nfor (var rank = 1; rank <= 13; rank++) {\nfor (var suit = 0; suit < 4; suit++) {\nfinal card = Card(rank, suit);\ncard.position = stock.position;\ncards.add(card);\n}\n}\n\nadd(stock);\nadd(waste);\naddAll(foundations);\naddAll(tableauPiles);\naddAll(cards);\nadd(baseCard);\n\nplayAreaSize =\nVector2(7 * cardSpaceWidth + cardGap, 4 * cardSpaceHeight + topGap);\nfinal gameMidX = playAreaSize.x / 2;\n\naddButton('New deal', gameMidX, Action.newDeal);\naddButton('Same deal', gameMidX + cardSpaceWidth, Action.sameDeal);\naddButton('Draw 1 or 3', gameMidX + 2 * cardSpaceWidth, Action.changeDraw);\naddButton('Have fun', gameMidX + 3 * cardSpaceWidth, Action.haveFun);\n\nfinal camera = game.camera;\ncamera.viewfinder.visibleGameSize = playAreaSize;\ncamera.viewfinder.position = Vector2(gameMidX, 0);\ncamera.viewfinder.anchor = Anchor.topCenter;\n\ndeal();\n}\n\nvoid addButton(String label, double buttonX, Action action) {\nfinal button = FlatButton(\nlabel,\nsize: Vector2(KlondikeGame.cardWidth, 0.6 * topGap),\nposition: Vector2(buttonX, topGap / 2),\nonReleased: () {\nif (action == Action.haveFun) {\n// Shortcut to the \"win\" sequence, for Tutorial purposes only.\nletsCelebrate();\n} else {\n// Restart with a new deal or the same deal as before.\ngame.action = action;\ngame.world = KlondikeWorld();\n}\n},\n);\nadd(button);\n}\n\nvoid deal() {\nassert(cards.length == 52, 'There are ${cards.length} cards: should be 52');\n\nif (game.action != Action.sameDeal) {\n// New deal: change the Random Number Generator's seed.\ngame.seed = Random().nextInt(KlondikeGame.maxInt);\nif (game.action == Action.changeDraw) {\ngame.klondikeDraw = (game.klondikeDraw == 3) ? 1 : 3;\n}\n}\n// For the \"Same deal\" option, re-use the previous seed, else use a new one.\ncards.shuffle(Random(game.seed));\n\n// Each card dealt must be seen to come from the top of the deck!\nvar dealPriority = 1;\nfor (final card in cards) {\ncard.priority = dealPriority++;\n}\n\n// Change priority as cards take off: so later cards fly above earlier ones.\nvar cardToDeal = cards.length - 1;\nvar nMovingCards = 0;\nfor (var i = 0; i < 7; i++) {\nfor (var j = i; j < 7; j++) {\nfinal card = cards[cardToDeal--];\ncard.doMove(\ntableauPiles[j].position,\nspeed: 15.0,\nstart: nMovingCards * 0.15,\nstartPriority: 100 + nMovingCards,\nonComplete: () {\ntableauPiles[j].acquireCard(card);\nnMovingCards--;\nif (nMovingCards == 0) {\nvar delayFactor = 0;\nfor (final tableauPile in tableauPiles) {\ndelayFactor++;\ntableauPile.flipTopCard(start: delayFactor * 0.15);\n}\n}\n},\n);\nnMovingCards++;\n}\n}\nfor (var n = 0; n <= cardToDeal; n++) {\nstock.acquireCard(cards[n]);\n}\n}\n\nvoid checkWin() {\n// Callback from a Foundation Pile when it is full (Ace to King).\nvar nComplete = 0;\nfor (final f in foundations) {\nif (f.isFull) {\nnComplete++;\n}\n}\nif (nComplete == foundations.length) {\nletsCelebrate();\n}\n}\n\nvoid letsCelebrate({int phase = 1}) {\n// Deal won: bring all cards to the middle of the screen (phase 1)\n// then scatter them to points just outside the screen (phase 2).\n//\n// First get the device's screen-size in game co-ordinates, then get the\n// top-left of the off-screen area that will accept the scattered cards.\n// Note: The play area is anchored at TopCenter, so topLeft.y is fixed.\n\nfinal cameraZoom = game.camera.viewfinder.zoom;\nfinal zoomedScreen = game.size / cameraZoom;\nfinal screenCenter = (playAreaSize - KlondikeGame.cardSize) / 2;\nfinal topLeft = Vector2(\n(playAreaSize.x - zoomedScreen.x) / 2 - KlondikeGame.cardWidth,\n-KlondikeGame.cardHeight,\n);\nfinal nCards = cards.length;\nfinal offscreenHeight = zoomedScreen.y + KlondikeGame.cardSize.y;\nfinal offscreenWidth = zoomedScreen.x + KlondikeGame.cardSize.x;\nfinal spacing = 2.0 * (offscreenHeight + offscreenWidth) / nCards;\n\n// Starting points, directions and lengths of offscreen rect's sides.\nfinal corner = [\nVector2(0.0, 0.0),\nVector2(0.0, offscreenHeight),\nVector2(offscreenWidth, offscreenHeight),\nVector2(offscreenWidth, 0.0),\n];\nfinal direction = [\nVector2(0.0, 1.0),\nVector2(1.0, 0.0),\nVector2(0.0, -1.0),\nVector2(-1.0, 0.0),\n];\nfinal length = [\noffscreenHeight,\noffscreenWidth,\noffscreenHeight,\noffscreenWidth,\n];\n\nvar side = 0;\nvar cardsToMove = nCards;\nvar offScreenPosition = corner[side] + topLeft;\nvar space = length[side];\nvar cardNum = 0;\n\nwhile (cardNum < nCards) {\nfinal cardIndex = phase == 1 ? cardNum : nCards - cardNum - 1;\nfinal card = cards[cardIndex];\ncard.priority = cardIndex + 1;\nif (card.isFaceDown) {\ncard.flip();\n}\n// Start cards a short time apart to give a riffle effect.\nfinal delay = phase == 1 ? cardNum * 0.02 : 0.5 + cardNum * 0.04;\nfinal destination = (phase == 1) ? screenCenter : offScreenPosition;\ncard.doMove(\ndestination,\nspeed: (phase == 1) ? 15.0 : 5.0,\nstart: delay,\nonComplete: () {\ncardsToMove--;\nif (cardsToMove == 0) {\nif (phase == 1) {\nletsCelebrate(phase: 2);\n} else {\n// Restart with a new deal after winning or pressing \"Have fun\".\ngame.action = Action.newDeal;\ngame.world = KlondikeWorld();\n}\n}\n},\n);\ncardNum++;\nif (phase == 1) {\ncontinue;\n}\n\n// Phase 2: next card goes to same side with full spacing, if possible.\noffScreenPosition = offScreenPosition + direction[side] * spacing;\nspace = space - spacing;\nif ((space < 0.0) && (side < 3)) {\n// Out of space: change to the next side and use excess spacing there.\nside++;\noffScreenPosition = corner[side] + topLeft - direction[side] * space;\nspace = length[side] + space;\n}\n}\n}\n}"}
{"prompt": "Create a Flutter Flame game component that The Have fun button¶: But it is also time to have a look at the Ember Tutorial!", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'klondike_game.dart';\n\nvoid main() {\nfinal game = KlondikeGame();\nrunApp(GameWidget(game: game));\n}"}
{"prompt": "Show me how to implement The Have fun button¶: But it is also time to have a look at the Ember Tutorial! using Flutter Flame", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'klondike_game.dart';\n\nvoid main() {\nfinal game = KlondikeGame();\nrunApp(GameWidget(game: game));\n}"}
{"prompt": "Write Flutter Flame code to The Have fun button¶: But it is also time to have a look at the Ember Tutorial!", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'klondike_game.dart';\n\nvoid main() {\nfinal game = KlondikeGame();\nrunApp(GameWidget(game: game));\n}"}
{"prompt": "Create a Flutter Flame game component that The Have fun button¶: But it is also time to have a look at the Ember Tutorial!", "completion": "import 'components/card.dart';\n\nenum MoveMethod { drag, tap }\n\nabstract class Pile {\n/// Returns true if the [card] can be taken away from this pile and moved\n/// somewhere else. A tapping move may need additional validation.\nbool canMoveCard(Card card, MoveMethod method);\n\n/// Returns true if the [card] can be placed on top of this pile. The [card]\n/// may have other cards \"attached\" to it.\nbool canAcceptCard(Card card);\n\n/// Removes [card] from this pile; this method will only be called for a card\n/// that both belong to this pile, and for which [canMoveCard] returns true.\nvoid removeCard(Card card, MoveMethod method);\n\n/// Places a single [card] on top of this pile. This method will only be\n/// called for a card for which [canAcceptCard] returns true.\nvoid acquireCard(Card card);\n\n/// Returns a [card], which already belongs to this pile, to its proper place.\nvoid returnCard(Card card);\n}"}
{"prompt": "Show me how to implement The Have fun button¶: But it is also time to have a look at the Ember Tutorial! using Flutter Flame", "completion": "import 'components/card.dart';\n\nenum MoveMethod { drag, tap }\n\nabstract class Pile {\n/// Returns true if the [card] can be taken away from this pile and moved\n/// somewhere else. A tapping move may need additional validation.\nbool canMoveCard(Card card, MoveMethod method);\n\n/// Returns true if the [card] can be placed on top of this pile. The [card]\n/// may have other cards \"attached\" to it.\nbool canAcceptCard(Card card);\n\n/// Removes [card] from this pile; this method will only be called for a card\n/// that both belong to this pile, and for which [canMoveCard] returns true.\nvoid removeCard(Card card, MoveMethod method);\n\n/// Places a single [card] on top of this pile. This method will only be\n/// called for a card for which [canAcceptCard] returns true.\nvoid acquireCard(Card card);\n\n/// Returns a [card], which already belongs to this pile, to its proper place.\nvoid returnCard(Card card);\n}"}
{"prompt": "Write Flutter Flame code to The Have fun button¶: But it is also time to have a look at the Ember Tutorial!", "completion": "import 'components/card.dart';\n\nenum MoveMethod { drag, tap }\n\nabstract class Pile {\n/// Returns true if the [card] can be taken away from this pile and moved\n/// somewhere else. A tapping move may need additional validation.\nbool canMoveCard(Card card, MoveMethod method);\n\n/// Returns true if the [card] can be placed on top of this pile. The [card]\n/// may have other cards \"attached\" to it.\nbool canAcceptCard(Card card);\n\n/// Removes [card] from this pile; this method will only be called for a card\n/// that both belong to this pile, and for which [canMoveCard] returns true.\nvoid removeCard(Card card, MoveMethod method);\n\n/// Places a single [card] on top of this pile. This method will only be\n/// called for a card for which [canAcceptCard] returns true.\nvoid acquireCard(Card card);\n\n/// Returns a [card], which already belongs to this pile, to its proper place.\nvoid returnCard(Card card);\n}"}
{"prompt": "Create a Flutter Flame game component that The Have fun button¶: But it is also time to have a look at the Ember Tutorial!", "completion": "import 'package:flame/components.dart';\nimport 'package:flutter/foundation.dart';\nimport 'klondike_game.dart';\n\n@immutable\nclass Rank {\nfactory Rank.fromInt(int value) {\nassert(\nvalue >= 1 && value <= 13,\n'value is outside of the bounds of what a rank can be',\n);\nreturn _singletons[value - 1];\n}\n\nRank._(\nthis.value,\nthis.label,\ndouble x1,\ndouble y1,\ndouble x2,\ndouble y2,\ndouble w,\ndouble h,\n)   : redSprite = klondikeSprite(x1, y1, w, h),\nblackSprite = klondikeSprite(x2, y2, w, h);\n\nfinal int value;\nfinal String label;\nfinal Sprite redSprite;\nfinal Sprite blackSprite;\n\nstatic final List<Rank> _singletons = [\nRank._(1, 'A', 335, 164, 789, 161, 120, 129),\nRank._(2, '2', 20, 19, 15, 322, 83, 125),\nRank._(3, '3', 122, 19, 117, 322, 80, 127),\nRank._(4, '4', 213, 12, 208, 315, 93, 132),\nRank._(5, '5', 314, 21, 309, 324, 85, 125),\nRank._(6, '6', 419, 17, 414, 320, 84, 129),\nRank._(7, '7', 509, 21, 505, 324, 92, 128),\nRank._(8, '8', 612, 19, 607, 322, 78, 127),\nRank._(9, '9', 709, 19, 704, 322, 84, 130),\nRank._(10, '10', 810, 20, 805, 322, 137, 127),\nRank._(11, 'J', 15, 170, 469, 167, 56, 126),\nRank._(12, 'Q', 92, 168, 547, 165, 132, 128),\nRank._(13, 'K', 243, 170, 696, 167, 92, 123),\n];\n}"}
{"prompt": "Show me how to implement The Have fun button¶: But it is also time to have a look at the Ember Tutorial! using Flutter Flame", "completion": "import 'package:flame/components.dart';\nimport 'package:flutter/foundation.dart';\nimport 'klondike_game.dart';\n\n@immutable\nclass Rank {\nfactory Rank.fromInt(int value) {\nassert(\nvalue >= 1 && value <= 13,\n'value is outside of the bounds of what a rank can be',\n);\nreturn _singletons[value - 1];\n}\n\nRank._(\nthis.value,\nthis.label,\ndouble x1,\ndouble y1,\ndouble x2,\ndouble y2,\ndouble w,\ndouble h,\n)   : redSprite = klondikeSprite(x1, y1, w, h),\nblackSprite = klondikeSprite(x2, y2, w, h);\n\nfinal int value;\nfinal String label;\nfinal Sprite redSprite;\nfinal Sprite blackSprite;\n\nstatic final List<Rank> _singletons = [\nRank._(1, 'A', 335, 164, 789, 161, 120, 129),\nRank._(2, '2', 20, 19, 15, 322, 83, 125),\nRank._(3, '3', 122, 19, 117, 322, 80, 127),\nRank._(4, '4', 213, 12, 208, 315, 93, 132),\nRank._(5, '5', 314, 21, 309, 324, 85, 125),\nRank._(6, '6', 419, 17, 414, 320, 84, 129),\nRank._(7, '7', 509, 21, 505, 324, 92, 128),\nRank._(8, '8', 612, 19, 607, 322, 78, 127),\nRank._(9, '9', 709, 19, 704, 322, 84, 130),\nRank._(10, '10', 810, 20, 805, 322, 137, 127),\nRank._(11, 'J', 15, 170, 469, 167, 56, 126),\nRank._(12, 'Q', 92, 168, 547, 165, 132, 128),\nRank._(13, 'K', 243, 170, 696, 167, 92, 123),\n];\n}"}
{"prompt": "Write Flutter Flame code to The Have fun button¶: But it is also time to have a look at the Ember Tutorial!", "completion": "import 'package:flame/components.dart';\nimport 'package:flutter/foundation.dart';\nimport 'klondike_game.dart';\n\n@immutable\nclass Rank {\nfactory Rank.fromInt(int value) {\nassert(\nvalue >= 1 && value <= 13,\n'value is outside of the bounds of what a rank can be',\n);\nreturn _singletons[value - 1];\n}\n\nRank._(\nthis.value,\nthis.label,\ndouble x1,\ndouble y1,\ndouble x2,\ndouble y2,\ndouble w,\ndouble h,\n)   : redSprite = klondikeSprite(x1, y1, w, h),\nblackSprite = klondikeSprite(x2, y2, w, h);\n\nfinal int value;\nfinal String label;\nfinal Sprite redSprite;\nfinal Sprite blackSprite;\n\nstatic final List<Rank> _singletons = [\nRank._(1, 'A', 335, 164, 789, 161, 120, 129),\nRank._(2, '2', 20, 19, 15, 322, 83, 125),\nRank._(3, '3', 122, 19, 117, 322, 80, 127),\nRank._(4, '4', 213, 12, 208, 315, 93, 132),\nRank._(5, '5', 314, 21, 309, 324, 85, 125),\nRank._(6, '6', 419, 17, 414, 320, 84, 129),\nRank._(7, '7', 509, 21, 505, 324, 92, 128),\nRank._(8, '8', 612, 19, 607, 322, 78, 127),\nRank._(9, '9', 709, 19, 704, 322, 84, 130),\nRank._(10, '10', 810, 20, 805, 322, 137, 127),\nRank._(11, 'J', 15, 170, 469, 167, 56, 126),\nRank._(12, 'Q', 92, 168, 547, 165, 132, 128),\nRank._(13, 'K', 243, 170, 696, 167, 92, 123),\n];\n}"}
{"prompt": "Create a Flutter Flame game component that The Have fun button¶: But it is also time to have a look at the Ember Tutorial!", "completion": "import 'package:flame/sprite.dart';\nimport 'package:flutter/foundation.dart';\nimport 'klondike_game.dart';\n\n@immutable\nclass Suit {\nfactory Suit.fromInt(int index) {\nassert(\nindex >= 0 && index <= 3,\n'index is outside of the bounds of what a suit can be',\n);\nreturn _singletons[index];\n}\n\nSuit._(this.value, this.label, double x, double y, double w, double h)\n: sprite = klondikeSprite(x, y, w, h);\n\nfinal int value;\nfinal String label;\nfinal Sprite sprite;\n\nstatic final List<Suit> _singletons = [\nSuit._(0, '♥', 1176, 17, 172, 183),\nSuit._(1, '♦', 973, 14, 177, 182),\nSuit._(2, '♣', 974, 226, 184, 172),\nSuit._(3, '♠', 1178, 220, 176, 182),\n];\n\n/// Hearts and Diamonds are red, while Clubs and Spades are black.\nbool get isRed => value <= 1;\nbool get isBlack => value >= 2;\n}"}
{"prompt": "Show me how to implement The Have fun button¶: But it is also time to have a look at the Ember Tutorial! using Flutter Flame", "completion": "import 'package:flame/sprite.dart';\nimport 'package:flutter/foundation.dart';\nimport 'klondike_game.dart';\n\n@immutable\nclass Suit {\nfactory Suit.fromInt(int index) {\nassert(\nindex >= 0 && index <= 3,\n'index is outside of the bounds of what a suit can be',\n);\nreturn _singletons[index];\n}\n\nSuit._(this.value, this.label, double x, double y, double w, double h)\n: sprite = klondikeSprite(x, y, w, h);\n\nfinal int value;\nfinal String label;\nfinal Sprite sprite;\n\nstatic final List<Suit> _singletons = [\nSuit._(0, '♥', 1176, 17, 172, 183),\nSuit._(1, '♦', 973, 14, 177, 182),\nSuit._(2, '♣', 974, 226, 184, 172),\nSuit._(3, '♠', 1178, 220, 176, 182),\n];\n\n/// Hearts and Diamonds are red, while Clubs and Spades are black.\nbool get isRed => value <= 1;\nbool get isBlack => value >= 2;\n}"}
{"prompt": "Write Flutter Flame code to The Have fun button¶: But it is also time to have a look at the Ember Tutorial!", "completion": "import 'package:flame/sprite.dart';\nimport 'package:flutter/foundation.dart';\nimport 'klondike_game.dart';\n\n@immutable\nclass Suit {\nfactory Suit.fromInt(int index) {\nassert(\nindex >= 0 && index <= 3,\n'index is outside of the bounds of what a suit can be',\n);\nreturn _singletons[index];\n}\n\nSuit._(this.value, this.label, double x, double y, double w, double h)\n: sprite = klondikeSprite(x, y, w, h);\n\nfinal int value;\nfinal String label;\nfinal Sprite sprite;\n\nstatic final List<Suit> _singletons = [\nSuit._(0, '♥', 1176, 17, 172, 183),\nSuit._(1, '♦', 973, 14, 177, 182),\nSuit._(2, '♣', 974, 226, 184, 172),\nSuit._(3, '♠', 1178, 220, 176, 182),\n];\n\n/// Hearts and Diamonds are red, while Clubs and Spades are black.\nbool get isRed => value <= 1;\nbool get isBlack => value >= 2;\n}"}
{"prompt": "Create a Flutter Flame game component that FlameBlocProvider¶: FlameBlocProvider should be used to create new blocs which will be made available to the rest of the subtree.", "completion": "FlameBlocProvider<BlocA, BlocAState>(\n  create: () => BlocA(),\n  children: [...]\n);"}
{"prompt": "Show me how to implement FlameBlocProvider¶: FlameBlocProvider should be used to create new blocs which will be made available to the rest of the subtree. using Flutter Flame", "completion": "FlameBlocProvider<BlocA, BlocAState>(\n  create: () => BlocA(),\n  children: [...]\n);"}
{"prompt": "Write Flutter Flame code to FlameBlocProvider¶: FlameBlocProvider should be used to create new blocs which will be made available to the rest of the subtree.", "completion": "FlameBlocProvider<BlocA, BlocAState>(\n  create: () => BlocA(),\n  children: [...]\n);"}
{"prompt": "Create a Flutter Flame game component that FlameBlocProvider¶: FlameBlocProvider can be used to provide an existing bloc to a new portion of the Component tree.", "completion": "FlameBlocProvider<BlocA, BlocAState>.value(\n  value: blocA,\n  children: [...],\n);"}
{"prompt": "Show me how to implement FlameBlocProvider¶: FlameBlocProvider can be used to provide an existing bloc to a new portion of the Component tree. using Flutter Flame", "completion": "FlameBlocProvider<BlocA, BlocAState>.value(\n  value: blocA,\n  children: [...],\n);"}
{"prompt": "Write Flutter Flame code to FlameBlocProvider¶: FlameBlocProvider can be used to provide an existing bloc to a new portion of the Component tree.", "completion": "FlameBlocProvider<BlocA, BlocAState>.value(\n  value: blocA,\n  children: [...],\n);"}
{"prompt": "Create a Flutter Flame game component that FlameMultiBlocProvider¶: Similar to FlameBlocProvider, but provides multiples blocs down to the component tree", "completion": "FlameMultiBlocProvider(\n  providers: [\n    FlameBlocProvider<BlocA, BlocAState>(\n      create: () => BlocA(),\n    ),\n    FlameBlocProvider<BlocB, BlocBState>.value(\n      create: () => BlocB(),\n    ),\n    ],\n  children: [...],\n)"}
{"prompt": "Show me how to implement FlameMultiBlocProvider¶: Similar to FlameBlocProvider, but provides multiples blocs down to the component tree using Flutter Flame", "completion": "FlameMultiBlocProvider(\n  providers: [\n    FlameBlocProvider<BlocA, BlocAState>(\n      create: () => BlocA(),\n    ),\n    FlameBlocProvider<BlocB, BlocBState>.value(\n      create: () => BlocB(),\n    ),\n    ],\n  children: [...],\n)"}
{"prompt": "Write Flutter Flame code to FlameMultiBlocProvider¶: Similar to FlameBlocProvider, but provides multiples blocs down to the component tree", "completion": "FlameMultiBlocProvider(\n  providers: [\n    FlameBlocProvider<BlocA, BlocAState>(\n      create: () => BlocA(),\n    ),\n    FlameBlocProvider<BlocB, BlocBState>.value(\n      create: () => BlocB(),\n    ),\n    ],\n  children: [...],\n)"}
{"prompt": "Create a Flutter Flame game component that FlameBlocListener¶: alternatively you can use FlameBlocListenable mixin to listen state changes on Component.", "completion": "FlameBlocListener<GameStatsBloc, GameStatsState>(\n  listenWhen: (previousState, newState) {\n      // return true/false to determine whether or not\n      // to call listener with state\n  },\n  onNewState: (state) {\n          // do stuff here based on state\n  },\n)"}
{"prompt": "Show me how to implement FlameBlocListener¶: alternatively you can use FlameBlocListenable mixin to listen state changes on Component. using Flutter Flame", "completion": "FlameBlocListener<GameStatsBloc, GameStatsState>(\n  listenWhen: (previousState, newState) {\n      // return true/false to determine whether or not\n      // to call listener with state\n  },\n  onNewState: (state) {\n          // do stuff here based on state\n  },\n)"}
{"prompt": "Write Flutter Flame code to FlameBlocListener¶: alternatively you can use FlameBlocListenable mixin to listen state changes on Component.", "completion": "FlameBlocListener<GameStatsBloc, GameStatsState>(\n  listenWhen: (previousState, newState) {\n      // return true/false to determine whether or not\n      // to call listener with state\n  },\n  onNewState: (state) {\n          // do stuff here based on state\n  },\n)"}
{"prompt": "Create a Flutter Flame game component that FlameBlocListenable¶: FlameBlocListenable is an alternative to FlameBlocListener to listen state changes.", "completion": "class ComponentA extends Component\n    with FlameBlocListenable<BlocA, BlocAState> {\n\n  @override\n  bool listenWhen(PlayerState previousState, PlayerState newState) {\n    // return true/false to determine whether or not\n    // to call listener with state\n  }\n\n  @override\n  void onNewState(PlayerState state) {\n    super.onNewState(state);\n    // do stuff here based on state\n  }\n}"}
{"prompt": "Show me how to implement FlameBlocListenable¶: FlameBlocListenable is an alternative to FlameBlocListener to listen state changes. using Flutter Flame", "completion": "class ComponentA extends Component\n    with FlameBlocListenable<BlocA, BlocAState> {\n\n  @override\n  bool listenWhen(PlayerState previousState, PlayerState newState) {\n    // return true/false to determine whether or not\n    // to call listener with state\n  }\n\n  @override\n  void onNewState(PlayerState state) {\n    super.onNewState(state);\n    // do stuff here based on state\n  }\n}"}
{"prompt": "Write Flutter Flame code to FlameBlocListenable¶: FlameBlocListenable is an alternative to FlameBlocListener to listen state changes.", "completion": "class ComponentA extends Component\n    with FlameBlocListenable<BlocA, BlocAState> {\n\n  @override\n  bool listenWhen(PlayerState previousState, PlayerState newState) {\n    // return true/false to determine whether or not\n    // to call listener with state\n  }\n\n  @override\n  void onNewState(PlayerState state) {\n    super.onNewState(state);\n    // do stuff here based on state\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that FlameBlocReader¶: FlameBlocReader is mixin that allows you to read the current state of bloc on Component. It is Useful for components that needs to only read a bloc current state or to trigger an event on it. You can have only one reader on Component", "completion": "class InventoryReader extends Component\n    with FlameBlocReader<InventoryCubit, InventoryState> {}\n\n    /// inside game\n    \n    final component = InventoryReader();\n    // reading current state\n    var state = component.bloc"}
{"prompt": "Show me how to implement FlameBlocReader¶: FlameBlocReader is mixin that allows you to read the current state of bloc on Component. It is Useful for components that needs to only read a bloc current state or to trigger an event on it. You can have only one reader on Component using Flutter Flame", "completion": "class InventoryReader extends Component\n    with FlameBlocReader<InventoryCubit, InventoryState> {}\n\n    /// inside game\n    \n    final component = InventoryReader();\n    // reading current state\n    var state = component.bloc"}
{"prompt": "Write Flutter Flame code to FlameBlocReader¶: FlameBlocReader is mixin that allows you to read the current state of bloc on Component. It is Useful for components that needs to only read a bloc current state or to trigger an event on it. You can have only one reader on Component", "completion": "class InventoryReader extends Component\n    with FlameBlocReader<InventoryCubit, InventoryState> {}\n\n    /// inside game\n    \n    final component = InventoryReader();\n    // reading current state\n    var state = component.bloc"}
{"prompt": "Create a Flutter Flame game component that FlameGame¶: A simple FlameGame implementation that adds two components, one in onLoad and one directly in the constructor can look like this:", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/game.dart';\nimport 'package:flutter/widgets.dart';\n\n/// A component that renders the crate sprite, with a 16 x 16 size.\nclass MyCrate extends SpriteComponent {\n  MyCrate() : super(size: Vector2.all(16));\n\n  @override\n  Future<void> onLoad() async {\n    sprite = await Sprite.load('crate.png');\n  }\n}\n\nclass MyWorld extends World {\n  @override\n  Future<void> onLoad() async {\n    await add(MyCrate());\n  }\n}\n\nvoid main() {\n  final myGame = FlameGame(world: MyWorld());\n  runApp(\n    GameWidget(game: myGame),\n  );\n}"}
{"prompt": "Show me how to implement FlameGame¶: A simple FlameGame implementation that adds two components, one in onLoad and one directly in the constructor can look like this: using Flutter Flame", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/game.dart';\nimport 'package:flutter/widgets.dart';\n\n/// A component that renders the crate sprite, with a 16 x 16 size.\nclass MyCrate extends SpriteComponent {\n  MyCrate() : super(size: Vector2.all(16));\n\n  @override\n  Future<void> onLoad() async {\n    sprite = await Sprite.load('crate.png');\n  }\n}\n\nclass MyWorld extends World {\n  @override\n  Future<void> onLoad() async {\n    await add(MyCrate());\n  }\n}\n\nvoid main() {\n  final myGame = FlameGame(world: MyWorld());\n  runApp(\n    GameWidget(game: myGame),\n  );\n}"}
{"prompt": "Write Flutter Flame code to FlameGame¶: A simple FlameGame implementation that adds two components, one in onLoad and one directly in the constructor can look like this:", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/game.dart';\nimport 'package:flutter/widgets.dart';\n\n/// A component that renders the crate sprite, with a 16 x 16 size.\nclass MyCrate extends SpriteComponent {\n  MyCrate() : super(size: Vector2.all(16));\n\n  @override\n  Future<void> onLoad() async {\n    sprite = await Sprite.load('crate.png');\n  }\n}\n\nclass MyWorld extends World {\n  @override\n  Future<void> onLoad() async {\n    await add(MyCrate());\n  }\n}\n\nvoid main() {\n  final myGame = FlameGame(world: MyWorld());\n  runApp(\n    GameWidget(game: myGame),\n  );\n}"}
{"prompt": "Create a Flutter Flame game component that Lifecycle¶: The onRemove callback can be used to clean up children and cached data:", "completion": "@override\n  void onRemove() {\n    // Optional based on your game needs.\n    removeAll(children);\n    processLifecycleEvents();\n    Flame.images.clearCache();\n    Flame.assets.clearCache();\n    // Any other code that you want to run when the game is removed.\n  }"}
{"prompt": "Show me how to implement Lifecycle¶: The onRemove callback can be used to clean up children and cached data: using Flutter Flame", "completion": "@override\n  void onRemove() {\n    // Optional based on your game needs.\n    removeAll(children);\n    processLifecycleEvents();\n    Flame.images.clearCache();\n    Flame.assets.clearCache();\n    // Any other code that you want to run when the game is removed.\n  }"}
{"prompt": "Write Flutter Flame code to Lifecycle¶: The onRemove callback can be used to clean up children and cached data:", "completion": "@override\n  void onRemove() {\n    // Optional based on your game needs.\n    removeAll(children);\n    processLifecycleEvents();\n    Flame.images.clearCache();\n    Flame.assets.clearCache();\n    // Any other code that you want to run when the game is removed.\n  }"}
{"prompt": "Create a Flutter Flame game component that Change background color¶: In the following example, the background color is set to be fully transparent, so that you can see the widgets that are behind the GameWidget. The default is opaque black.", "completion": "class MyGame extends FlameGame {\n  @override\n  Color backgroundColor() => const Color(0x00000000);\n}"}
{"prompt": "Show me how to implement Change background color¶: In the following example, the background color is set to be fully transparent, so that you can see the widgets that are behind the GameWidget. The default is opaque black. using Flutter Flame", "completion": "class MyGame extends FlameGame {\n  @override\n  Color backgroundColor() => const Color(0x00000000);\n}"}
{"prompt": "Write Flutter Flame code to Change background color¶: In the following example, the background color is set to be fully transparent, so that you can see the widgets that are behind the GameWidget. The default is opaque black.", "completion": "class MyGame extends FlameGame {\n  @override\n  Color backgroundColor() => const Color(0x00000000);\n}"}
{"prompt": "Create a Flutter Flame game component that SingleGameInstance mixin¶: Using this mixin is simple:", "completion": "class MyGame extends FlameGame with SingleGameInstance {\n  // ...\n}"}
{"prompt": "Show me how to implement SingleGameInstance mixin¶: Using this mixin is simple: using Flutter Flame", "completion": "class MyGame extends FlameGame with SingleGameInstance {\n  // ...\n}"}
{"prompt": "Write Flutter Flame code to SingleGameInstance mixin¶: Using this mixin is simple:", "completion": "class MyGame extends FlameGame with SingleGameInstance {\n  // ...\n}"}
{"prompt": "Create a Flutter Flame game component that Low-level Game API¶: An example of how a Game implementation could look like is:", "completion": "class MyGameSubClass extends Game {\n  @override\n  void render(Canvas canvas) {\n    // ...\n  }\n\n  @override\n  void update(double dt) {\n    // ...\n  }\n}\n\nvoid main() {\n  final myGame = MyGameSubClass();\n  runApp(\n    GameWidget(\n      game: myGame,\n    )\n  );\n}"}
{"prompt": "Show me how to implement Low-level Game API¶: An example of how a Game implementation could look like is: using Flutter Flame", "completion": "class MyGameSubClass extends Game {\n  @override\n  void render(Canvas canvas) {\n    // ...\n  }\n\n  @override\n  void update(double dt) {\n    // ...\n  }\n}\n\nvoid main() {\n  final myGame = MyGameSubClass();\n  runApp(\n    GameWidget(\n      game: myGame,\n    )\n  );\n}"}
{"prompt": "Write Flutter Flame code to Low-level Game API¶: An example of how a Game implementation could look like is:", "completion": "class MyGameSubClass extends Game {\n  @override\n  void render(Canvas canvas) {\n    // ...\n  }\n\n  @override\n  void update(double dt) {\n    // ...\n  }\n}\n\nvoid main() {\n  final myGame = MyGameSubClass();\n  runApp(\n    GameWidget(\n      game: myGame,\n    )\n  );\n}"}
{"prompt": "Create a Flutter Flame game component that Backgrounding¶: The game will be automatically paused when the app is sent to the background, and resumed when it comes back to the foreground. This behavior can be disabled by setting pauseWhenBackgrounded to false.", "completion": "class MyGame extends FlameGame {\n  MyGame() {\n    pauseWhenBackgrounded = false;\n  }\n}"}
{"prompt": "Show me how to implement Backgrounding¶: The game will be automatically paused when the app is sent to the background, and resumed when it comes back to the foreground. This behavior can be disabled by setting pauseWhenBackgrounded to false. using Flutter Flame", "completion": "class MyGame extends FlameGame {\n  MyGame() {\n    pauseWhenBackgrounded = false;\n  }\n}"}
{"prompt": "Write Flutter Flame code to Backgrounding¶: The game will be automatically paused when the app is sent to the background, and resumed when it comes back to the foreground. This behavior can be disabled by setting pauseWhenBackgrounded to false.", "completion": "class MyGame extends FlameGame {\n  MyGame() {\n    pauseWhenBackgrounded = false;\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that HasPerformanceTracker mixin¶: To get the update and render times, just add the HasPerformanceTracker mixin to the game class.", "completion": "class MyGame extends FlameGame with HasPerformanceTracker {\n  // access `updateTime` and `renderTime` getters.\n}"}
{"prompt": "Show me how to implement HasPerformanceTracker mixin¶: To get the update and render times, just add the HasPerformanceTracker mixin to the game class. using Flutter Flame", "completion": "class MyGame extends FlameGame with HasPerformanceTracker {\n  // access `updateTime` and `renderTime` getters.\n}"}
{"prompt": "Write Flutter Flame code to HasPerformanceTracker mixin¶: To get the update and render times, just add the HasPerformanceTracker mixin to the game class.", "completion": "class MyGame extends FlameGame with HasPerformanceTracker {\n  // access `updateTime` and `renderTime` getters.\n}"}
{"prompt": "Create a Flutter Flame game component that Mouse cursor¶: To already initialize the GameWidget with a custom cursor, the mouseCursor property can be used", "completion": "GameWidget(\n  game: MouseCursorGame(),\n  mouseCursor: SystemMouseCursors.move,\n);"}
{"prompt": "Show me how to implement Mouse cursor¶: To already initialize the GameWidget with a custom cursor, the mouseCursor property can be used using Flutter Flame", "completion": "GameWidget(\n  game: MouseCursorGame(),\n  mouseCursor: SystemMouseCursors.move,\n);"}
{"prompt": "Write Flutter Flame code to Mouse cursor¶: To already initialize the GameWidget with a custom cursor, the mouseCursor property can be used", "completion": "GameWidget(\n  game: MouseCursorGame(),\n  mouseCursor: SystemMouseCursors.move,\n);"}
{"prompt": "Create a Flutter Flame game component that Example¶: The position where the event occurred relative to the GameWidget position and size, same as localPosition in Flutter’s native events.", "completion": "class MyGame extends FlameGame with TapDetector {\n  // Other methods omitted\n\n  @override\n  bool onTapDown(TapDownInfo info) {\n    print(\"Player tap down on ${info.eventPosition.widget}\");\n    return true;\n  }\n\n  @override\n  bool onTapUp(TapUpInfo info) {\n    print(\"Player tap up on ${info.eventPosition.widget}\");\n    return true;\n  }\n}"}
{"prompt": "Show me how to implement Example¶: The position where the event occurred relative to the GameWidget position and size, same as localPosition in Flutter’s native events. using Flutter Flame", "completion": "class MyGame extends FlameGame with TapDetector {\n  // Other methods omitted\n\n  @override\n  bool onTapDown(TapDownInfo info) {\n    print(\"Player tap down on ${info.eventPosition.widget}\");\n    return true;\n  }\n\n  @override\n  bool onTapUp(TapUpInfo info) {\n    print(\"Player tap up on ${info.eventPosition.widget}\");\n    return true;\n  }\n}"}
{"prompt": "Write Flutter Flame code to Example¶: The position where the event occurred relative to the GameWidget position and size, same as localPosition in Flutter’s native events.", "completion": "class MyGame extends FlameGame with TapDetector {\n  // Other methods omitted\n\n  @override\n  bool onTapDown(TapDownInfo info) {\n    print(\"Player tap down on ${info.eventPosition.widget}\");\n    return true;\n  }\n\n  @override\n  bool onTapUp(TapUpInfo info) {\n    print(\"Player tap up on ${info.eventPosition.widget}\");\n    return true;\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that KlondikeGame¶: So, create a new file called klondike_game.dart inside the lib/ folder, and declare the KlondikeGame class inside:", "completion": "import 'package:flame/game.dart';\nimport 'package:flame/flame.dart';\n\nclass KlondikeGame extends FlameGame {\n  @override\n  Future<void> onLoad() async {\n    await Flame.images.load('klondike-sprites.png');\n  }\n}"}
{"prompt": "Show me how to implement KlondikeGame¶: So, create a new file called klondike_game.dart inside the lib/ folder, and declare the KlondikeGame class inside: using Flutter Flame", "completion": "import 'package:flame/game.dart';\nimport 'package:flame/flame.dart';\n\nclass KlondikeGame extends FlameGame {\n  @override\n  Future<void> onLoad() async {\n    await Flame.images.load('klondike-sprites.png');\n  }\n}"}
{"prompt": "Write Flutter Flame code to KlondikeGame¶: So, create a new file called klondike_game.dart inside the lib/ folder, and declare the KlondikeGame class inside:", "completion": "import 'package:flame/game.dart';\nimport 'package:flame/flame.dart';\n\nclass KlondikeGame extends FlameGame {\n  @override\n  Future<void> onLoad() async {\n    await Flame.images.load('klondike-sprites.png');\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that KlondikeGame¶: Also note that I am awaiting the image to finish loading before initializing anything else in the game. This is for convenience: it means that by the time all other components are initialized, they can assume the sprite sheet is already loaded. We can even add a helper function to extract a sprite from the common sprite sheet:", "completion": "Sprite klondikeSprite(double x, double y, double width, double height) {\n  return Sprite(\n    Flame.images.fromCache('klondike-sprites.png'),\n    srcPosition: Vector2(x, y),\n    srcSize: Vector2(width, height),\n  );\n}"}
{"prompt": "Show me how to implement KlondikeGame¶: Also note that I am awaiting the image to finish loading before initializing anything else in the game. This is for convenience: it means that by the time all other components are initialized, they can assume the sprite sheet is already loaded. We can even add a helper function to extract a sprite from the common sprite sheet: using Flutter Flame", "completion": "Sprite klondikeSprite(double x, double y, double width, double height) {\n  return Sprite(\n    Flame.images.fromCache('klondike-sprites.png'),\n    srcPosition: Vector2(x, y),\n    srcSize: Vector2(width, height),\n  );\n}"}
{"prompt": "Write Flutter Flame code to KlondikeGame¶: Also note that I am awaiting the image to finish loading before initializing anything else in the game. This is for convenience: it means that by the time all other components are initialized, they can assume the sprite sheet is already loaded. We can even add a helper function to extract a sprite from the common sprite sheet:", "completion": "Sprite klondikeSprite(double x, double y, double width, double height) {\n  return Sprite(\n    Flame.images.fromCache('klondike-sprites.png'),\n    srcPosition: Vector2(x, y),\n    srcSize: Vector2(width, height),\n  );\n}"}
{"prompt": "Create a Flutter Flame game component that KlondikeGame¶: Let’s incorporate this class into the project so that it isn’t orphaned. Open the main.dart find the line which says final game = FlameGame(); and replace the FlameGame with KlondikeGame. You will need to import the class too. After all is done, the file should look like this:", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/widgets.dart';\nimport 'klondike_game.dart';\n\nvoid main() {\n  final game = KlondikeGame();\n  runApp(GameWidget(game: game));\n}"}
{"prompt": "Show me how to implement KlondikeGame¶: Let’s incorporate this class into the project so that it isn’t orphaned. Open the main.dart find the line which says final game = FlameGame(); and replace the FlameGame with KlondikeGame. You will need to import the class too. After all is done, the file should look like this: using Flutter Flame", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/widgets.dart';\nimport 'klondike_game.dart';\n\nvoid main() {\n  final game = KlondikeGame();\n  runApp(GameWidget(game: game));\n}"}
{"prompt": "Write Flutter Flame code to KlondikeGame¶: Let’s incorporate this class into the project so that it isn’t orphaned. Open the main.dart find the line which says final game = FlameGame(); and replace the FlameGame with KlondikeGame. You will need to import the class too. After all is done, the file should look like this:", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/widgets.dart';\nimport 'klondike_game.dart';\n\nvoid main() {\n  final game = KlondikeGame();\n  runApp(GameWidget(game: game));\n}"}
{"prompt": "Create a Flutter Flame game component that Other classes¶: For now, let’s create the container classes, as shown on the sketch. These are: Stock, Waste, Pile and Foundation. Inside the lib/ folder create a sub-directory components, and then the file lib/components/stock.dart. In that file write", "completion": "import 'package:flame/components.dart';\n\nclass Stock extends PositionComponent {\n  @override\n  bool get debugMode => true;\n}"}
{"prompt": "Show me how to implement Other classes¶: For now, let’s create the container classes, as shown on the sketch. These are: Stock, Waste, Pile and Foundation. Inside the lib/ folder create a sub-directory components, and then the file lib/components/stock.dart. In that file write using Flutter Flame", "completion": "import 'package:flame/components.dart';\n\nclass Stock extends PositionComponent {\n  @override\n  bool get debugMode => true;\n}"}
{"prompt": "Write Flutter Flame code to Other classes¶: For now, let’s create the container classes, as shown on the sketch. These are: Stock, Waste, Pile and Foundation. Inside the lib/ folder create a sub-directory components, and then the file lib/components/stock.dart. In that file write", "completion": "import 'package:flame/components.dart';\n\nclass Stock extends PositionComponent {\n  @override\n  bool get debugMode => true;\n}"}
{"prompt": "Create a Flutter Flame game component that Game structure¶: Thus, the overall structure of the component tree will look approximately like this:", "completion": "KlondikeGame\n ├─ World\n │   ├─ Stock\n │   ├─ Waste\n │   ├─ Foundation (×4)\n │   └─ Pile (×7)\n └─ CameraComponent"}
{"prompt": "Show me how to implement Game structure¶: Thus, the overall structure of the component tree will look approximately like this: using Flutter Flame", "completion": "KlondikeGame\n ├─ World\n │   ├─ Stock\n │   ├─ Waste\n │   ├─ Foundation (×4)\n │   └─ Pile (×7)\n └─ CameraComponent"}
{"prompt": "Write Flutter Flame code to Game structure¶: Thus, the overall structure of the component tree will look approximately like this:", "completion": "KlondikeGame\n ├─ World\n │   ├─ Stock\n │   ├─ Waste\n │   ├─ Foundation (×4)\n │   └─ Pile (×7)\n └─ CameraComponent"}
{"prompt": "Create a Flutter Flame game component that Game structure¶: First, we declare several global constants which describe the dimensions of a card and the distance between cards. We declare them as constants because we are not planning to change these values during the game:", "completion": "static const double cardWidth = 1000.0;\n  static const double cardHeight = 1400.0;\n  static const double cardGap = 175.0;\n  static const double cardRadius = 100.0;\n  static final Vector2 cardSize = Vector2(cardWidth, cardHeight);"}
{"prompt": "Show me how to implement Game structure¶: First, we declare several global constants which describe the dimensions of a card and the distance between cards. We declare them as constants because we are not planning to change these values during the game: using Flutter Flame", "completion": "static const double cardWidth = 1000.0;\n  static const double cardHeight = 1400.0;\n  static const double cardGap = 175.0;\n  static const double cardRadius = 100.0;\n  static final Vector2 cardSize = Vector2(cardWidth, cardHeight);"}
{"prompt": "Write Flutter Flame code to Game structure¶: First, we declare several global constants which describe the dimensions of a card and the distance between cards. We declare them as constants because we are not planning to change these values during the game:", "completion": "static const double cardWidth = 1000.0;\n  static const double cardHeight = 1400.0;\n  static const double cardGap = 175.0;\n  static const double cardRadius = 100.0;\n  static final Vector2 cardSize = Vector2(cardWidth, cardHeight);"}
{"prompt": "Create a Flutter Flame game component that Game structure¶: Next, we will create a Stock component, the Waste, four Foundations and seven Piles, setting their sizes and positions in the world. The positions are calculated using simple arithmetics. This should all happen inside the onLoad method, after loading the sprite sheet:", "completion": "final stock = Stock()\n      ..size = cardSize\n      ..position = Vector2(cardGap, cardGap);\n    final waste = Waste()\n      ..size = cardSize\n      ..position = Vector2(cardWidth + 2 * cardGap, cardGap);\n    final foundations = List.generate(\n,\n      (i) => Foundation()\n        ..size = cardSize\n        ..position =\n            Vector2((i + 3) * (cardWidth + cardGap) + cardGap, cardGap),\n    );\n    final piles = List.generate(\n,\n      (i) => Pile()\n        ..size = cardSize\n        ..position = Vector2(\n          cardGap + i * (cardWidth + cardGap),\n          cardHeight + 2 * cardGap,\n        ),\n    );"}
{"prompt": "Show me how to implement Game structure¶: Next, we will create a Stock component, the Waste, four Foundations and seven Piles, setting their sizes and positions in the world. The positions are calculated using simple arithmetics. This should all happen inside the onLoad method, after loading the sprite sheet: using Flutter Flame", "completion": "final stock = Stock()\n      ..size = cardSize\n      ..position = Vector2(cardGap, cardGap);\n    final waste = Waste()\n      ..size = cardSize\n      ..position = Vector2(cardWidth + 2 * cardGap, cardGap);\n    final foundations = List.generate(\n,\n      (i) => Foundation()\n        ..size = cardSize\n        ..position =\n            Vector2((i + 3) * (cardWidth + cardGap) + cardGap, cardGap),\n    );\n    final piles = List.generate(\n,\n      (i) => Pile()\n        ..size = cardSize\n        ..position = Vector2(\n          cardGap + i * (cardWidth + cardGap),\n          cardHeight + 2 * cardGap,\n        ),\n    );"}
{"prompt": "Write Flutter Flame code to Game structure¶: Next, we will create a Stock component, the Waste, four Foundations and seven Piles, setting their sizes and positions in the world. The positions are calculated using simple arithmetics. This should all happen inside the onLoad method, after loading the sprite sheet:", "completion": "final stock = Stock()\n      ..size = cardSize\n      ..position = Vector2(cardGap, cardGap);\n    final waste = Waste()\n      ..size = cardSize\n      ..position = Vector2(cardWidth + 2 * cardGap, cardGap);\n    final foundations = List.generate(\n,\n      (i) => Foundation()\n        ..size = cardSize\n        ..position =\n            Vector2((i + 3) * (cardWidth + cardGap) + cardGap, cardGap),\n    );\n    final piles = List.generate(\n,\n      (i) => Pile()\n        ..size = cardSize\n        ..position = Vector2(\n          cardGap + i * (cardWidth + cardGap),\n          cardHeight + 2 * cardGap,\n        ),\n    );"}
{"prompt": "Create a Flutter Flame game component that Game structure¶: The reason for such choice for the viewfinder’s position and anchor is because of how we want it to respond if the game size becomes too wide or too tall: in case of too wide we want it to be centered on the screen, but if the screen is too tall, we want the content to be aligned at the top.", "completion": "camera.viewfinder.visibleGameSize =\n           Vector2(cardWidth * 7 + cardGap * 8, 4 * cardHeight + 3 * cardGap);\n    camera.viewfinder.position = Vector2(cardWidth * 3.5 + cardGap * 4, 0);\n    camera.viewfinder.anchor = Anchor.topCenter;"}
{"prompt": "Show me how to implement Game structure¶: The reason for such choice for the viewfinder’s position and anchor is because of how we want it to respond if the game size becomes too wide or too tall: in case of too wide we want it to be centered on the screen, but if the screen is too tall, we want the content to be aligned at the top. using Flutter Flame", "completion": "camera.viewfinder.visibleGameSize =\n           Vector2(cardWidth * 7 + cardGap * 8, 4 * cardHeight + 3 * cardGap);\n    camera.viewfinder.position = Vector2(cardWidth * 3.5 + cardGap * 4, 0);\n    camera.viewfinder.anchor = Anchor.topCenter;"}
{"prompt": "Write Flutter Flame code to Game structure¶: The reason for such choice for the viewfinder’s position and anchor is because of how we want it to respond if the game size becomes too wide or too tall: in case of too wide we want it to be centered on the screen, but if the screen is too tall, we want the content to be aligned at the top.", "completion": "camera.viewfinder.visibleGameSize =\n           Vector2(cardWidth * 7 + cardGap * 8, 4 * cardHeight + 3 * cardGap);\n    camera.viewfinder.position = Vector2(cardWidth * 3.5 + cardGap * 4, 0);\n    camera.viewfinder.anchor = Anchor.topCenter;"}
{"prompt": "Create a Flutter Flame game component that Game structure¶: If you run the game now, you should see the placeholders for where the various components will be. If you are running the game in the browser, try resizing the window and see how the game responds to this.", "completion": "import 'package:flame/components.dart';\n\nclass Foundation extends PositionComponent {\n@override\nbool get debugMode => true;\n}"}
{"prompt": "Show me how to implement Game structure¶: If you run the game now, you should see the placeholders for where the various components will be. If you are running the game in the browser, try resizing the window and see how the game responds to this. using Flutter Flame", "completion": "import 'package:flame/components.dart';\n\nclass Foundation extends PositionComponent {\n@override\nbool get debugMode => true;\n}"}
{"prompt": "Write Flutter Flame code to Game structure¶: If you run the game now, you should see the placeholders for where the various components will be. If you are running the game in the browser, try resizing the window and see how the game responds to this.", "completion": "import 'package:flame/components.dart';\n\nclass Foundation extends PositionComponent {\n@override\nbool get debugMode => true;\n}"}
{"prompt": "Create a Flutter Flame game component that Game structure¶: If you run the game now, you should see the placeholders for where the various components will be. If you are running the game in the browser, try resizing the window and see how the game responds to this.", "completion": "import 'package:flame/components.dart';\n\nclass Pile extends PositionComponent {\n@override\nbool get debugMode => true;\n}"}
{"prompt": "Show me how to implement Game structure¶: If you run the game now, you should see the placeholders for where the various components will be. If you are running the game in the browser, try resizing the window and see how the game responds to this. using Flutter Flame", "completion": "import 'package:flame/components.dart';\n\nclass Pile extends PositionComponent {\n@override\nbool get debugMode => true;\n}"}
{"prompt": "Write Flutter Flame code to Game structure¶: If you run the game now, you should see the placeholders for where the various components will be. If you are running the game in the browser, try resizing the window and see how the game responds to this.", "completion": "import 'package:flame/components.dart';\n\nclass Pile extends PositionComponent {\n@override\nbool get debugMode => true;\n}"}
{"prompt": "Create a Flutter Flame game component that Game structure¶: If you run the game now, you should see the placeholders for where the various components will be. If you are running the game in the browser, try resizing the window and see how the game responds to this.", "completion": "import 'package:flame/components.dart';\n\nclass Stock extends PositionComponent {\n@override\nbool get debugMode => true;\n}"}
{"prompt": "Show me how to implement Game structure¶: If you run the game now, you should see the placeholders for where the various components will be. If you are running the game in the browser, try resizing the window and see how the game responds to this. using Flutter Flame", "completion": "import 'package:flame/components.dart';\n\nclass Stock extends PositionComponent {\n@override\nbool get debugMode => true;\n}"}
{"prompt": "Write Flutter Flame code to Game structure¶: If you run the game now, you should see the placeholders for where the various components will be. If you are running the game in the browser, try resizing the window and see how the game responds to this.", "completion": "import 'package:flame/components.dart';\n\nclass Stock extends PositionComponent {\n@override\nbool get debugMode => true;\n}"}
{"prompt": "Create a Flutter Flame game component that Game structure¶: If you run the game now, you should see the placeholders for where the various components will be. If you are running the game in the browser, try resizing the window and see how the game responds to this.", "completion": "import 'package:flame/components.dart';\n\nclass Waste extends PositionComponent {\n@override\nbool get debugMode => true;\n}"}
{"prompt": "Show me how to implement Game structure¶: If you run the game now, you should see the placeholders for where the various components will be. If you are running the game in the browser, try resizing the window and see how the game responds to this. using Flutter Flame", "completion": "import 'package:flame/components.dart';\n\nclass Waste extends PositionComponent {\n@override\nbool get debugMode => true;\n}"}
{"prompt": "Write Flutter Flame code to Game structure¶: If you run the game now, you should see the placeholders for where the various components will be. If you are running the game in the browser, try resizing the window and see how the game responds to this.", "completion": "import 'package:flame/components.dart';\n\nclass Waste extends PositionComponent {\n@override\nbool get debugMode => true;\n}"}
{"prompt": "Create a Flutter Flame game component that Game structure¶: If you run the game now, you should see the placeholders for where the various components will be. If you are running the game in the browser, try resizing the window and see how the game responds to this.", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/flame.dart';\nimport 'package:flame/game.dart';\n\nimport 'components/foundation.dart';\nimport 'components/pile.dart';\nimport 'components/stock.dart';\nimport 'components/waste.dart';\n\nclass KlondikeGame extends FlameGame {\nstatic const double cardGap = 175.0;\nstatic const double cardWidth = 1000.0;\nstatic const double cardHeight = 1400.0;\nstatic const double cardRadius = 100.0;\nstatic final Vector2 cardSize = Vector2(cardWidth, cardHeight);\n\n@override\nFuture<void> onLoad() async {\nawait Flame.images.load('klondike-sprites.png');\n\nfinal stock = Stock()\n..size = cardSize\n..position = Vector2(cardGap, cardGap);\nfinal waste = Waste()\n..size = cardSize\n..position = Vector2(cardWidth + 2 * cardGap, cardGap);\nfinal foundations = List.generate(\n4,\n(i) => Foundation()\n..size = cardSize\n..position =\nVector2((i + 3) * (cardWidth + cardGap) + cardGap, cardGap),\n);\nfinal piles = List.generate(\n7,\n(i) => Pile()\n..size = cardSize\n..position = Vector2(\ncardGap + i * (cardWidth + cardGap),\ncardHeight + 2 * cardGap,\n),\n);\n\nworld.add(stock);\nworld.add(waste);\nworld.addAll(foundations);\nworld.addAll(piles);\n\ncamera.viewfinder.visibleGameSize =\nVector2(cardWidth * 7 + cardGap * 8, 4 * cardHeight + 3 * cardGap);\ncamera.viewfinder.position = Vector2(cardWidth * 3.5 + cardGap * 4, 0);\ncamera.viewfinder.anchor = Anchor.topCenter;\n}\n}\n\nSprite klondikeSprite(double x, double y, double width, double height) {\nreturn Sprite(\nFlame.images.fromCache('klondike-sprites.png'),\nsrcPosition: Vector2(x, y),\nsrcSize: Vector2(width, height),\n);\n}"}
{"prompt": "Show me how to implement Game structure¶: If you run the game now, you should see the placeholders for where the various components will be. If you are running the game in the browser, try resizing the window and see how the game responds to this. using Flutter Flame", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/flame.dart';\nimport 'package:flame/game.dart';\n\nimport 'components/foundation.dart';\nimport 'components/pile.dart';\nimport 'components/stock.dart';\nimport 'components/waste.dart';\n\nclass KlondikeGame extends FlameGame {\nstatic const double cardGap = 175.0;\nstatic const double cardWidth = 1000.0;\nstatic const double cardHeight = 1400.0;\nstatic const double cardRadius = 100.0;\nstatic final Vector2 cardSize = Vector2(cardWidth, cardHeight);\n\n@override\nFuture<void> onLoad() async {\nawait Flame.images.load('klondike-sprites.png');\n\nfinal stock = Stock()\n..size = cardSize\n..position = Vector2(cardGap, cardGap);\nfinal waste = Waste()\n..size = cardSize\n..position = Vector2(cardWidth + 2 * cardGap, cardGap);\nfinal foundations = List.generate(\n4,\n(i) => Foundation()\n..size = cardSize\n..position =\nVector2((i + 3) * (cardWidth + cardGap) + cardGap, cardGap),\n);\nfinal piles = List.generate(\n7,\n(i) => Pile()\n..size = cardSize\n..position = Vector2(\ncardGap + i * (cardWidth + cardGap),\ncardHeight + 2 * cardGap,\n),\n);\n\nworld.add(stock);\nworld.add(waste);\nworld.addAll(foundations);\nworld.addAll(piles);\n\ncamera.viewfinder.visibleGameSize =\nVector2(cardWidth * 7 + cardGap * 8, 4 * cardHeight + 3 * cardGap);\ncamera.viewfinder.position = Vector2(cardWidth * 3.5 + cardGap * 4, 0);\ncamera.viewfinder.anchor = Anchor.topCenter;\n}\n}\n\nSprite klondikeSprite(double x, double y, double width, double height) {\nreturn Sprite(\nFlame.images.fromCache('klondike-sprites.png'),\nsrcPosition: Vector2(x, y),\nsrcSize: Vector2(width, height),\n);\n}"}
{"prompt": "Write Flutter Flame code to Game structure¶: If you run the game now, you should see the placeholders for where the various components will be. If you are running the game in the browser, try resizing the window and see how the game responds to this.", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/flame.dart';\nimport 'package:flame/game.dart';\n\nimport 'components/foundation.dart';\nimport 'components/pile.dart';\nimport 'components/stock.dart';\nimport 'components/waste.dart';\n\nclass KlondikeGame extends FlameGame {\nstatic const double cardGap = 175.0;\nstatic const double cardWidth = 1000.0;\nstatic const double cardHeight = 1400.0;\nstatic const double cardRadius = 100.0;\nstatic final Vector2 cardSize = Vector2(cardWidth, cardHeight);\n\n@override\nFuture<void> onLoad() async {\nawait Flame.images.load('klondike-sprites.png');\n\nfinal stock = Stock()\n..size = cardSize\n..position = Vector2(cardGap, cardGap);\nfinal waste = Waste()\n..size = cardSize\n..position = Vector2(cardWidth + 2 * cardGap, cardGap);\nfinal foundations = List.generate(\n4,\n(i) => Foundation()\n..size = cardSize\n..position =\nVector2((i + 3) * (cardWidth + cardGap) + cardGap, cardGap),\n);\nfinal piles = List.generate(\n7,\n(i) => Pile()\n..size = cardSize\n..position = Vector2(\ncardGap + i * (cardWidth + cardGap),\ncardHeight + 2 * cardGap,\n),\n);\n\nworld.add(stock);\nworld.add(waste);\nworld.addAll(foundations);\nworld.addAll(piles);\n\ncamera.viewfinder.visibleGameSize =\nVector2(cardWidth * 7 + cardGap * 8, 4 * cardHeight + 3 * cardGap);\ncamera.viewfinder.position = Vector2(cardWidth * 3.5 + cardGap * 4, 0);\ncamera.viewfinder.anchor = Anchor.topCenter;\n}\n}\n\nSprite klondikeSprite(double x, double y, double width, double height) {\nreturn Sprite(\nFlame.images.fromCache('klondike-sprites.png'),\nsrcPosition: Vector2(x, y),\nsrcSize: Vector2(width, height),\n);\n}"}
{"prompt": "Create a Flutter Flame game component that Game structure¶: If you run the game now, you should see the placeholders for where the various components will be. If you are running the game in the browser, try resizing the window and see how the game responds to this.", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'klondike_game.dart';\n\nvoid main() {\nfinal game = KlondikeGame();\nrunApp(GameWidget(game: game));\n}"}
{"prompt": "Show me how to implement Game structure¶: If you run the game now, you should see the placeholders for where the various components will be. If you are running the game in the browser, try resizing the window and see how the game responds to this. using Flutter Flame", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'klondike_game.dart';\n\nvoid main() {\nfinal game = KlondikeGame();\nrunApp(GameWidget(game: game));\n}"}
{"prompt": "Write Flutter Flame code to Game structure¶: If you run the game now, you should see the placeholders for where the various components will be. If you are running the game in the browser, try resizing the window and see how the game responds to this.", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'klondike_game.dart';\n\nvoid main() {\nfinal game = KlondikeGame();\nrunApp(GameWidget(game: game));\n}"}
{"prompt": "Create a Flutter Flame game component that Usage¶: By default, the RiverpodAwareGameWidget is rebuilt when Riverpod-aware (i.e. using the RiverpodComponentMixin) components are mounted and when they are removed.", "completion": "/// An excerpt from the Example. Check it out!\nclass RefExampleGame extends FlameGame with RiverpodGameMixin {\n  @override\n  Future<void> onLoad() async {\n    await super.onLoad();\n    add(TextComponent(text: 'Flame'));\n    add(RiverpodAwareTextComponent());\n  }\n}\n\nclass RiverpodAwareTextComponent extends PositionComponent\n    with RiverpodComponentMixin {\n  late TextComponent textComponent;\n  int currentValue = 0;\n\n  @override\n  void onMount() {\n    addToGameWidgetBuild(() {\n      ref.listen(countingStreamProvider, (p0, p1) {\n        if (p1.hasValue) {\n          currentValue = p1.value!;\n          textComponent.text = '$currentValue';\n        }\n      });\n    });\n    super.onMount();\n    add(textComponent = TextComponent(position: position + Vector2(0, 27)));\n  }\n}"}
{"prompt": "Show me how to implement Usage¶: By default, the RiverpodAwareGameWidget is rebuilt when Riverpod-aware (i.e. using the RiverpodComponentMixin) components are mounted and when they are removed. using Flutter Flame", "completion": "/// An excerpt from the Example. Check it out!\nclass RefExampleGame extends FlameGame with RiverpodGameMixin {\n  @override\n  Future<void> onLoad() async {\n    await super.onLoad();\n    add(TextComponent(text: 'Flame'));\n    add(RiverpodAwareTextComponent());\n  }\n}\n\nclass RiverpodAwareTextComponent extends PositionComponent\n    with RiverpodComponentMixin {\n  late TextComponent textComponent;\n  int currentValue = 0;\n\n  @override\n  void onMount() {\n    addToGameWidgetBuild(() {\n      ref.listen(countingStreamProvider, (p0, p1) {\n        if (p1.hasValue) {\n          currentValue = p1.value!;\n          textComponent.text = '$currentValue';\n        }\n      });\n    });\n    super.onMount();\n    add(textComponent = TextComponent(position: position + Vector2(0, 27)));\n  }\n}"}
{"prompt": "Write Flutter Flame code to Usage¶: By default, the RiverpodAwareGameWidget is rebuilt when Riverpod-aware (i.e. using the RiverpodComponentMixin) components are mounted and when they are removed.", "completion": "/// An excerpt from the Example. Check it out!\nclass RefExampleGame extends FlameGame with RiverpodGameMixin {\n  @override\n  Future<void> onLoad() async {\n    await super.onLoad();\n    add(TextComponent(text: 'Flame'));\n    add(RiverpodAwareTextComponent());\n  }\n}\n\nclass RiverpodAwareTextComponent extends PositionComponent\n    with RiverpodComponentMixin {\n  late TextComponent textComponent;\n  int currentValue = 0;\n\n  @override\n  void onMount() {\n    addToGameWidgetBuild(() {\n      ref.listen(countingStreamProvider, (p0, p1) {\n        if (p1.hasValue) {\n          currentValue = p1.value!;\n          textComponent.text = '$currentValue';\n        }\n      });\n    });\n    super.onMount();\n    add(textComponent = TextComponent(position: position + Vector2(0, 27)));\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that MoveByEffect¶: This effect applies to a PositionComponent and shifts it by a prescribed offset amount. This offset is relative to the current position of the target:", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass MoveByEffectGame extends FlameGame {\nbool reset = false;\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nsize: 60,\nposition: canvasSize / 2,\nonTap: (flower) {\nif (reset = !reset) {\nflower.add(\nMoveEffect.by(\nVector2(30, 30),\nEffectController(duration: 1.0),\n),\n);\n} else {\nflower.add(\nMoveEffect.by(\nVector2(-30, -30),\nEffectController(duration: 1.0),\n),\n);\n}\n},\n);\nadd(flower);\n}\n}"}
{"prompt": "Show me how to implement MoveByEffect¶: This effect applies to a PositionComponent and shifts it by a prescribed offset amount. This offset is relative to the current position of the target: using Flutter Flame", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass MoveByEffectGame extends FlameGame {\nbool reset = false;\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nsize: 60,\nposition: canvasSize / 2,\nonTap: (flower) {\nif (reset = !reset) {\nflower.add(\nMoveEffect.by(\nVector2(30, 30),\nEffectController(duration: 1.0),\n),\n);\n} else {\nflower.add(\nMoveEffect.by(\nVector2(-30, -30),\nEffectController(duration: 1.0),\n),\n);\n}\n},\n);\nadd(flower);\n}\n}"}
{"prompt": "Write Flutter Flame code to MoveByEffect¶: This effect applies to a PositionComponent and shifts it by a prescribed offset amount. This offset is relative to the current position of the target:", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass MoveByEffectGame extends FlameGame {\nbool reset = false;\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nsize: 60,\nposition: canvasSize / 2,\nonTap: (flower) {\nif (reset = !reset) {\nflower.add(\nMoveEffect.by(\nVector2(30, 30),\nEffectController(duration: 1.0),\n),\n);\n} else {\nflower.add(\nMoveEffect.by(\nVector2(-30, -30),\nEffectController(duration: 1.0),\n),\n);\n}\n},\n);\nadd(flower);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that MoveByEffect¶: This effect applies to a PositionComponent and shifts it by a prescribed offset amount. This offset is relative to the current position of the target:", "completion": "final effect = MoveByEffect(\n  Vector2(0, -10),\n  EffectController(duration: 0.5),\n);"}
{"prompt": "Show me how to implement MoveByEffect¶: This effect applies to a PositionComponent and shifts it by a prescribed offset amount. This offset is relative to the current position of the target: using Flutter Flame", "completion": "final effect = MoveByEffect(\n  Vector2(0, -10),\n  EffectController(duration: 0.5),\n);"}
{"prompt": "Write Flutter Flame code to MoveByEffect¶: This effect applies to a PositionComponent and shifts it by a prescribed offset amount. This offset is relative to the current position of the target:", "completion": "final effect = MoveByEffect(\n  Vector2(0, -10),\n  EffectController(duration: 0.5),\n);"}
{"prompt": "Create a Flutter Flame game component that MoveToEffect¶: This effect moves a PositionComponent from its current position to the specified destination point in a straight line.", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass MoveToEffectGame extends FlameGame {\nbool reset = false;\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nsize: 60,\nposition: canvasSize / 2,\nonTap: (flower) {\nif (reset = !reset) {\nflower.add(\nMoveEffect.to(\nVector2(30, 30),\nEffectController(duration: 1.0),\n),\n);\n} else {\nflower.add(\nMoveEffect.to(\nsize / 2,\nEffectController(duration: 1.0),\n),\n);\n}\n},\n);\nadd(flower);\n}\n}"}
{"prompt": "Show me how to implement MoveToEffect¶: This effect moves a PositionComponent from its current position to the specified destination point in a straight line. using Flutter Flame", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass MoveToEffectGame extends FlameGame {\nbool reset = false;\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nsize: 60,\nposition: canvasSize / 2,\nonTap: (flower) {\nif (reset = !reset) {\nflower.add(\nMoveEffect.to(\nVector2(30, 30),\nEffectController(duration: 1.0),\n),\n);\n} else {\nflower.add(\nMoveEffect.to(\nsize / 2,\nEffectController(duration: 1.0),\n),\n);\n}\n},\n);\nadd(flower);\n}\n}"}
{"prompt": "Write Flutter Flame code to MoveToEffect¶: This effect moves a PositionComponent from its current position to the specified destination point in a straight line.", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass MoveToEffectGame extends FlameGame {\nbool reset = false;\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nsize: 60,\nposition: canvasSize / 2,\nonTap: (flower) {\nif (reset = !reset) {\nflower.add(\nMoveEffect.to(\nVector2(30, 30),\nEffectController(duration: 1.0),\n),\n);\n} else {\nflower.add(\nMoveEffect.to(\nsize / 2,\nEffectController(duration: 1.0),\n),\n);\n}\n},\n);\nadd(flower);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that MoveToEffect¶: This effect moves a PositionComponent from its current position to the specified destination point in a straight line.", "completion": "final effect = MoveToEffect(\n  Vector2(100, 500),\n  EffectController(duration: 3),\n);"}
{"prompt": "Show me how to implement MoveToEffect¶: This effect moves a PositionComponent from its current position to the specified destination point in a straight line. using Flutter Flame", "completion": "final effect = MoveToEffect(\n  Vector2(100, 500),\n  EffectController(duration: 3),\n);"}
{"prompt": "Write Flutter Flame code to MoveToEffect¶: This effect moves a PositionComponent from its current position to the specified destination point in a straight line.", "completion": "final effect = MoveToEffect(\n  Vector2(100, 500),\n  EffectController(duration: 3),\n);"}
{"prompt": "Create a Flutter Flame game component that MoveAlongPathEffect¶: This effect moves a PositionComponent along the specified path relative to the component’s current position. The path can have non-linear segments, but must be singly connected. It is recommended to start a path at Vector2.zero() in order to avoid sudden jumps in the component’s position.", "completion": "import 'dart:ui';\n\nimport 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass MoveAlongPathEffectGame extends FlameGame {\nbool reset = false;\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nsize: 60,\nposition: canvasSize / 2,\nonTap: (flower) {\nif (reset = !reset) {\nflower.add(\nMoveAlongPathEffect(\nPath()..quadraticBezierTo(100, 0, 50, -50),\nEffectController(duration: 1.5),\n),\n);\n} else {\nflower.add(\nMoveAlongPathEffect(\nPath()..quadraticBezierTo(-100, 0, -50, 50),\nEffectController(duration: 1.5),\n),\n);\n}\n},\n);\nadd(flower);\n}\n}"}
{"prompt": "Show me how to implement MoveAlongPathEffect¶: This effect moves a PositionComponent along the specified path relative to the component’s current position. The path can have non-linear segments, but must be singly connected. It is recommended to start a path at Vector2.zero() in order to avoid sudden jumps in the component’s position. using Flutter Flame", "completion": "import 'dart:ui';\n\nimport 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass MoveAlongPathEffectGame extends FlameGame {\nbool reset = false;\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nsize: 60,\nposition: canvasSize / 2,\nonTap: (flower) {\nif (reset = !reset) {\nflower.add(\nMoveAlongPathEffect(\nPath()..quadraticBezierTo(100, 0, 50, -50),\nEffectController(duration: 1.5),\n),\n);\n} else {\nflower.add(\nMoveAlongPathEffect(\nPath()..quadraticBezierTo(-100, 0, -50, 50),\nEffectController(duration: 1.5),\n),\n);\n}\n},\n);\nadd(flower);\n}\n}"}
{"prompt": "Write Flutter Flame code to MoveAlongPathEffect¶: This effect moves a PositionComponent along the specified path relative to the component’s current position. The path can have non-linear segments, but must be singly connected. It is recommended to start a path at Vector2.zero() in order to avoid sudden jumps in the component’s position.", "completion": "import 'dart:ui';\n\nimport 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass MoveAlongPathEffectGame extends FlameGame {\nbool reset = false;\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nsize: 60,\nposition: canvasSize / 2,\nonTap: (flower) {\nif (reset = !reset) {\nflower.add(\nMoveAlongPathEffect(\nPath()..quadraticBezierTo(100, 0, 50, -50),\nEffectController(duration: 1.5),\n),\n);\n} else {\nflower.add(\nMoveAlongPathEffect(\nPath()..quadraticBezierTo(-100, 0, -50, 50),\nEffectController(duration: 1.5),\n),\n);\n}\n},\n);\nadd(flower);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that RotateEffect.by¶: Rotates the target clockwise by the specified angle relative to its current orientation. The angle is in radians. For example, the following effect will rotate the target 90º (=tau/4 in radians) clockwise:", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/geometry.dart';\n\nclass RotateByEffectGame extends FlameGame {\nbool reset = false;\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nsize: 60,\nposition: canvasSize / 2,\nonTap: (flower) {\nif (reset = !reset) {\nflower.add(\nRotateEffect.by(\ntau / 4,\nEffectController(duration: 2),\n),\n);\n} else {\nflower.add(\nRotateEffect.by(\n-tau / 4,\nEffectController(duration: 2),\n),\n);\n}\n},\n);\nadd(flower);\n}\n}"}
{"prompt": "Show me how to implement RotateEffect.by¶: Rotates the target clockwise by the specified angle relative to its current orientation. The angle is in radians. For example, the following effect will rotate the target 90º (=tau/4 in radians) clockwise: using Flutter Flame", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/geometry.dart';\n\nclass RotateByEffectGame extends FlameGame {\nbool reset = false;\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nsize: 60,\nposition: canvasSize / 2,\nonTap: (flower) {\nif (reset = !reset) {\nflower.add(\nRotateEffect.by(\ntau / 4,\nEffectController(duration: 2),\n),\n);\n} else {\nflower.add(\nRotateEffect.by(\n-tau / 4,\nEffectController(duration: 2),\n),\n);\n}\n},\n);\nadd(flower);\n}\n}"}
{"prompt": "Write Flutter Flame code to RotateEffect.by¶: Rotates the target clockwise by the specified angle relative to its current orientation. The angle is in radians. For example, the following effect will rotate the target 90º (=tau/4 in radians) clockwise:", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/geometry.dart';\n\nclass RotateByEffectGame extends FlameGame {\nbool reset = false;\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nsize: 60,\nposition: canvasSize / 2,\nonTap: (flower) {\nif (reset = !reset) {\nflower.add(\nRotateEffect.by(\ntau / 4,\nEffectController(duration: 2),\n),\n);\n} else {\nflower.add(\nRotateEffect.by(\n-tau / 4,\nEffectController(duration: 2),\n),\n);\n}\n},\n);\nadd(flower);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that RotateEffect.to¶: Rotates the target clockwise to the specified angle. For example, the following will rotate the target to look east (0º is north, 90º=tau/4 east, 180º=tau/2 south, and 270º=tau*3/4 west):", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/geometry.dart';\n\nclass RotateToEffectGame extends FlameGame {\nbool reset = false;\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nsize: 60,\nposition: canvasSize / 2,\nonTap: (flower) {\nif (reset = !reset) {\nflower.add(\nRotateEffect.to(\ntau / 4,\nEffectController(duration: 2),\n),\n);\n} else {\nflower.add(\nRotateEffect.to(\n-tau / 4,\nEffectController(duration: 2),\n),\n);\n}\n},\n);\nadd(flower);\n}\n}"}
{"prompt": "Show me how to implement RotateEffect.to¶: Rotates the target clockwise to the specified angle. For example, the following will rotate the target to look east (0º is north, 90º=tau/4 east, 180º=tau/2 south, and 270º=tau*3/4 west): using Flutter Flame", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/geometry.dart';\n\nclass RotateToEffectGame extends FlameGame {\nbool reset = false;\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nsize: 60,\nposition: canvasSize / 2,\nonTap: (flower) {\nif (reset = !reset) {\nflower.add(\nRotateEffect.to(\ntau / 4,\nEffectController(duration: 2),\n),\n);\n} else {\nflower.add(\nRotateEffect.to(\n-tau / 4,\nEffectController(duration: 2),\n),\n);\n}\n},\n);\nadd(flower);\n}\n}"}
{"prompt": "Write Flutter Flame code to RotateEffect.to¶: Rotates the target clockwise to the specified angle. For example, the following will rotate the target to look east (0º is north, 90º=tau/4 east, 180º=tau/2 south, and 270º=tau*3/4 west):", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/geometry.dart';\n\nclass RotateToEffectGame extends FlameGame {\nbool reset = false;\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nsize: 60,\nposition: canvasSize / 2,\nonTap: (flower) {\nif (reset = !reset) {\nflower.add(\nRotateEffect.to(\ntau / 4,\nEffectController(duration: 2),\n),\n);\n} else {\nflower.add(\nRotateEffect.to(\n-tau / 4,\nEffectController(duration: 2),\n),\n);\n}\n},\n);\nadd(flower);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that ScaleEffect.by¶: This effect will change the target’s scale by the specified amount. For example, this will cause the component to grow 50% larger:", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass ScaleByEffectGame extends FlameGame {\nbool reverse = false;\nbool hold = false;\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nsize: 60,\nposition: canvasSize / 2,\nonTap: (flower) {\nif (hold) {\nreturn;\n}\nhold = true;\nif (reverse = !reverse) {\nflower.add(\nScaleEffect.by(\nVector2.all(1.5),\nEffectController(duration: 0.3),\nonComplete: () => hold = false,\n),\n);\n} else {\nflower.add(\nScaleEffect.by(\nVector2.all(1 / 1.5),\nEffectController(duration: 0.3),\nonComplete: () => hold = false,\n),\n);\n}\n},\n);\nadd(flower);\n}\n}"}
{"prompt": "Show me how to implement ScaleEffect.by¶: This effect will change the target’s scale by the specified amount. For example, this will cause the component to grow 50% larger: using Flutter Flame", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass ScaleByEffectGame extends FlameGame {\nbool reverse = false;\nbool hold = false;\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nsize: 60,\nposition: canvasSize / 2,\nonTap: (flower) {\nif (hold) {\nreturn;\n}\nhold = true;\nif (reverse = !reverse) {\nflower.add(\nScaleEffect.by(\nVector2.all(1.5),\nEffectController(duration: 0.3),\nonComplete: () => hold = false,\n),\n);\n} else {\nflower.add(\nScaleEffect.by(\nVector2.all(1 / 1.5),\nEffectController(duration: 0.3),\nonComplete: () => hold = false,\n),\n);\n}\n},\n);\nadd(flower);\n}\n}"}
{"prompt": "Write Flutter Flame code to ScaleEffect.by¶: This effect will change the target’s scale by the specified amount. For example, this will cause the component to grow 50% larger:", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass ScaleByEffectGame extends FlameGame {\nbool reverse = false;\nbool hold = false;\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nsize: 60,\nposition: canvasSize / 2,\nonTap: (flower) {\nif (hold) {\nreturn;\n}\nhold = true;\nif (reverse = !reverse) {\nflower.add(\nScaleEffect.by(\nVector2.all(1.5),\nEffectController(duration: 0.3),\nonComplete: () => hold = false,\n),\n);\n} else {\nflower.add(\nScaleEffect.by(\nVector2.all(1 / 1.5),\nEffectController(duration: 0.3),\nonComplete: () => hold = false,\n),\n);\n}\n},\n);\nadd(flower);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that ScaleEffect.by¶: This effect will change the target’s scale by the specified amount. For example, this will cause the component to grow 50% larger:", "completion": "final effect = ScaleEffect.by(\n  Vector2.all(1.5),\n  EffectController(duration: 0.3),\n);"}
{"prompt": "Show me how to implement ScaleEffect.by¶: This effect will change the target’s scale by the specified amount. For example, this will cause the component to grow 50% larger: using Flutter Flame", "completion": "final effect = ScaleEffect.by(\n  Vector2.all(1.5),\n  EffectController(duration: 0.3),\n);"}
{"prompt": "Write Flutter Flame code to ScaleEffect.by¶: This effect will change the target’s scale by the specified amount. For example, this will cause the component to grow 50% larger:", "completion": "final effect = ScaleEffect.by(\n  Vector2.all(1.5),\n  EffectController(duration: 0.3),\n);"}
{"prompt": "Create a Flutter Flame game component that ScaleEffect.to¶: This effect works similar to ScaleEffect.by, but sets the absolute value of the target’s scale.", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass ScaleToEffectGame extends FlameGame {\nbool reverse = false;\nbool hold = false;\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nsize: 60,\nposition: canvasSize / 2,\nonTap: (flower) {\nif (hold) {\nreturn;\n}\nhold = true;\nif (reverse = !reverse) {\nflower.add(\nScaleEffect.to(\nVector2.all(0.5),\nEffectController(duration: 0.5),\nonComplete: () => hold = false,\n),\n);\n} else {\nflower.add(\nScaleEffect.to(\nVector2.all(1),\nEffectController(duration: 0.5),\nonComplete: () => hold = false,\n),\n);\n}\n},\n);\nadd(flower);\n}\n}"}
{"prompt": "Show me how to implement ScaleEffect.to¶: This effect works similar to ScaleEffect.by, but sets the absolute value of the target’s scale. using Flutter Flame", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass ScaleToEffectGame extends FlameGame {\nbool reverse = false;\nbool hold = false;\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nsize: 60,\nposition: canvasSize / 2,\nonTap: (flower) {\nif (hold) {\nreturn;\n}\nhold = true;\nif (reverse = !reverse) {\nflower.add(\nScaleEffect.to(\nVector2.all(0.5),\nEffectController(duration: 0.5),\nonComplete: () => hold = false,\n),\n);\n} else {\nflower.add(\nScaleEffect.to(\nVector2.all(1),\nEffectController(duration: 0.5),\nonComplete: () => hold = false,\n),\n);\n}\n},\n);\nadd(flower);\n}\n}"}
{"prompt": "Write Flutter Flame code to ScaleEffect.to¶: This effect works similar to ScaleEffect.by, but sets the absolute value of the target’s scale.", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass ScaleToEffectGame extends FlameGame {\nbool reverse = false;\nbool hold = false;\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nsize: 60,\nposition: canvasSize / 2,\nonTap: (flower) {\nif (hold) {\nreturn;\n}\nhold = true;\nif (reverse = !reverse) {\nflower.add(\nScaleEffect.to(\nVector2.all(0.5),\nEffectController(duration: 0.5),\nonComplete: () => hold = false,\n),\n);\n} else {\nflower.add(\nScaleEffect.to(\nVector2.all(1),\nEffectController(duration: 0.5),\nonComplete: () => hold = false,\n),\n);\n}\n},\n);\nadd(flower);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that ScaleEffect.to¶: This effect works similar to ScaleEffect.by, but sets the absolute value of the target’s scale.", "completion": "final effect = ScaleEffect.to(\n  Vector2.all(0.5),\n  EffectController(duration: 0.5),\n);"}
{"prompt": "Show me how to implement ScaleEffect.to¶: This effect works similar to ScaleEffect.by, but sets the absolute value of the target’s scale. using Flutter Flame", "completion": "final effect = ScaleEffect.to(\n  Vector2.all(0.5),\n  EffectController(duration: 0.5),\n);"}
{"prompt": "Write Flutter Flame code to ScaleEffect.to¶: This effect works similar to ScaleEffect.by, but sets the absolute value of the target’s scale.", "completion": "final effect = ScaleEffect.to(\n  Vector2.all(0.5),\n  EffectController(duration: 0.5),\n);"}
{"prompt": "Create a Flutter Flame game component that SizeEffect.by¶: This effect will change the size of the target component, relative to its current size. For example, if the target has size Vector2(100, 100), then after the following effect is applied and runs its course, the new size will be Vector2(120, 50):", "completion": "import 'package:doc_flame_examples/ember.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass SizeByEffectGame extends FlameGame {\nbool reset = false;\n@override\nFuture<void> onLoad() async {\nfinal ember = EmberPlayer(\nposition: size / 2,\nsize: Vector2(45, 40),\nonTap: (ember) {\nif (reset = !reset) {\nember.add(\nSizeEffect.by(\nVector2(-15, 30),\nEffectController(duration: 0.75),\n),\n);\n} else {\nember.add(\nSizeEffect.by(\nVector2(15, -30),\nEffectController(duration: 0.75),\n),\n);\n}\n},\n)..anchor = Anchor.center;\n\nadd(ember);\n}\n}"}
{"prompt": "Show me how to implement SizeEffect.by¶: This effect will change the size of the target component, relative to its current size. For example, if the target has size Vector2(100, 100), then after the following effect is applied and runs its course, the new size will be Vector2(120, 50): using Flutter Flame", "completion": "import 'package:doc_flame_examples/ember.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass SizeByEffectGame extends FlameGame {\nbool reset = false;\n@override\nFuture<void> onLoad() async {\nfinal ember = EmberPlayer(\nposition: size / 2,\nsize: Vector2(45, 40),\nonTap: (ember) {\nif (reset = !reset) {\nember.add(\nSizeEffect.by(\nVector2(-15, 30),\nEffectController(duration: 0.75),\n),\n);\n} else {\nember.add(\nSizeEffect.by(\nVector2(15, -30),\nEffectController(duration: 0.75),\n),\n);\n}\n},\n)..anchor = Anchor.center;\n\nadd(ember);\n}\n}"}
{"prompt": "Write Flutter Flame code to SizeEffect.by¶: This effect will change the size of the target component, relative to its current size. For example, if the target has size Vector2(100, 100), then after the following effect is applied and runs its course, the new size will be Vector2(120, 50):", "completion": "import 'package:doc_flame_examples/ember.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass SizeByEffectGame extends FlameGame {\nbool reset = false;\n@override\nFuture<void> onLoad() async {\nfinal ember = EmberPlayer(\nposition: size / 2,\nsize: Vector2(45, 40),\nonTap: (ember) {\nif (reset = !reset) {\nember.add(\nSizeEffect.by(\nVector2(-15, 30),\nEffectController(duration: 0.75),\n),\n);\n} else {\nember.add(\nSizeEffect.by(\nVector2(15, -30),\nEffectController(duration: 0.75),\n),\n);\n}\n},\n)..anchor = Anchor.center;\n\nadd(ember);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that SizeEffect.by¶: This effect will change the size of the target component, relative to its current size. For example, if the target has size Vector2(100, 100), then after the following effect is applied and runs its course, the new size will be Vector2(120, 50):", "completion": "final effect = SizeEffect.by(\n   Vector2(-15, 30),\n   EffectController(duration: 1),\n);"}
{"prompt": "Show me how to implement SizeEffect.by¶: This effect will change the size of the target component, relative to its current size. For example, if the target has size Vector2(100, 100), then after the following effect is applied and runs its course, the new size will be Vector2(120, 50): using Flutter Flame", "completion": "final effect = SizeEffect.by(\n   Vector2(-15, 30),\n   EffectController(duration: 1),\n);"}
{"prompt": "Write Flutter Flame code to SizeEffect.by¶: This effect will change the size of the target component, relative to its current size. For example, if the target has size Vector2(100, 100), then after the following effect is applied and runs its course, the new size will be Vector2(120, 50):", "completion": "final effect = SizeEffect.by(\n   Vector2(-15, 30),\n   EffectController(duration: 1),\n);"}
{"prompt": "Create a Flutter Flame game component that SizeEffect.to¶: Changes the size of the target component to the specified size. Target size cannot be negative:", "completion": "import 'package:doc_flame_examples/ember.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass SizeToEffectGame extends FlameGame {\nbool reset = false;\n@override\nFuture<void> onLoad() async {\nfinal ember = EmberPlayer(\nposition: size / 2,\nsize: Vector2(45, 40),\nonTap: (ember) {\nif (reset = !reset) {\nember.add(\nSizeEffect.to(\nVector2(90, 80),\nEffectController(duration: 0.75),\n),\n);\n} else {\nember.add(\nSizeEffect.to(\nVector2(45, 40),\nEffectController(duration: 0.75),\n),\n);\n}\n},\n)..anchor = Anchor.center;\n\nadd(ember);\n}\n}"}
{"prompt": "Show me how to implement SizeEffect.to¶: Changes the size of the target component to the specified size. Target size cannot be negative: using Flutter Flame", "completion": "import 'package:doc_flame_examples/ember.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass SizeToEffectGame extends FlameGame {\nbool reset = false;\n@override\nFuture<void> onLoad() async {\nfinal ember = EmberPlayer(\nposition: size / 2,\nsize: Vector2(45, 40),\nonTap: (ember) {\nif (reset = !reset) {\nember.add(\nSizeEffect.to(\nVector2(90, 80),\nEffectController(duration: 0.75),\n),\n);\n} else {\nember.add(\nSizeEffect.to(\nVector2(45, 40),\nEffectController(duration: 0.75),\n),\n);\n}\n},\n)..anchor = Anchor.center;\n\nadd(ember);\n}\n}"}
{"prompt": "Write Flutter Flame code to SizeEffect.to¶: Changes the size of the target component to the specified size. Target size cannot be negative:", "completion": "import 'package:doc_flame_examples/ember.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass SizeToEffectGame extends FlameGame {\nbool reset = false;\n@override\nFuture<void> onLoad() async {\nfinal ember = EmberPlayer(\nposition: size / 2,\nsize: Vector2(45, 40),\nonTap: (ember) {\nif (reset = !reset) {\nember.add(\nSizeEffect.to(\nVector2(90, 80),\nEffectController(duration: 0.75),\n),\n);\n} else {\nember.add(\nSizeEffect.to(\nVector2(45, 40),\nEffectController(duration: 0.75),\n),\n);\n}\n},\n)..anchor = Anchor.center;\n\nadd(ember);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that SizeEffect.to¶: Changes the size of the target component to the specified size. Target size cannot be negative:", "completion": "final effect = SizeEffect.to(\n  Vector2(90, 80),\n  EffectController(duration: 1),\n);"}
{"prompt": "Show me how to implement SizeEffect.to¶: Changes the size of the target component to the specified size. Target size cannot be negative: using Flutter Flame", "completion": "final effect = SizeEffect.to(\n  Vector2(90, 80),\n  EffectController(duration: 1),\n);"}
{"prompt": "Write Flutter Flame code to SizeEffect.to¶: Changes the size of the target component to the specified size. Target size cannot be negative:", "completion": "final effect = SizeEffect.to(\n  Vector2(90, 80),\n  EffectController(duration: 1),\n);"}
{"prompt": "Create a Flutter Flame game component that AnchorByEffect¶: Changes the location of the target’s anchor by the specified offset. This effect can also be created using AnchorEffect.by().", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass AnchorByEffectGame extends FlameGame {\nbool reset = false;\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nsize: 60,\nposition: canvasSize / 2,\nonTap: (flower) {\nif (reset = !reset) {\nflower.add(\nAnchorByEffect(\nVector2(0.5, 0.5),\nEffectController(speed: 1),\n),\n);\n} else {\nflower.add(\nAnchorByEffect(\nVector2(-0.5, -0.5),\nEffectController(speed: 1),\n),\n);\n}\n},\n);\nadd(flower);\n}\n}"}
{"prompt": "Show me how to implement AnchorByEffect¶: Changes the location of the target’s anchor by the specified offset. This effect can also be created using AnchorEffect.by(). using Flutter Flame", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass AnchorByEffectGame extends FlameGame {\nbool reset = false;\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nsize: 60,\nposition: canvasSize / 2,\nonTap: (flower) {\nif (reset = !reset) {\nflower.add(\nAnchorByEffect(\nVector2(0.5, 0.5),\nEffectController(speed: 1),\n),\n);\n} else {\nflower.add(\nAnchorByEffect(\nVector2(-0.5, -0.5),\nEffectController(speed: 1),\n),\n);\n}\n},\n);\nadd(flower);\n}\n}"}
{"prompt": "Write Flutter Flame code to AnchorByEffect¶: Changes the location of the target’s anchor by the specified offset. This effect can also be created using AnchorEffect.by().", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass AnchorByEffectGame extends FlameGame {\nbool reset = false;\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nsize: 60,\nposition: canvasSize / 2,\nonTap: (flower) {\nif (reset = !reset) {\nflower.add(\nAnchorByEffect(\nVector2(0.5, 0.5),\nEffectController(speed: 1),\n),\n);\n} else {\nflower.add(\nAnchorByEffect(\nVector2(-0.5, -0.5),\nEffectController(speed: 1),\n),\n);\n}\n},\n);\nadd(flower);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that AnchorByEffect¶: Changes the location of the target’s anchor by the specified offset. This effect can also be created using AnchorEffect.by().", "completion": "final effect = AnchorByEffect(\n  Vector2(0.1, 0.1),\n  EffectController(speed: 1),\n);"}
{"prompt": "Show me how to implement AnchorByEffect¶: Changes the location of the target’s anchor by the specified offset. This effect can also be created using AnchorEffect.by(). using Flutter Flame", "completion": "final effect = AnchorByEffect(\n  Vector2(0.1, 0.1),\n  EffectController(speed: 1),\n);"}
{"prompt": "Write Flutter Flame code to AnchorByEffect¶: Changes the location of the target’s anchor by the specified offset. This effect can also be created using AnchorEffect.by().", "completion": "final effect = AnchorByEffect(\n  Vector2(0.1, 0.1),\n  EffectController(speed: 1),\n);"}
{"prompt": "Create a Flutter Flame game component that AnchorToEffect¶: Changes the location of the target’s anchor. This effect can also be created using AnchorEffect.to().", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass AnchorToEffectGame extends FlameGame {\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nsize: 60,\nposition: canvasSize / 2,\nonTap: (flower) {\nif (flower.anchor == Anchor.center) {\nflower.add(\nAnchorToEffect(\nAnchor.bottomLeft,\nEffectController(speed: 1),\n),\n);\n} else {\nflower.add(\nAnchorToEffect(\nAnchor.center,\nEffectController(speed: 1),\n),\n);\n}\n},\n);\nadd(flower);\n}\n}"}
{"prompt": "Show me how to implement AnchorToEffect¶: Changes the location of the target’s anchor. This effect can also be created using AnchorEffect.to(). using Flutter Flame", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass AnchorToEffectGame extends FlameGame {\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nsize: 60,\nposition: canvasSize / 2,\nonTap: (flower) {\nif (flower.anchor == Anchor.center) {\nflower.add(\nAnchorToEffect(\nAnchor.bottomLeft,\nEffectController(speed: 1),\n),\n);\n} else {\nflower.add(\nAnchorToEffect(\nAnchor.center,\nEffectController(speed: 1),\n),\n);\n}\n},\n);\nadd(flower);\n}\n}"}
{"prompt": "Write Flutter Flame code to AnchorToEffect¶: Changes the location of the target’s anchor. This effect can also be created using AnchorEffect.to().", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass AnchorToEffectGame extends FlameGame {\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nsize: 60,\nposition: canvasSize / 2,\nonTap: (flower) {\nif (flower.anchor == Anchor.center) {\nflower.add(\nAnchorToEffect(\nAnchor.bottomLeft,\nEffectController(speed: 1),\n),\n);\n} else {\nflower.add(\nAnchorToEffect(\nAnchor.center,\nEffectController(speed: 1),\n),\n);\n}\n},\n);\nadd(flower);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that OpacityToEffect¶: This effect will change the opacity of the target over time to the specified alpha-value. It can only be applied to components that implement the OpacityProvider.", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass OpacityToEffectGame extends FlameGame {\nbool reset = false;\n\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nposition: size / 2,\nsize: 60,\nonTap: _onTap,\n)..anchor = Anchor.center;\n\nadd(flower);\n}\n\nvoid _onTap(Flower flower) {\nif (reset = !reset) {\nflower.add(\nOpacityEffect.to(\n0.2,\nEffectController(duration: 0.75),\n),\n);\n} else {\nflower.add(\nOpacityEffect.fadeIn(\nEffectController(duration: 0.75),\n),\n);\n}\n}\n}"}
{"prompt": "Show me how to implement OpacityToEffect¶: This effect will change the opacity of the target over time to the specified alpha-value. It can only be applied to components that implement the OpacityProvider. using Flutter Flame", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass OpacityToEffectGame extends FlameGame {\nbool reset = false;\n\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nposition: size / 2,\nsize: 60,\nonTap: _onTap,\n)..anchor = Anchor.center;\n\nadd(flower);\n}\n\nvoid _onTap(Flower flower) {\nif (reset = !reset) {\nflower.add(\nOpacityEffect.to(\n0.2,\nEffectController(duration: 0.75),\n),\n);\n} else {\nflower.add(\nOpacityEffect.fadeIn(\nEffectController(duration: 0.75),\n),\n);\n}\n}\n}"}
{"prompt": "Write Flutter Flame code to OpacityToEffect¶: This effect will change the opacity of the target over time to the specified alpha-value. It can only be applied to components that implement the OpacityProvider.", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass OpacityToEffectGame extends FlameGame {\nbool reset = false;\n\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nposition: size / 2,\nsize: 60,\nonTap: _onTap,\n)..anchor = Anchor.center;\n\nadd(flower);\n}\n\nvoid _onTap(Flower flower) {\nif (reset = !reset) {\nflower.add(\nOpacityEffect.to(\n0.2,\nEffectController(duration: 0.75),\n),\n);\n} else {\nflower.add(\nOpacityEffect.fadeIn(\nEffectController(duration: 0.75),\n),\n);\n}\n}\n}"}
{"prompt": "Create a Flutter Flame game component that OpacityToEffect¶: If the component uses multiple paints, the effect can target one more more of those paints using the target parameter. The HasPaint mixin implements OpacityProvider and exposes APIs to easily create providers for desired paintIds. For single paintId opacityProviderOf can be used and for multiple paintIds and opacityProviderOfList can be used.", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass OpacityEffectWithTargetGame extends FlameGame {\nbool reset = false;\n\n// This reference needs to be stored because every new instance of\n// OpacityProvider caches the opacity ratios at the time on creation.\nlate OpacityProvider _borderOpacityProvider;\n\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nposition: size / 2,\nsize: 60,\nonTap: _onTap,\n)..anchor = Anchor.center;\n\n_borderOpacityProvider = flower.opacityProviderOfList(\npaintIds: const [FlowerPaint.paintId1, FlowerPaint.paintId2],\n);\n\nadd(flower);\n}\n\nvoid _onTap(Flower flower) {\nif (reset = !reset) {\nflower.add(\nOpacityEffect.to(\n0.2,\nEffectController(duration: 0.75),\ntarget: _borderOpacityProvider,\n),\n);\n} else {\nflower.add(\nOpacityEffect.fadeIn(\nEffectController(duration: 0.75),\ntarget: _borderOpacityProvider,\n),\n);\n}\n}\n}"}
{"prompt": "Show me how to implement OpacityToEffect¶: If the component uses multiple paints, the effect can target one more more of those paints using the target parameter. The HasPaint mixin implements OpacityProvider and exposes APIs to easily create providers for desired paintIds. For single paintId opacityProviderOf can be used and for multiple paintIds and opacityProviderOfList can be used. using Flutter Flame", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass OpacityEffectWithTargetGame extends FlameGame {\nbool reset = false;\n\n// This reference needs to be stored because every new instance of\n// OpacityProvider caches the opacity ratios at the time on creation.\nlate OpacityProvider _borderOpacityProvider;\n\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nposition: size / 2,\nsize: 60,\nonTap: _onTap,\n)..anchor = Anchor.center;\n\n_borderOpacityProvider = flower.opacityProviderOfList(\npaintIds: const [FlowerPaint.paintId1, FlowerPaint.paintId2],\n);\n\nadd(flower);\n}\n\nvoid _onTap(Flower flower) {\nif (reset = !reset) {\nflower.add(\nOpacityEffect.to(\n0.2,\nEffectController(duration: 0.75),\ntarget: _borderOpacityProvider,\n),\n);\n} else {\nflower.add(\nOpacityEffect.fadeIn(\nEffectController(duration: 0.75),\ntarget: _borderOpacityProvider,\n),\n);\n}\n}\n}"}
{"prompt": "Write Flutter Flame code to OpacityToEffect¶: If the component uses multiple paints, the effect can target one more more of those paints using the target parameter. The HasPaint mixin implements OpacityProvider and exposes APIs to easily create providers for desired paintIds. For single paintId opacityProviderOf can be used and for multiple paintIds and opacityProviderOfList can be used.", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass OpacityEffectWithTargetGame extends FlameGame {\nbool reset = false;\n\n// This reference needs to be stored because every new instance of\n// OpacityProvider caches the opacity ratios at the time on creation.\nlate OpacityProvider _borderOpacityProvider;\n\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nposition: size / 2,\nsize: 60,\nonTap: _onTap,\n)..anchor = Anchor.center;\n\n_borderOpacityProvider = flower.opacityProviderOfList(\npaintIds: const [FlowerPaint.paintId1, FlowerPaint.paintId2],\n);\n\nadd(flower);\n}\n\nvoid _onTap(Flower flower) {\nif (reset = !reset) {\nflower.add(\nOpacityEffect.to(\n0.2,\nEffectController(duration: 0.75),\ntarget: _borderOpacityProvider,\n),\n);\n} else {\nflower.add(\nOpacityEffect.fadeIn(\nEffectController(duration: 0.75),\ntarget: _borderOpacityProvider,\n),\n);\n}\n}\n}"}
{"prompt": "Create a Flutter Flame game component that OpacityByEffect¶: This effect will change the opacity of the target relative to the specified alpha-value. For example, the following effect will change the opacity of the target by 90%:", "completion": "import 'package:doc_flame_examples/ember.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass OpacityByEffectGame extends FlameGame {\nbool reset = false;\n@override\nFuture<void> onLoad() async {\nfinal ember = EmberPlayer(\nposition: size / 2,\nsize: size / 4,\nonTap: (ember) {\nif (reset = !reset) {\nember.add(\nOpacityEffect.by(\n0.9,\nEffectController(duration: 0.75),\n),\n);\n} else {\nember.add(\nOpacityEffect.by(\n-0.9,\nEffectController(duration: 0.75),\n),\n);\n}\n},\n)..anchor = Anchor.center;\n\nadd(ember);\n}\n}"}
{"prompt": "Show me how to implement OpacityByEffect¶: This effect will change the opacity of the target relative to the specified alpha-value. For example, the following effect will change the opacity of the target by 90%: using Flutter Flame", "completion": "import 'package:doc_flame_examples/ember.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass OpacityByEffectGame extends FlameGame {\nbool reset = false;\n@override\nFuture<void> onLoad() async {\nfinal ember = EmberPlayer(\nposition: size / 2,\nsize: size / 4,\nonTap: (ember) {\nif (reset = !reset) {\nember.add(\nOpacityEffect.by(\n0.9,\nEffectController(duration: 0.75),\n),\n);\n} else {\nember.add(\nOpacityEffect.by(\n-0.9,\nEffectController(duration: 0.75),\n),\n);\n}\n},\n)..anchor = Anchor.center;\n\nadd(ember);\n}\n}"}
{"prompt": "Write Flutter Flame code to OpacityByEffect¶: This effect will change the opacity of the target relative to the specified alpha-value. For example, the following effect will change the opacity of the target by 90%:", "completion": "import 'package:doc_flame_examples/ember.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass OpacityByEffectGame extends FlameGame {\nbool reset = false;\n@override\nFuture<void> onLoad() async {\nfinal ember = EmberPlayer(\nposition: size / 2,\nsize: size / 4,\nonTap: (ember) {\nif (reset = !reset) {\nember.add(\nOpacityEffect.by(\n0.9,\nEffectController(duration: 0.75),\n),\n);\n} else {\nember.add(\nOpacityEffect.by(\n-0.9,\nEffectController(duration: 0.75),\n),\n);\n}\n},\n)..anchor = Anchor.center;\n\nadd(ember);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that GlowEffect¶: This effect will apply the glowing shade around target relative to the specified glow-strength. The color of shade will be targets paint color. For example, the following effect will apply the glowing shade around target by strength of 10:", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nimport 'package:flutter/material.dart';\n\nclass GlowEffectExample extends FlameGame {\n@override\nFuture<void> onLoad() async {\nfinal paint = Paint()..color = const Color(0xff39FF14);\n\nadd(\nCircleComponent(\nradius: size.y / 4,\nposition: size / 2,\nanchor: Anchor.center,\npaint: paint,\n)..add(\nGlowEffect(\n10.0,\nEffectController(\nduration: 2,\ninfinite: true,\n),\n),\n),\n);\n}\n}"}
{"prompt": "Show me how to implement GlowEffect¶: This effect will apply the glowing shade around target relative to the specified glow-strength. The color of shade will be targets paint color. For example, the following effect will apply the glowing shade around target by strength of 10: using Flutter Flame", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nimport 'package:flutter/material.dart';\n\nclass GlowEffectExample extends FlameGame {\n@override\nFuture<void> onLoad() async {\nfinal paint = Paint()..color = const Color(0xff39FF14);\n\nadd(\nCircleComponent(\nradius: size.y / 4,\nposition: size / 2,\nanchor: Anchor.center,\npaint: paint,\n)..add(\nGlowEffect(\n10.0,\nEffectController(\nduration: 2,\ninfinite: true,\n),\n),\n),\n);\n}\n}"}
{"prompt": "Write Flutter Flame code to GlowEffect¶: This effect will apply the glowing shade around target relative to the specified glow-strength. The color of shade will be targets paint color. For example, the following effect will apply the glowing shade around target by strength of 10:", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nimport 'package:flutter/material.dart';\n\nclass GlowEffectExample extends FlameGame {\n@override\nFuture<void> onLoad() async {\nfinal paint = Paint()..color = const Color(0xff39FF14);\n\nadd(\nCircleComponent(\nradius: size.y / 4,\nposition: size / 2,\nanchor: Anchor.center,\npaint: paint,\n)..add(\nGlowEffect(\n10.0,\nEffectController(\nduration: 2,\ninfinite: true,\n),\n),\n),\n);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that SequenceEffect¶: The sequence effect can also be alternating (the sequence will first run forward, and then backward); and also repeat a certain predetermined number of times, or infinitely.", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass SequenceEffectGame extends FlameGame {\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nsize: 40,\nposition: canvasSize / 2,\nonTap: (flower) {\nflower.add(\nSequenceEffect([\nScaleEffect.by(\nVector2.all(1.5),\nEffectController(duration: 0.2, alternate: true),\n),\nMoveEffect.by(\nVector2(30, -50),\nEffectController(duration: 0.5),\n),\nMoveEffect.by(\nVector2(-30, 50),\nEffectController(duration: 0.5),\n),\nScaleEffect.by(\nVector2.all(0.75),\nEffectController(duration: 0.2, alternate: true),\n),\n]),\n);\n},\n);\nadd(flower);\n}\n}"}
{"prompt": "Show me how to implement SequenceEffect¶: The sequence effect can also be alternating (the sequence will first run forward, and then backward); and also repeat a certain predetermined number of times, or infinitely. using Flutter Flame", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass SequenceEffectGame extends FlameGame {\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nsize: 40,\nposition: canvasSize / 2,\nonTap: (flower) {\nflower.add(\nSequenceEffect([\nScaleEffect.by(\nVector2.all(1.5),\nEffectController(duration: 0.2, alternate: true),\n),\nMoveEffect.by(\nVector2(30, -50),\nEffectController(duration: 0.5),\n),\nMoveEffect.by(\nVector2(-30, 50),\nEffectController(duration: 0.5),\n),\nScaleEffect.by(\nVector2.all(0.75),\nEffectController(duration: 0.2, alternate: true),\n),\n]),\n);\n},\n);\nadd(flower);\n}\n}"}
{"prompt": "Write Flutter Flame code to SequenceEffect¶: The sequence effect can also be alternating (the sequence will first run forward, and then backward); and also repeat a certain predetermined number of times, or infinitely.", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\n\nclass SequenceEffectGame extends FlameGame {\n@override\nFuture<void> onLoad() async {\nfinal flower = Flower(\nsize: 40,\nposition: canvasSize / 2,\nonTap: (flower) {\nflower.add(\nSequenceEffect([\nScaleEffect.by(\nVector2.all(1.5),\nEffectController(duration: 0.2, alternate: true),\n),\nMoveEffect.by(\nVector2(30, -50),\nEffectController(duration: 0.5),\n),\nMoveEffect.by(\nVector2(-30, 50),\nEffectController(duration: 0.5),\n),\nScaleEffect.by(\nVector2.all(0.75),\nEffectController(duration: 0.2, alternate: true),\n),\n]),\n);\n},\n);\nadd(flower);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that SequenceEffect¶: The sequence effect can also be alternating (the sequence will first run forward, and then backward); and also repeat a certain predetermined number of times, or infinitely.", "completion": "final effect = SequenceEffect([\n  ScaleEffect.by(\n    Vector2.all(1.5),\n    EffectController(\n      duration: 0.2,\n      alternate: true,\n    ),\n  ),\n  MoveEffect.by(\n    Vector2(30, -50),\n    EffectController(\n      duration: 0.5,\n    ),\n  ),\n  OpacityEffect.to(\n,\n    EffectController(\n      duration: 0.3,\n    ),\n  ),\n  RemoveEffect(),\n]);"}
{"prompt": "Show me how to implement SequenceEffect¶: The sequence effect can also be alternating (the sequence will first run forward, and then backward); and also repeat a certain predetermined number of times, or infinitely. using Flutter Flame", "completion": "final effect = SequenceEffect([\n  ScaleEffect.by(\n    Vector2.all(1.5),\n    EffectController(\n      duration: 0.2,\n      alternate: true,\n    ),\n  ),\n  MoveEffect.by(\n    Vector2(30, -50),\n    EffectController(\n      duration: 0.5,\n    ),\n  ),\n  OpacityEffect.to(\n,\n    EffectController(\n      duration: 0.3,\n    ),\n  ),\n  RemoveEffect(),\n]);"}
{"prompt": "Write Flutter Flame code to SequenceEffect¶: The sequence effect can also be alternating (the sequence will first run forward, and then backward); and also repeat a certain predetermined number of times, or infinitely.", "completion": "final effect = SequenceEffect([\n  ScaleEffect.by(\n    Vector2.all(1.5),\n    EffectController(\n      duration: 0.2,\n      alternate: true,\n    ),\n  ),\n  MoveEffect.by(\n    Vector2(30, -50),\n    EffectController(\n      duration: 0.5,\n    ),\n  ),\n  OpacityEffect.to(\n,\n    EffectController(\n      duration: 0.3,\n    ),\n  ),\n  RemoveEffect(),\n]);"}
{"prompt": "Create a Flutter Flame game component that RemoveEffect¶: This is a simple effect that can be attached to a component causing it to be removed from the game tree after the specified delay has passed:", "completion": "import 'package:doc_flame_examples/ember.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\n\nclass RemoveEffectGame extends FlameGame with TapDetector {\nstatic const double delayTime = 3;\nlate EmberPlayer ember;\nlate TextComponent textComponent;\nfinal RemoveEffect effect = RemoveEffect(delay: delayTime);\n\n@override\nFuture<void> onLoad() async {\nadd(\nember = EmberPlayer(\nposition: size / 2,\nsize: Vector2(45, 40),\n)..anchor = Anchor.center,\n);\nadd(textComponent = TextComponent()..position = Vector2.all(5));\n}\n\n@override\nvoid onTap() {\nif (children.contains(ember)) {\nember.add(effect);\n} else {\neffect.reset();\nadd(ember);\n}\n}\n\n@override\nvoid update(double dt) {\ntextComponent.text =\n(effect.controller.progress * delayTime).toStringAsFixed(2);\nsuper.update(dt);\n}\n}"}
{"prompt": "Show me how to implement RemoveEffect¶: This is a simple effect that can be attached to a component causing it to be removed from the game tree after the specified delay has passed: using Flutter Flame", "completion": "import 'package:doc_flame_examples/ember.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\n\nclass RemoveEffectGame extends FlameGame with TapDetector {\nstatic const double delayTime = 3;\nlate EmberPlayer ember;\nlate TextComponent textComponent;\nfinal RemoveEffect effect = RemoveEffect(delay: delayTime);\n\n@override\nFuture<void> onLoad() async {\nadd(\nember = EmberPlayer(\nposition: size / 2,\nsize: Vector2(45, 40),\n)..anchor = Anchor.center,\n);\nadd(textComponent = TextComponent()..position = Vector2.all(5));\n}\n\n@override\nvoid onTap() {\nif (children.contains(ember)) {\nember.add(effect);\n} else {\neffect.reset();\nadd(ember);\n}\n}\n\n@override\nvoid update(double dt) {\ntextComponent.text =\n(effect.controller.progress * delayTime).toStringAsFixed(2);\nsuper.update(dt);\n}\n}"}
{"prompt": "Write Flutter Flame code to RemoveEffect¶: This is a simple effect that can be attached to a component causing it to be removed from the game tree after the specified delay has passed:", "completion": "import 'package:doc_flame_examples/ember.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\n\nclass RemoveEffectGame extends FlameGame with TapDetector {\nstatic const double delayTime = 3;\nlate EmberPlayer ember;\nlate TextComponent textComponent;\nfinal RemoveEffect effect = RemoveEffect(delay: delayTime);\n\n@override\nFuture<void> onLoad() async {\nadd(\nember = EmberPlayer(\nposition: size / 2,\nsize: Vector2(45, 40),\n)..anchor = Anchor.center,\n);\nadd(textComponent = TextComponent()..position = Vector2.all(5));\n}\n\n@override\nvoid onTap() {\nif (children.contains(ember)) {\nember.add(effect);\n} else {\neffect.reset();\nadd(ember);\n}\n}\n\n@override\nvoid update(double dt) {\ntextComponent.text =\n(effect.controller.progress * delayTime).toStringAsFixed(2);\nsuper.update(dt);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that ColorEffect¶: Usage example:", "completion": "import 'package:doc_flame_examples/ember.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\nimport 'package:flutter/animation.dart';\nimport 'package:flutter/cupertino.dart';\n\nclass ColorEffectExample extends FlameGame {\nbool reset = false;\n\n@override\nFuture<void> onLoad() async {\nfinal ember = EmberPlayer(\nposition: size / 2,\nsize: size / 4,\nonTap: (ember) {\nif (reset = !reset) {\nember.add(\nColorEffect(\nconst Color(0xFF00FF00),\nEffectController(duration: 1.5),\nopacityTo: 0.6,\n),\n);\n} else {\nember.add(\nColorEffect(\nconst Color(0xFF1039DB),\nEffectController(duration: 1.5),\nopacityTo: 0.6,\n),\n);\n}\n},\n)..anchor = Anchor.center;\n\nadd(ember);\n}\n}"}
{"prompt": "Show me how to implement ColorEffect¶: Usage example: using Flutter Flame", "completion": "import 'package:doc_flame_examples/ember.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\nimport 'package:flutter/animation.dart';\nimport 'package:flutter/cupertino.dart';\n\nclass ColorEffectExample extends FlameGame {\nbool reset = false;\n\n@override\nFuture<void> onLoad() async {\nfinal ember = EmberPlayer(\nposition: size / 2,\nsize: size / 4,\nonTap: (ember) {\nif (reset = !reset) {\nember.add(\nColorEffect(\nconst Color(0xFF00FF00),\nEffectController(duration: 1.5),\nopacityTo: 0.6,\n),\n);\n} else {\nember.add(\nColorEffect(\nconst Color(0xFF1039DB),\nEffectController(duration: 1.5),\nopacityTo: 0.6,\n),\n);\n}\n},\n)..anchor = Anchor.center;\n\nadd(ember);\n}\n}"}
{"prompt": "Write Flutter Flame code to ColorEffect¶: Usage example:", "completion": "import 'package:doc_flame_examples/ember.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\nimport 'package:flutter/animation.dart';\nimport 'package:flutter/cupertino.dart';\n\nclass ColorEffectExample extends FlameGame {\nbool reset = false;\n\n@override\nFuture<void> onLoad() async {\nfinal ember = EmberPlayer(\nposition: size / 2,\nsize: size / 4,\nonTap: (ember) {\nif (reset = !reset) {\nember.add(\nColorEffect(\nconst Color(0xFF00FF00),\nEffectController(duration: 1.5),\nopacityTo: 0.6,\n),\n);\n} else {\nember.add(\nColorEffect(\nconst Color(0xFF1039DB),\nEffectController(duration: 1.5),\nopacityTo: 0.6,\n),\n);\n}\n},\n)..anchor = Anchor.center;\n\nadd(ember);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that Object creation per frame¶: It is like buying a new computer every time you want to send an email or buying a new pen every time you want to write something. Sure it gets the job done, but it is not very economically smart.", "completion": "class MyComponent extends PositionComponent {\n  @override\n  void update(double dt) {\n    position += Vector2(10, 20) * dt;\n  }\n\n  @override\n  void render(Canvas canvas) {\n    canvas.drawRect(size.toRect(), Paint());\n  }\n}"}
{"prompt": "Show me how to implement Object creation per frame¶: It is like buying a new computer every time you want to send an email or buying a new pen every time you want to write something. Sure it gets the job done, but it is not very economically smart. using Flutter Flame", "completion": "class MyComponent extends PositionComponent {\n  @override\n  void update(double dt) {\n    position += Vector2(10, 20) * dt;\n  }\n\n  @override\n  void render(Canvas canvas) {\n    canvas.drawRect(size.toRect(), Paint());\n  }\n}"}
{"prompt": "Write Flutter Flame code to Object creation per frame¶: It is like buying a new computer every time you want to send an email or buying a new pen every time you want to write something. Sure it gets the job done, but it is not very economically smart.", "completion": "class MyComponent extends PositionComponent {\n  @override\n  void update(double dt) {\n    position += Vector2(10, 20) * dt;\n  }\n\n  @override\n  void render(Canvas canvas) {\n    canvas.drawRect(size.toRect(), Paint());\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Object creation per frame¶: A better way of doing things would be something like as shown below. This code stores the required Vector2 and Paint objects as class members and reuses them across all the update and render calls.", "completion": "class MyComponent extends PositionComponent {\n  final _direction = Vector2(10, 20);\n  final _paint = Paint();\n\n  @override\n  void update(double dt) {\n    position.setValues(\n      position.x + _direction.x * dt, \n      position.y + _direction.y * dt,\n    );\n  }\n\n  @override\n  void render(Canvas canvas) {\n    canvas.drawRect(size.toRect(), _paint);\n  }\n}"}
{"prompt": "Show me how to implement Object creation per frame¶: A better way of doing things would be something like as shown below. This code stores the required Vector2 and Paint objects as class members and reuses them across all the update and render calls. using Flutter Flame", "completion": "class MyComponent extends PositionComponent {\n  final _direction = Vector2(10, 20);\n  final _paint = Paint();\n\n  @override\n  void update(double dt) {\n    position.setValues(\n      position.x + _direction.x * dt, \n      position.y + _direction.y * dt,\n    );\n  }\n\n  @override\n  void render(Canvas canvas) {\n    canvas.drawRect(size.toRect(), _paint);\n  }\n}"}
{"prompt": "Write Flutter Flame code to Object creation per frame¶: A better way of doing things would be something like as shown below. This code stores the required Vector2 and Paint objects as class members and reuses them across all the update and render calls.", "completion": "class MyComponent extends PositionComponent {\n  final _direction = Vector2(10, 20);\n  final _paint = Paint();\n\n  @override\n  void update(double dt) {\n    position.setValues(\n      position.x + _direction.x * dt, \n      position.y + _direction.y * dt,\n    );\n  }\n\n  @override\n  void render(Canvas canvas) {\n    canvas.drawRect(size.toRect(), _paint);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Admonitions¶: Admonitions are emphasized blocks of text with a distinct appearance. They are created using the triple-backticks syntax:", "completion": "```{note}\nPlease note this very important caveat.\n```\n```{warning}\nDon't look down, or you will encounter an error.\n```\n```{error}\nI told you so.\n```\n```{seealso}\nAlso check out this cool thingy.\n```"}
{"prompt": "Show me how to implement Admonitions¶: Admonitions are emphasized blocks of text with a distinct appearance. They are created using the triple-backticks syntax: using Flutter Flame", "completion": "```{note}\nPlease note this very important caveat.\n```\n```{warning}\nDon't look down, or you will encounter an error.\n```\n```{error}\nI told you so.\n```\n```{seealso}\nAlso check out this cool thingy.\n```"}
{"prompt": "Write Flutter Flame code to Admonitions¶: Admonitions are emphasized blocks of text with a distinct appearance. They are created using the triple-backticks syntax:", "completion": "```{note}\nPlease note this very important caveat.\n```\n```{warning}\nDon't look down, or you will encounter an error.\n```\n```{error}\nI told you so.\n```\n```{seealso}\nAlso check out this cool thingy.\n```"}
{"prompt": "Create a Flutter Flame game component that Live examples¶: height: an integer that defines the height of the embedded application. If this is not defined, the height will be 350px.", "completion": "import 'dart:math';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flutter/rendering.dart';\n\nclass TapEventsGame extends FlameGame {\n@override\nFuture<void> onLoad() async {\nadd(TapTarget());\n}\n}\n\n/// This component is the tappable blue-ish rectangle in the center of the game.\n/// It uses the [TapCallbacks] mixin to receive tap events.\nclass TapTarget extends PositionComponent with TapCallbacks {\nTapTarget() : super(anchor: Anchor.center);\n\nfinal _paint = Paint()..color = const Color(0x448BA8FF);\n\n/// We will store all current circles into this map, keyed by the `pointerId`\n/// of the event that created the circle.\nfinal Map<int, ExpandingCircle> _circles = {};\n\n@override\nvoid onGameResize(Vector2 size) {\nsuper.onGameResize(size);\nthis.size = size - Vector2(100, 75);\nif (this.size.x < 100 || this.size.y < 100) {\nthis.size = size * 0.9;\n}\nposition = size / 2;\n}\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRect(size.toRect(), _paint);\n}\n\n@override\nvoid onTapDown(TapDownEvent event) {\nfinal circle = ExpandingCircle(event.localPosition);\n_circles[event.pointerId] = circle;\nadd(circle);\n}\n\n@override\nvoid onLongTapDown(TapDownEvent event) {\n_circles[event.pointerId]!.accent();\n}\n\n@override\nvoid onTapUp(TapUpEvent event) {\n_circles.remove(event.pointerId)!.release();\n}\n\n@override\nvoid onTapCancel(TapCancelEvent event) {\n_circles.remove(event.pointerId)!.cancel();\n}\n}\n\nclass ExpandingCircle extends Component {\nExpandingCircle(this._center)\n: _baseColor =\nHSLColor.fromAHSL(1, random.nextDouble() * 360, 1, 0.8).toColor();\n\nfinal Color _baseColor;\nfinal Vector2 _center;\ndouble _outerRadius = 0;\ndouble _innerRadius = 0;\nbool _released = false;\nbool _cancelled = false;\nlate final _paint = Paint()\n..style = PaintingStyle.stroke\n..color = _baseColor;\n\n/// \"Accent\" is thin white circle generated by `onLongTapDown`. We use\n/// negative radius to indicate that the circle should not be drawn yet.\ndouble _accentRadius = -1e10;\nlate final _accentPaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 0\n..color = const Color(0xFFFFFFFF);\n\n/// At this radius the circle will disappear.\nstatic const maxRadius = 175;\nstatic final random = Random();\n\ndouble get radius => (_innerRadius + _outerRadius) / 2;\n\nvoid release() => _released = true;\nvoid cancel() => _cancelled = true;\nvoid accent() => _accentRadius = 0;\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawCircle(_center.toOffset(), radius, _paint);\nif (_accentRadius >= 0) {\ncanvas.drawCircle(_center.toOffset(), _accentRadius, _accentPaint);\n}\n}\n\n@override\nvoid update(double dt) {\nif (_cancelled) {\n_innerRadius += dt * 100; // implosion\n} else {\n_outerRadius += dt * 20;\n_innerRadius += dt * (_released ? 20 : 6);\n_accentRadius += dt * 20;\n}\nif (radius >= maxRadius || _innerRadius > _outerRadius) {\nremoveFromParent();\n} else {\nfinal opacity = 1 - radius / maxRadius;\n_paint.color = _baseColor.withValues(alpha: opacity);\n_paint.strokeWidth = _outerRadius - _innerRadius;\n}\n}\n}"}
{"prompt": "Show me how to implement Live examples¶: height: an integer that defines the height of the embedded application. If this is not defined, the height will be 350px. using Flutter Flame", "completion": "import 'dart:math';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flutter/rendering.dart';\n\nclass TapEventsGame extends FlameGame {\n@override\nFuture<void> onLoad() async {\nadd(TapTarget());\n}\n}\n\n/// This component is the tappable blue-ish rectangle in the center of the game.\n/// It uses the [TapCallbacks] mixin to receive tap events.\nclass TapTarget extends PositionComponent with TapCallbacks {\nTapTarget() : super(anchor: Anchor.center);\n\nfinal _paint = Paint()..color = const Color(0x448BA8FF);\n\n/// We will store all current circles into this map, keyed by the `pointerId`\n/// of the event that created the circle.\nfinal Map<int, ExpandingCircle> _circles = {};\n\n@override\nvoid onGameResize(Vector2 size) {\nsuper.onGameResize(size);\nthis.size = size - Vector2(100, 75);\nif (this.size.x < 100 || this.size.y < 100) {\nthis.size = size * 0.9;\n}\nposition = size / 2;\n}\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRect(size.toRect(), _paint);\n}\n\n@override\nvoid onTapDown(TapDownEvent event) {\nfinal circle = ExpandingCircle(event.localPosition);\n_circles[event.pointerId] = circle;\nadd(circle);\n}\n\n@override\nvoid onLongTapDown(TapDownEvent event) {\n_circles[event.pointerId]!.accent();\n}\n\n@override\nvoid onTapUp(TapUpEvent event) {\n_circles.remove(event.pointerId)!.release();\n}\n\n@override\nvoid onTapCancel(TapCancelEvent event) {\n_circles.remove(event.pointerId)!.cancel();\n}\n}\n\nclass ExpandingCircle extends Component {\nExpandingCircle(this._center)\n: _baseColor =\nHSLColor.fromAHSL(1, random.nextDouble() * 360, 1, 0.8).toColor();\n\nfinal Color _baseColor;\nfinal Vector2 _center;\ndouble _outerRadius = 0;\ndouble _innerRadius = 0;\nbool _released = false;\nbool _cancelled = false;\nlate final _paint = Paint()\n..style = PaintingStyle.stroke\n..color = _baseColor;\n\n/// \"Accent\" is thin white circle generated by `onLongTapDown`. We use\n/// negative radius to indicate that the circle should not be drawn yet.\ndouble _accentRadius = -1e10;\nlate final _accentPaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 0\n..color = const Color(0xFFFFFFFF);\n\n/// At this radius the circle will disappear.\nstatic const maxRadius = 175;\nstatic final random = Random();\n\ndouble get radius => (_innerRadius + _outerRadius) / 2;\n\nvoid release() => _released = true;\nvoid cancel() => _cancelled = true;\nvoid accent() => _accentRadius = 0;\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawCircle(_center.toOffset(), radius, _paint);\nif (_accentRadius >= 0) {\ncanvas.drawCircle(_center.toOffset(), _accentRadius, _accentPaint);\n}\n}\n\n@override\nvoid update(double dt) {\nif (_cancelled) {\n_innerRadius += dt * 100; // implosion\n} else {\n_outerRadius += dt * 20;\n_innerRadius += dt * (_released ? 20 : 6);\n_accentRadius += dt * 20;\n}\nif (radius >= maxRadius || _innerRadius > _outerRadius) {\nremoveFromParent();\n} else {\nfinal opacity = 1 - radius / maxRadius;\n_paint.color = _baseColor.withValues(alpha: opacity);\n_paint.strokeWidth = _outerRadius - _innerRadius;\n}\n}\n}"}
{"prompt": "Write Flutter Flame code to Live examples¶: height: an integer that defines the height of the embedded application. If this is not defined, the height will be 350px.", "completion": "import 'dart:math';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flutter/rendering.dart';\n\nclass TapEventsGame extends FlameGame {\n@override\nFuture<void> onLoad() async {\nadd(TapTarget());\n}\n}\n\n/// This component is the tappable blue-ish rectangle in the center of the game.\n/// It uses the [TapCallbacks] mixin to receive tap events.\nclass TapTarget extends PositionComponent with TapCallbacks {\nTapTarget() : super(anchor: Anchor.center);\n\nfinal _paint = Paint()..color = const Color(0x448BA8FF);\n\n/// We will store all current circles into this map, keyed by the `pointerId`\n/// of the event that created the circle.\nfinal Map<int, ExpandingCircle> _circles = {};\n\n@override\nvoid onGameResize(Vector2 size) {\nsuper.onGameResize(size);\nthis.size = size - Vector2(100, 75);\nif (this.size.x < 100 || this.size.y < 100) {\nthis.size = size * 0.9;\n}\nposition = size / 2;\n}\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRect(size.toRect(), _paint);\n}\n\n@override\nvoid onTapDown(TapDownEvent event) {\nfinal circle = ExpandingCircle(event.localPosition);\n_circles[event.pointerId] = circle;\nadd(circle);\n}\n\n@override\nvoid onLongTapDown(TapDownEvent event) {\n_circles[event.pointerId]!.accent();\n}\n\n@override\nvoid onTapUp(TapUpEvent event) {\n_circles.remove(event.pointerId)!.release();\n}\n\n@override\nvoid onTapCancel(TapCancelEvent event) {\n_circles.remove(event.pointerId)!.cancel();\n}\n}\n\nclass ExpandingCircle extends Component {\nExpandingCircle(this._center)\n: _baseColor =\nHSLColor.fromAHSL(1, random.nextDouble() * 360, 1, 0.8).toColor();\n\nfinal Color _baseColor;\nfinal Vector2 _center;\ndouble _outerRadius = 0;\ndouble _innerRadius = 0;\nbool _released = false;\nbool _cancelled = false;\nlate final _paint = Paint()\n..style = PaintingStyle.stroke\n..color = _baseColor;\n\n/// \"Accent\" is thin white circle generated by `onLongTapDown`. We use\n/// negative radius to indicate that the circle should not be drawn yet.\ndouble _accentRadius = -1e10;\nlate final _accentPaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 0\n..color = const Color(0xFFFFFFFF);\n\n/// At this radius the circle will disappear.\nstatic const maxRadius = 175;\nstatic final random = Random();\n\ndouble get radius => (_innerRadius + _outerRadius) / 2;\n\nvoid release() => _released = true;\nvoid cancel() => _cancelled = true;\nvoid accent() => _accentRadius = 0;\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawCircle(_center.toOffset(), radius, _paint);\nif (_accentRadius >= 0) {\ncanvas.drawCircle(_center.toOffset(), _accentRadius, _accentPaint);\n}\n}\n\n@override\nvoid update(double dt) {\nif (_cancelled) {\n_innerRadius += dt * 100; // implosion\n} else {\n_outerRadius += dt * 20;\n_innerRadius += dt * (_released ? 20 : 6);\n_accentRadius += dt * 20;\n}\nif (radius >= maxRadius || _innerRadius > _outerRadius) {\nremoveFromParent();\n} else {\nfinal opacity = 1 - radius / maxRadius;\n_paint.color = _baseColor.withValues(alpha: opacity);\n_paint.strokeWidth = _outerRadius - _innerRadius;\n}\n}\n}"}
{"prompt": "Create a Flutter Flame game component that Assets Directory Structure¶: If using the following example code:", "completion": "class MyGame extends FlameGame {\n  @override\n  Future<void> onLoad() async {\n    await FlameAudio.play('explosion.mp3');\n\n    // Load some images\n    await Flame.images.load('player.png');\n    await Flame.images.load('enemy.png');\n    \n    // Or load all images in your images folder\n    await Flame.images.loadAllImages();\n\n    final map1 = await TiledComponent.load('level.tmx', tileSize);\n  }\n}"}
{"prompt": "Show me how to implement Assets Directory Structure¶: If using the following example code: using Flutter Flame", "completion": "class MyGame extends FlameGame {\n  @override\n  Future<void> onLoad() async {\n    await FlameAudio.play('explosion.mp3');\n\n    // Load some images\n    await Flame.images.load('player.png');\n    await Flame.images.load('enemy.png');\n    \n    // Or load all images in your images folder\n    await Flame.images.loadAllImages();\n\n    final map1 = await TiledComponent.load('level.tmx', tileSize);\n  }\n}"}
{"prompt": "Write Flutter Flame code to Assets Directory Structure¶: If using the following example code:", "completion": "class MyGame extends FlameGame {\n  @override\n  Future<void> onLoad() async {\n    await FlameAudio.play('explosion.mp3');\n\n    // Load some images\n    await Flame.images.load('player.png');\n    await Flame.images.load('enemy.png');\n    \n    // Or load all images in your images folder\n    await Flame.images.loadAllImages();\n\n    final map1 = await TiledComponent.load('level.tmx', tileSize);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Camera & World¶: Example of a simple game structure:", "completion": "FlameGame\n├── World\n│   ├── Player\n│   └── Enemy\n└── CameraComponent\n    ├── Viewfinder\n    │   ├── HudButton\n    │   └── FpsTextComponent\n    └── Viewport"}
{"prompt": "Show me how to implement Camera & World¶: Example of a simple game structure: using Flutter Flame", "completion": "FlameGame\n├── World\n│   ├── Player\n│   └── Enemy\n└── CameraComponent\n    ├── Viewfinder\n    │   ├── HudButton\n    │   └── FpsTextComponent\n    └── Viewport"}
{"prompt": "Write Flutter Flame code to Camera & World¶: Example of a simple game structure:", "completion": "FlameGame\n├── World\n│   ├── Player\n│   └── Enemy\n└── CameraComponent\n    ├── Viewfinder\n    │   ├── HudButton\n    │   └── FpsTextComponent\n    └── Viewport"}
{"prompt": "Create a Flutter Flame game component that World¶: For many games you want to extend the world and create your logic in there, such a game structure could look like this:", "completion": "void main() {\n  runApp(GameWidget(FlameGame(world: MyWorld())));\n}\n\nclass MyWorld extends World {\n  @override\n  Future<void> onLoad() async {\n    // Load all the assets that are needed in this world\n    // and add components etc.\n  }\n}"}
{"prompt": "Show me how to implement World¶: For many games you want to extend the world and create your logic in there, such a game structure could look like this: using Flutter Flame", "completion": "void main() {\n  runApp(GameWidget(FlameGame(world: MyWorld())));\n}\n\nclass MyWorld extends World {\n  @override\n  Future<void> onLoad() async {\n    // Load all the assets that are needed in this world\n    // and add components etc.\n  }\n}"}
{"prompt": "Write Flutter Flame code to World¶: For many games you want to extend the world and create your logic in there, such a game structure could look like this:", "completion": "void main() {\n  runApp(GameWidget(FlameGame(world: MyWorld())));\n}\n\nclass MyWorld extends World {\n  @override\n  Future<void> onLoad() async {\n    // Load all the assets that are needed in this world\n    // and add components etc.\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that CameraComponent¶: The FlameGame class has a camera field in its constructor, so you can set what type of default camera that you want, like this camera with a fixed resolution for example:", "completion": "void main() {\n  runApp(\n    GameWidget(\n      FlameGame(\n        camera: CameraComponent.withFixedResolution(\n          width: 800,\n          height: 600,\n        ),\n        world: MyWorld(),\n      ),\n    ),\n  );\n}"}
{"prompt": "Show me how to implement CameraComponent¶: The FlameGame class has a camera field in its constructor, so you can set what type of default camera that you want, like this camera with a fixed resolution for example: using Flutter Flame", "completion": "void main() {\n  runApp(\n    GameWidget(\n      FlameGame(\n        camera: CameraComponent.withFixedResolution(\n          width: 800,\n          height: 600,\n        ),\n        world: MyWorld(),\n      ),\n    ),\n  );\n}"}
{"prompt": "Write Flutter Flame code to CameraComponent¶: The FlameGame class has a camera field in its constructor, so you can set what type of default camera that you want, like this camera with a fixed resolution for example:", "completion": "void main() {\n  runApp(\n    GameWidget(\n      FlameGame(\n        camera: CameraComponent.withFixedResolution(\n          width: 800,\n          height: 600,\n        ),\n        world: MyWorld(),\n      ),\n    ),\n  );\n}"}
{"prompt": "Create a Flutter Flame game component that CameraComponent with fixed resolution¶: This named constructor will let you pretend that the user’s device has a fixed resolution of your choice. For example:", "completion": "final camera = CameraComponent.withFixedResolution(\n  world: myWorldComponent,\n  width: 800,\n  height: 600,\n);"}
{"prompt": "Show me how to implement CameraComponent with fixed resolution¶: This named constructor will let you pretend that the user’s device has a fixed resolution of your choice. For example: using Flutter Flame", "completion": "final camera = CameraComponent.withFixedResolution(\n  world: myWorldComponent,\n  width: 800,\n  height: 600,\n);"}
{"prompt": "Write Flutter Flame code to CameraComponent with fixed resolution¶: This named constructor will let you pretend that the user’s device has a fixed resolution of your choice. For example:", "completion": "final camera = CameraComponent.withFixedResolution(\n  world: myWorldComponent,\n  width: 800,\n  height: 600,\n);"}
{"prompt": "Create a Flutter Flame game component that PaintDecorator.blur¶: There are a certain number of decorators available in Flame, and it is simple to add one’s own if necessary. We are planning to add shader-based decorators once Flutter fully supports them on the web.", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/rendering.dart';\n\nclass DecoratorBlurGame extends FlameGame {\n@override\nFuture<void> onLoad() async {\nvar step = 0;\nadd(\nFlower(\nsize: 100,\nposition: canvasSize / 2,\nonTap: (flower) {\nfinal decorator = flower.decorator;\nstep++;\nif (step == 1) {\ndecorator.addLast(PaintDecorator.blur(3.0));\n} else if (step == 2) {\ndecorator.replaceLast(PaintDecorator.blur(5.0));\n} else if (step == 3) {\ndecorator.replaceLast(PaintDecorator.blur(0.0, 20.0));\n} else {\ndecorator.replaceLast(null);\nstep = 0;\n}\n},\n)..onTapUp(),\n);\n}\n}"}
{"prompt": "Show me how to implement PaintDecorator.blur¶: There are a certain number of decorators available in Flame, and it is simple to add one’s own if necessary. We are planning to add shader-based decorators once Flutter fully supports them on the web. using Flutter Flame", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/rendering.dart';\n\nclass DecoratorBlurGame extends FlameGame {\n@override\nFuture<void> onLoad() async {\nvar step = 0;\nadd(\nFlower(\nsize: 100,\nposition: canvasSize / 2,\nonTap: (flower) {\nfinal decorator = flower.decorator;\nstep++;\nif (step == 1) {\ndecorator.addLast(PaintDecorator.blur(3.0));\n} else if (step == 2) {\ndecorator.replaceLast(PaintDecorator.blur(5.0));\n} else if (step == 3) {\ndecorator.replaceLast(PaintDecorator.blur(0.0, 20.0));\n} else {\ndecorator.replaceLast(null);\nstep = 0;\n}\n},\n)..onTapUp(),\n);\n}\n}"}
{"prompt": "Write Flutter Flame code to PaintDecorator.blur¶: There are a certain number of decorators available in Flame, and it is simple to add one’s own if necessary. We are planning to add shader-based decorators once Flutter fully supports them on the web.", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/rendering.dart';\n\nclass DecoratorBlurGame extends FlameGame {\n@override\nFuture<void> onLoad() async {\nvar step = 0;\nadd(\nFlower(\nsize: 100,\nposition: canvasSize / 2,\nonTap: (flower) {\nfinal decorator = flower.decorator;\nstep++;\nif (step == 1) {\ndecorator.addLast(PaintDecorator.blur(3.0));\n} else if (step == 2) {\ndecorator.replaceLast(PaintDecorator.blur(5.0));\n} else if (step == 3) {\ndecorator.replaceLast(PaintDecorator.blur(0.0, 20.0));\n} else {\ndecorator.replaceLast(null);\nstep = 0;\n}\n},\n)..onTapUp(),\n);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that PaintDecorator.grayscale¶: blurred vision when the character is drunk.", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/rendering.dart';\n\nclass DecoratorGrayscaleGame extends FlameGame {\n@override\nFuture<void> onLoad() async {\nvar step = 0;\nadd(\nFlower(\nsize: 100,\nposition: canvasSize / 2,\nonTap: (flower) {\nfinal decorator = flower.decorator;\nstep++;\nif (step == 1) {\ndecorator.addLast(PaintDecorator.grayscale());\n} else if (step == 2) {\ndecorator.replaceLast(PaintDecorator.grayscale(opacity: 0.5));\n} else if (step == 3) {\ndecorator.replaceLast(PaintDecorator.grayscale(opacity: 0.2));\n} else if (step == 4) {\ndecorator.replaceLast(PaintDecorator.grayscale(opacity: 0.1));\n} else {\ndecorator.removeLast();\nstep = 0;\n}\n},\n)..onTapUp(),\n);\n}\n}"}
{"prompt": "Show me how to implement PaintDecorator.grayscale¶: blurred vision when the character is drunk. using Flutter Flame", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/rendering.dart';\n\nclass DecoratorGrayscaleGame extends FlameGame {\n@override\nFuture<void> onLoad() async {\nvar step = 0;\nadd(\nFlower(\nsize: 100,\nposition: canvasSize / 2,\nonTap: (flower) {\nfinal decorator = flower.decorator;\nstep++;\nif (step == 1) {\ndecorator.addLast(PaintDecorator.grayscale());\n} else if (step == 2) {\ndecorator.replaceLast(PaintDecorator.grayscale(opacity: 0.5));\n} else if (step == 3) {\ndecorator.replaceLast(PaintDecorator.grayscale(opacity: 0.2));\n} else if (step == 4) {\ndecorator.replaceLast(PaintDecorator.grayscale(opacity: 0.1));\n} else {\ndecorator.removeLast();\nstep = 0;\n}\n},\n)..onTapUp(),\n);\n}\n}"}
{"prompt": "Write Flutter Flame code to PaintDecorator.grayscale¶: blurred vision when the character is drunk.", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/rendering.dart';\n\nclass DecoratorGrayscaleGame extends FlameGame {\n@override\nFuture<void> onLoad() async {\nvar step = 0;\nadd(\nFlower(\nsize: 100,\nposition: canvasSize / 2,\nonTap: (flower) {\nfinal decorator = flower.decorator;\nstep++;\nif (step == 1) {\ndecorator.addLast(PaintDecorator.grayscale());\n} else if (step == 2) {\ndecorator.replaceLast(PaintDecorator.grayscale(opacity: 0.5));\n} else if (step == 3) {\ndecorator.replaceLast(PaintDecorator.grayscale(opacity: 0.2));\n} else if (step == 4) {\ndecorator.replaceLast(PaintDecorator.grayscale(opacity: 0.1));\n} else {\ndecorator.removeLast();\nstep = 0;\n}\n},\n)..onTapUp(),\n);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that PaintDecorator.tint¶: black-and-white photos.", "completion": "import 'dart:ui';\n\nimport 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/rendering.dart';\n\nclass DecoratorTintGame extends FlameGame {\n@override\nFuture<void> onLoad() async {\nvar step = 0;\nadd(\nFlower(\nsize: 100,\nposition: canvasSize / 2,\nonTap: (flower) {\nfinal decorator = flower.decorator;\nstep++;\nif (step == 1) {\ndecorator.addLast(PaintDecorator.tint(const Color(0x88FF0000)));\n} else if (step == 2) {\ndecorator.replaceLast(PaintDecorator.tint(const Color(0x8800FF00)));\n} else if (step == 3) {\ndecorator.replaceLast(PaintDecorator.tint(const Color(0x88000088)));\n} else if (step == 4) {\ndecorator.replaceLast(PaintDecorator.tint(const Color(0x66FFFFFF)));\n} else if (step == 5) {\ndecorator.replaceLast(PaintDecorator.tint(const Color(0xAA000000)));\n} else {\ndecorator.removeLast();\nstep = 0;\n}\n},\n)..onTapUp(),\n);\n}\n}"}
{"prompt": "Show me how to implement PaintDecorator.tint¶: black-and-white photos. using Flutter Flame", "completion": "import 'dart:ui';\n\nimport 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/rendering.dart';\n\nclass DecoratorTintGame extends FlameGame {\n@override\nFuture<void> onLoad() async {\nvar step = 0;\nadd(\nFlower(\nsize: 100,\nposition: canvasSize / 2,\nonTap: (flower) {\nfinal decorator = flower.decorator;\nstep++;\nif (step == 1) {\ndecorator.addLast(PaintDecorator.tint(const Color(0x88FF0000)));\n} else if (step == 2) {\ndecorator.replaceLast(PaintDecorator.tint(const Color(0x8800FF00)));\n} else if (step == 3) {\ndecorator.replaceLast(PaintDecorator.tint(const Color(0x88000088)));\n} else if (step == 4) {\ndecorator.replaceLast(PaintDecorator.tint(const Color(0x66FFFFFF)));\n} else if (step == 5) {\ndecorator.replaceLast(PaintDecorator.tint(const Color(0xAA000000)));\n} else {\ndecorator.removeLast();\nstep = 0;\n}\n},\n)..onTapUp(),\n);\n}\n}"}
{"prompt": "Write Flutter Flame code to PaintDecorator.tint¶: black-and-white photos.", "completion": "import 'dart:ui';\n\nimport 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/rendering.dart';\n\nclass DecoratorTintGame extends FlameGame {\n@override\nFuture<void> onLoad() async {\nvar step = 0;\nadd(\nFlower(\nsize: 100,\nposition: canvasSize / 2,\nonTap: (flower) {\nfinal decorator = flower.decorator;\nstep++;\nif (step == 1) {\ndecorator.addLast(PaintDecorator.tint(const Color(0x88FF0000)));\n} else if (step == 2) {\ndecorator.replaceLast(PaintDecorator.tint(const Color(0x8800FF00)));\n} else if (step == 3) {\ndecorator.replaceLast(PaintDecorator.tint(const Color(0x88000088)));\n} else if (step == 4) {\ndecorator.replaceLast(PaintDecorator.tint(const Color(0x66FFFFFF)));\n} else if (step == 5) {\ndecorator.replaceLast(PaintDecorator.tint(const Color(0xAA000000)));\n} else {\ndecorator.removeLast();\nstep = 0;\n}\n},\n)..onTapUp(),\n);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that Rotate3DDecorator¶: tint the scene deep blue during the night time;", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/rendering.dart';\n\nclass DecoratorRotate3DGame extends FlameGame {\n@override\nFuture<void> onLoad() async {\nvar step = 0;\nfinal decorator = Rotate3DDecorator()\n..center = Vector2.all(50)\n..perspective = 0.01;\nadd(\nFlower(\nsize: 100,\nposition: canvasSize / 2,\ndecorator: decorator,\nonTap: (flower) {\nstep++;\nif (step == 1) {\ndecorator.angleY = -0.8;\n} else if (step == 2) {\ndecorator.angleX = 1.0;\n} else if (step == 3) {\ndecorator.angleZ = 0.2;\n} else if (step == 4) {\ndecorator.angleX = 10;\n} else if (step == 5) {\ndecorator.angleY = 2;\n} else {\ndecorator\n..angleX = 0\n..angleY = 0\n..angleZ = 0;\nstep = 0;\n}\n},\n)..onTapUp(),\n);\n}\n}"}
{"prompt": "Show me how to implement Rotate3DDecorator¶: tint the scene deep blue during the night time; using Flutter Flame", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/rendering.dart';\n\nclass DecoratorRotate3DGame extends FlameGame {\n@override\nFuture<void> onLoad() async {\nvar step = 0;\nfinal decorator = Rotate3DDecorator()\n..center = Vector2.all(50)\n..perspective = 0.01;\nadd(\nFlower(\nsize: 100,\nposition: canvasSize / 2,\ndecorator: decorator,\nonTap: (flower) {\nstep++;\nif (step == 1) {\ndecorator.angleY = -0.8;\n} else if (step == 2) {\ndecorator.angleX = 1.0;\n} else if (step == 3) {\ndecorator.angleZ = 0.2;\n} else if (step == 4) {\ndecorator.angleX = 10;\n} else if (step == 5) {\ndecorator.angleY = 2;\n} else {\ndecorator\n..angleX = 0\n..angleY = 0\n..angleZ = 0;\nstep = 0;\n}\n},\n)..onTapUp(),\n);\n}\n}"}
{"prompt": "Write Flutter Flame code to Rotate3DDecorator¶: tint the scene deep blue during the night time;", "completion": "import 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/rendering.dart';\n\nclass DecoratorRotate3DGame extends FlameGame {\n@override\nFuture<void> onLoad() async {\nvar step = 0;\nfinal decorator = Rotate3DDecorator()\n..center = Vector2.all(50)\n..perspective = 0.01;\nadd(\nFlower(\nsize: 100,\nposition: canvasSize / 2,\ndecorator: decorator,\nonTap: (flower) {\nstep++;\nif (step == 1) {\ndecorator.angleY = -0.8;\n} else if (step == 2) {\ndecorator.angleX = 1.0;\n} else if (step == 3) {\ndecorator.angleZ = 0.2;\n} else if (step == 4) {\ndecorator.angleX = 10;\n} else if (step == 5) {\ndecorator.angleY = 2;\n} else {\ndecorator\n..angleX = 0\n..angleY = 0\n..angleZ = 0;\nstep = 0;\n}\n},\n)..onTapUp(),\n);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that Shadow3DDecorator¶: 3d falling particles such as snowflakes or leaves.", "completion": "import 'dart:ui';\n\nimport 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/rendering.dart';\n\nclass DecoratorShadowGame extends FlameGame {\n@override\nColor backgroundColor() => const Color(0xFFC7C7C7);\n\n@override\nFuture<void> onLoad() async {\nfinal decorator = Shadow3DDecorator(base: Vector2(0, 100));\nvar step = 0;\nadd(Grid());\nadd(\nFlower(\nsize: 100,\nposition: canvasSize / 2,\ndecorator: decorator,\nonTap: (flower) {\nstep++;\nif (step == 1) {\ndecorator.xShift = 200;\ndecorator.opacity = 0.5;\n} else if (step == 2) {\ndecorator.xShift = 400;\ndecorator.yScale = 3;\ndecorator.blur = 1;\n} else if (step == 3) {\ndecorator.angle = 1.7;\ndecorator.blur = 2;\n} else if (step == 4) {\ndecorator.ascent = 20;\ndecorator.angle = 1.7;\ndecorator.blur = 2;\nflower.y -= 20;\n} else {\ndecorator.ascent = 0;\ndecorator.xShift = 0;\ndecorator.yScale = 1;\ndecorator.angle = -1.4;\ndecorator.opacity = 0.8;\ndecorator.blur = 0;\nflower.y += 20;\nstep = 0;\n}\n},\n)..onTapUp(),\n);\n}\n}\n\nclass Grid extends Component {\nfinal paint = Paint()\n..color = const Color(0xffa9a9a9)\n..style = PaintingStyle.stroke\n..strokeWidth = 1;\n@override\nvoid render(Canvas canvas) {\nfor (var i = 0; i < 50; i++) {\ncanvas.drawLine(Offset(0, i * 25), Offset(500, i * 25), paint);\ncanvas.drawLine(Offset(i * 25, 0), Offset(i * 25, 500), paint);\n}\n}\n}"}
{"prompt": "Show me how to implement Shadow3DDecorator¶: 3d falling particles such as snowflakes or leaves. using Flutter Flame", "completion": "import 'dart:ui';\n\nimport 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/rendering.dart';\n\nclass DecoratorShadowGame extends FlameGame {\n@override\nColor backgroundColor() => const Color(0xFFC7C7C7);\n\n@override\nFuture<void> onLoad() async {\nfinal decorator = Shadow3DDecorator(base: Vector2(0, 100));\nvar step = 0;\nadd(Grid());\nadd(\nFlower(\nsize: 100,\nposition: canvasSize / 2,\ndecorator: decorator,\nonTap: (flower) {\nstep++;\nif (step == 1) {\ndecorator.xShift = 200;\ndecorator.opacity = 0.5;\n} else if (step == 2) {\ndecorator.xShift = 400;\ndecorator.yScale = 3;\ndecorator.blur = 1;\n} else if (step == 3) {\ndecorator.angle = 1.7;\ndecorator.blur = 2;\n} else if (step == 4) {\ndecorator.ascent = 20;\ndecorator.angle = 1.7;\ndecorator.blur = 2;\nflower.y -= 20;\n} else {\ndecorator.ascent = 0;\ndecorator.xShift = 0;\ndecorator.yScale = 1;\ndecorator.angle = -1.4;\ndecorator.opacity = 0.8;\ndecorator.blur = 0;\nflower.y += 20;\nstep = 0;\n}\n},\n)..onTapUp(),\n);\n}\n}\n\nclass Grid extends Component {\nfinal paint = Paint()\n..color = const Color(0xffa9a9a9)\n..style = PaintingStyle.stroke\n..strokeWidth = 1;\n@override\nvoid render(Canvas canvas) {\nfor (var i = 0; i < 50; i++) {\ncanvas.drawLine(Offset(0, i * 25), Offset(500, i * 25), paint);\ncanvas.drawLine(Offset(i * 25, 0), Offset(i * 25, 500), paint);\n}\n}\n}"}
{"prompt": "Write Flutter Flame code to Shadow3DDecorator¶: 3d falling particles such as snowflakes or leaves.", "completion": "import 'dart:ui';\n\nimport 'package:doc_flame_examples/flower.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/rendering.dart';\n\nclass DecoratorShadowGame extends FlameGame {\n@override\nColor backgroundColor() => const Color(0xFFC7C7C7);\n\n@override\nFuture<void> onLoad() async {\nfinal decorator = Shadow3DDecorator(base: Vector2(0, 100));\nvar step = 0;\nadd(Grid());\nadd(\nFlower(\nsize: 100,\nposition: canvasSize / 2,\ndecorator: decorator,\nonTap: (flower) {\nstep++;\nif (step == 1) {\ndecorator.xShift = 200;\ndecorator.opacity = 0.5;\n} else if (step == 2) {\ndecorator.xShift = 400;\ndecorator.yScale = 3;\ndecorator.blur = 1;\n} else if (step == 3) {\ndecorator.angle = 1.7;\ndecorator.blur = 2;\n} else if (step == 4) {\ndecorator.ascent = 20;\ndecorator.angle = 1.7;\ndecorator.blur = 2;\nflower.y -= 20;\n} else {\ndecorator.ascent = 0;\ndecorator.xShift = 0;\ndecorator.yScale = 1;\ndecorator.angle = -1.4;\ndecorator.opacity = 0.8;\ndecorator.blur = 0;\nflower.y += 20;\nstep = 0;\n}\n},\n)..onTapUp(),\n);\n}\n}\n\nclass Grid extends Component {\nfinal paint = Paint()\n..color = const Color(0xffa9a9a9)\n..style = PaintingStyle.stroke\n..strokeWidth = 1;\n@override\nvoid render(Canvas canvas) {\nfor (var i = 0; i < 50; i++) {\ncanvas.drawLine(Offset(0, i * 25), Offset(500, i * 25), paint);\ncanvas.drawLine(Offset(i * 25, 0), Offset(i * 25, 500), paint);\n}\n}\n}"}
{"prompt": "Create a Flutter Flame game component that Shadow3DDecorator¶: The shadow produced by this generator is quite flexible: you can control its angle, length, opacity, blur, etc. For a full description of what properties this decorator has and their meaning, see the class documentation.", "completion": "final decorator = Shadow3DDecorator(\n  base: Vector2(100, 150),\n  angle: -1.4,\n  xShift: 200,\n  yScale: 1.5,\n  opacity: 0.5,\n  blur: 1.5,\n);"}
{"prompt": "Show me how to implement Shadow3DDecorator¶: The shadow produced by this generator is quite flexible: you can control its angle, length, opacity, blur, etc. For a full description of what properties this decorator has and their meaning, see the class documentation. using Flutter Flame", "completion": "final decorator = Shadow3DDecorator(\n  base: Vector2(100, 150),\n  angle: -1.4,\n  xShift: 200,\n  yScale: 1.5,\n  opacity: 0.5,\n  blur: 1.5,\n);"}
{"prompt": "Write Flutter Flame code to Shadow3DDecorator¶: The shadow produced by this generator is quite flexible: you can control its angle, length, opacity, blur, etc. For a full description of what properties this decorator has and their meaning, see the class documentation.", "completion": "final decorator = Shadow3DDecorator(\n  base: Vector2(100, 150),\n  angle: -1.4,\n  xShift: 200,\n  yScale: 1.5,\n  opacity: 0.5,\n  blur: 1.5,\n);"}
{"prompt": "Create a Flutter Flame game component that flame_tiled¶: Create a TiledComponent and add it to the component tree as follows:", "completion": "final component = await TiledComponent.load(\n  'my_map.tmx',\n  Vector2.all(32),\n);\n\nadd(component);"}
{"prompt": "Show me how to implement flame_tiled¶: Create a TiledComponent and add it to the component tree as follows: using Flutter Flame", "completion": "final component = await TiledComponent.load(\n  'my_map.tmx',\n  Vector2.all(32),\n);\n\nadd(component);"}
{"prompt": "Write Flutter Flame code to flame_tiled¶: Create a TiledComponent and add it to the component tree as follows:", "completion": "final component = await TiledComponent.load(\n  'my_map.tmx',\n  Vector2.all(32),\n);\n\nadd(component);"}
{"prompt": "Create a Flutter Flame game component that TileStack¶: Note: This currently only supports position based effects.", "completion": "void onLoad() {\n  final stack = map.tileMap.tileStack(4, 0, named: {'floor_under'});\n  stack.add(\n    SequenceEffect(\n      [\n        MoveEffect.by(\n          Vector2(5, 0),\n          NoiseEffectController(duration: 1, frequency: 20),\n        ),\n        MoveEffect.by(Vector2.zero(), LinearEffectController(2)),\n      ],\n      repeatCount: 3,\n    )\n      ..onComplete = () => stack.removeFromParent(),\n  );\n  map.add(stack);\n}"}
{"prompt": "Show me how to implement TileStack¶: Note: This currently only supports position based effects. using Flutter Flame", "completion": "void onLoad() {\n  final stack = map.tileMap.tileStack(4, 0, named: {'floor_under'});\n  stack.add(\n    SequenceEffect(\n      [\n        MoveEffect.by(\n          Vector2(5, 0),\n          NoiseEffectController(duration: 1, frequency: 20),\n        ),\n        MoveEffect.by(Vector2.zero(), LinearEffectController(2)),\n      ],\n      repeatCount: 3,\n    )\n      ..onComplete = () => stack.removeFromParent(),\n  );\n  map.add(stack);\n}"}
{"prompt": "Write Flutter Flame code to TileStack¶: Note: This currently only supports position based effects.", "completion": "void onLoad() {\n  final stack = map.tileMap.tileStack(4, 0, named: {'floor_under'});\n  stack.add(\n    SequenceEffect(\n      [\n        MoveEffect.by(\n          Vector2(5, 0),\n          NoiseEffectController(duration: 1, frequency: 20),\n        ),\n        MoveEffect.by(Vector2.zero(), LinearEffectController(2)),\n      ],\n      repeatCount: 3,\n    )\n      ..onComplete = () => stack.removeFromParent(),\n  );\n  map.add(stack);\n}"}
{"prompt": "Create a Flutter Flame game component that TileAtlas¶: NOTE: This is not recommended as such huge sizes might not work with all hardware. Instead consider resizing the original tileset images so that when packed they fit with the limits.", "completion": "final component = await TiledComponent.load(\n  'my_map.tmx',\n  Vector2.all(32),\n  atlasMaxX: 9216,\n  atlasMaxY: 9216,\n);\n\nadd(component);"}
{"prompt": "Show me how to implement TileAtlas¶: NOTE: This is not recommended as such huge sizes might not work with all hardware. Instead consider resizing the original tileset images so that when packed they fit with the limits. using Flutter Flame", "completion": "final component = await TiledComponent.load(\n  'my_map.tmx',\n  Vector2.all(32),\n  atlasMaxX: 9216,\n  atlasMaxY: 9216,\n);\n\nadd(component);"}
{"prompt": "Write Flutter Flame code to TileAtlas¶: NOTE: This is not recommended as such huge sizes might not work with all hardware. Instead consider resizing the original tileset images so that when packed they fit with the limits.", "completion": "final component = await TiledComponent.load(\n  'my_map.tmx',\n  Vector2.all(32),\n  atlasMaxX: 9216,\n  atlasMaxY: 9216,\n);\n\nadd(component);"}
{"prompt": "Create a Flutter Flame game component that Flip¶: Note: A large texture in this context means one with multiple tilesets (or a huge tileset) where the sum of their dimensions are in the thousands.", "completion": "final component = await TiledComponent.load(\n  'my_map.tmx',\n  Vector2.all(32),\n  ignoreFlip: true,\n);"}
{"prompt": "Show me how to implement Flip¶: Note: A large texture in this context means one with multiple tilesets (or a huge tileset) where the sum of their dimensions are in the thousands. using Flutter Flame", "completion": "final component = await TiledComponent.load(\n  'my_map.tmx',\n  Vector2.all(32),\n  ignoreFlip: true,\n);"}
{"prompt": "Write Flutter Flame code to Flip¶: Note: A large texture in this context means one with multiple tilesets (or a huge tileset) where the sum of their dimensions are in the thousands.", "completion": "final component = await TiledComponent.load(\n  'my_map.tmx',\n  Vector2.all(32),\n  ignoreFlip: true,\n);"}
{"prompt": "Create a Flutter Flame game component that NineTileBoxWidget¶: Here you can find an example of how to use it (without using the NineTileBoxComponent):", "completion": "import 'package:flame/widgets';\n\nNineTileBoxWidget(\n    image: image, // dart:ui image instance\n    tileSize: 16, // The width/height of the tile on your grid image\n    destTileSize: 50, // The dimensions to be used when drawing the tile on the canvas\n    child: SomeWidget(), // Any Flutter widget\n)"}
{"prompt": "Show me how to implement NineTileBoxWidget¶: Here you can find an example of how to use it (without using the NineTileBoxComponent): using Flutter Flame", "completion": "import 'package:flame/widgets';\n\nNineTileBoxWidget(\n    image: image, // dart:ui image instance\n    tileSize: 16, // The width/height of the tile on your grid image\n    destTileSize: 50, // The dimensions to be used when drawing the tile on the canvas\n    child: SomeWidget(), // Any Flutter widget\n)"}
{"prompt": "Write Flutter Flame code to NineTileBoxWidget¶: Here you can find an example of how to use it (without using the NineTileBoxComponent):", "completion": "import 'package:flame/widgets';\n\nNineTileBoxWidget(\n    image: image, // dart:ui image instance\n    tileSize: 16, // The width/height of the tile on your grid image\n    destTileSize: 50, // The dimensions to be used when drawing the tile on the canvas\n    child: SomeWidget(), // Any Flutter widget\n)"}
{"prompt": "Create a Flutter Flame game component that 1. Preparation¶: Now it is time to get started, but first you need to go to the bare flame game tutorial and complete the necessary setup steps. When you come back, you should already have the main.dart file with the following content:", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/widgets.dart';\n\nvoid main() {\n  final game = FlameGame();\n  runApp(GameWidget(game: game));\n}"}
{"prompt": "Show me how to implement 1. Preparation¶: Now it is time to get started, but first you need to go to the bare flame game tutorial and complete the necessary setup steps. When you come back, you should already have the main.dart file with the following content: using Flutter Flame", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/widgets.dart';\n\nvoid main() {\n  final game = FlameGame();\n  runApp(GameWidget(game: game));\n}"}
{"prompt": "Write Flutter Flame code to 1. Preparation¶: Now it is time to get started, but first you need to go to the bare flame game tutorial and complete the necessary setup steps. When you come back, you should already have the main.dart file with the following content:", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/widgets.dart';\n\nvoid main() {\n  final game = FlameGame();\n  runApp(GameWidget(game: game));\n}"}
{"prompt": "Create a Flutter Flame game component that flame_splash_screen¶: flame_splash_screen is a very customizable splash screen package.", "completion": "FlameSplashScreen(\n  theme: FlameSplashTheme.dark,\n  onFinish: (BuildContext context) => Navigator.pushNamed(context, '/your-game-initial-screen')\n)"}
{"prompt": "Show me how to implement flame_splash_screen¶: flame_splash_screen is a very customizable splash screen package. using Flutter Flame", "completion": "FlameSplashScreen(\n  theme: FlameSplashTheme.dark,\n  onFinish: (BuildContext context) => Navigator.pushNamed(context, '/your-game-initial-screen')\n)"}
{"prompt": "Write Flutter Flame code to flame_splash_screen¶: flame_splash_screen is a very customizable splash screen package.", "completion": "FlameSplashScreen(\n  theme: FlameSplashTheme.dark,\n  onFinish: (BuildContext context) => Navigator.pushNamed(context, '/your-game-initial-screen')\n)"}
{"prompt": "Create a Flutter Flame game component that FlameNetworkAssets¶: To create a specific asset handler class, you just need to extend the FlameNetworkAssets class and define the decodeAsset and encodeAsset arguments:", "completion": "class FlameNetworkCustomAsset extends FlameNetworkAssets<CustomAsset> {\n  FlameNetworkImages({\n    super.get,\n    super.getAppDirectory,\n    super.cacheInMemory,\n    super.cacheInStorage,\n  }) : super(\n          decodeAsset: (bytes) => CustomAsset.decode(bytes),\n          encodeAsset: (CustomAsset asset) => asset.encode(),\n        );\n}"}
{"prompt": "Show me how to implement FlameNetworkAssets¶: To create a specific asset handler class, you just need to extend the FlameNetworkAssets class and define the decodeAsset and encodeAsset arguments: using Flutter Flame", "completion": "class FlameNetworkCustomAsset extends FlameNetworkAssets<CustomAsset> {\n  FlameNetworkImages({\n    super.get,\n    super.getAppDirectory,\n    super.cacheInMemory,\n    super.cacheInStorage,\n  }) : super(\n          decodeAsset: (bytes) => CustomAsset.decode(bytes),\n          encodeAsset: (CustomAsset asset) => asset.encode(),\n        );\n}"}
{"prompt": "Write Flutter Flame code to FlameNetworkAssets¶: To create a specific asset handler class, you just need to extend the FlameNetworkAssets class and define the decodeAsset and encodeAsset arguments:", "completion": "class FlameNetworkCustomAsset extends FlameNetworkAssets<CustomAsset> {\n  FlameNetworkImages({\n    super.get,\n    super.getAppDirectory,\n    super.cacheInMemory,\n    super.cacheInStorage,\n  }) : super(\n          decodeAsset: (bytes) => CustomAsset.decode(bytes),\n          encodeAsset: (CustomAsset asset) => asset.encode(),\n        );\n}"}
{"prompt": "Create a Flutter Flame game component that Looping Background Music¶: To play a looping background music track, run:", "completion": "import 'package:flame_audio/flame_audio.dart';\n\nFlameAudio.bgm.play('adventure-track.mp3');"}
{"prompt": "Show me how to implement Looping Background Music¶: To play a looping background music track, run: using Flutter Flame", "completion": "import 'package:flame_audio/flame_audio.dart';\n\nFlameAudio.bgm.play('adventure-track.mp3');"}
{"prompt": "Write Flutter Flame code to Looping Background Music¶: To play a looping background music track, run:", "completion": "import 'package:flame_audio/flame_audio.dart';\n\nFlameAudio.bgm.play('adventure-track.mp3');"}
{"prompt": "Create a Flutter Flame game component that Audio¶: Then you have the following methods at your disposal:", "completion": "import 'package:flame_audio/flame_audio.dart';\n\n// For shorter reused audio clips, like sound effects\nFlameAudio.play('explosion.mp3');\n\n// For looping an audio file\nFlameAudio.loop('music.mp3');\n\n// For playing a longer audio file\nFlameAudio.playLongAudio('music.mp3');\n\n// For looping a longer audio file\nFlameAudio.loopLongAudio('music.mp3');\n\n// For background music that should be paused/played when the pausing/resuming\n// the game\nFlameAudio.bgm.play('music.mp3');"}
{"prompt": "Show me how to implement Audio¶: Then you have the following methods at your disposal: using Flutter Flame", "completion": "import 'package:flame_audio/flame_audio.dart';\n\n// For shorter reused audio clips, like sound effects\nFlameAudio.play('explosion.mp3');\n\n// For looping an audio file\nFlameAudio.loop('music.mp3');\n\n// For playing a longer audio file\nFlameAudio.playLongAudio('music.mp3');\n\n// For looping a longer audio file\nFlameAudio.loopLongAudio('music.mp3');\n\n// For background music that should be paused/played when the pausing/resuming\n// the game\nFlameAudio.bgm.play('music.mp3');"}
{"prompt": "Write Flutter Flame code to Audio¶: Then you have the following methods at your disposal:", "completion": "import 'package:flame_audio/flame_audio.dart';\n\n// For shorter reused audio clips, like sound effects\nFlameAudio.play('explosion.mp3');\n\n// For looping an audio file\nFlameAudio.loop('music.mp3');\n\n// For playing a longer audio file\nFlameAudio.playLongAudio('music.mp3');\n\n// For looping a longer audio file\nFlameAudio.loopLongAudio('music.mp3');\n\n// For background music that should be paused/played when the pausing/resuming\n// the game\nFlameAudio.bgm.play('music.mp3');"}
{"prompt": "Create a Flutter Flame game component that Enemies and Bullets collision¶: First we need to let our FlameGame know that we want collisions between components to be checked. In order to do so, simply add the HasCollisionDetection mixin to the declaration of the game class:", "completion": "class SpaceShooterGame extends FlameGame\n    with PanDetector, HasCollisionDetection {\n    // ...\n}"}
{"prompt": "Show me how to implement Enemies and Bullets collision¶: First we need to let our FlameGame know that we want collisions between components to be checked. In order to do so, simply add the HasCollisionDetection mixin to the declaration of the game class: using Flutter Flame", "completion": "class SpaceShooterGame extends FlameGame\n    with PanDetector, HasCollisionDetection {\n    // ...\n}"}
{"prompt": "Write Flutter Flame code to Enemies and Bullets collision¶: First we need to let our FlameGame know that we want collisions between components to be checked. In order to do so, simply add the HasCollisionDetection mixin to the declaration of the game class:", "completion": "class SpaceShooterGame extends FlameGame\n    with PanDetector, HasCollisionDetection {\n    // ...\n}"}
{"prompt": "Create a Flutter Flame game component that Enemies and Bullets collision¶: So let’s make a few changes to the Enemy class:", "completion": "class Enemy extends SpriteAnimationComponent\n    with HasGameReference<SpaceShooterGame>, CollisionCallbacks {\n\n  // Other methods omitted\n\n  @override\n  void onCollisionStart(\n    Set<Vector2> intersectionPoints,\n    PositionComponent other,\n  ) {\n    super.onCollisionStart(intersectionPoints, other);\n\n    if (other is Bullet) {\n      removeFromParent();\n      other.removeFromParent();\n    }\n  }\n}"}
{"prompt": "Show me how to implement Enemies and Bullets collision¶: So let’s make a few changes to the Enemy class: using Flutter Flame", "completion": "class Enemy extends SpriteAnimationComponent\n    with HasGameReference<SpaceShooterGame>, CollisionCallbacks {\n\n  // Other methods omitted\n\n  @override\n  void onCollisionStart(\n    Set<Vector2> intersectionPoints,\n    PositionComponent other,\n  ) {\n    super.onCollisionStart(intersectionPoints, other);\n\n    if (other is Bullet) {\n      removeFromParent();\n      other.removeFromParent();\n    }\n  }\n}"}
{"prompt": "Write Flutter Flame code to Enemies and Bullets collision¶: So let’s make a few changes to the Enemy class:", "completion": "class Enemy extends SpriteAnimationComponent\n    with HasGameReference<SpaceShooterGame>, CollisionCallbacks {\n\n  // Other methods omitted\n\n  @override\n  void onCollisionStart(\n    Set<Vector2> intersectionPoints,\n    PositionComponent other,\n  ) {\n    super.onCollisionStart(intersectionPoints, other);\n\n    if (other is Bullet) {\n      removeFromParent();\n      other.removeFromParent();\n    }\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Enemies and Bullets collision¶: First, let’s create the explosion class:", "completion": "class Explosion extends SpriteAnimationComponent\n    with HasGameReference<SpaceShooterGame> {\n  Explosion({\n    super.position,\n  }) : super(\n          size: Vector2.all(150),\n          anchor: Anchor.center,\n          removeOnFinish: true,\n        );\n\n\n  @override\n  Future<void> onLoad() async {\n    await super.onLoad();\n\n    animation = await game.loadSpriteAnimation(\n      'explosion.png',\n      SpriteAnimationData.sequenced(\n        amount: 6,\n        stepTime: .1,\n        textureSize: Vector2.all(32),\n        loop: false,\n      ),\n    );\n  }\n}"}
{"prompt": "Show me how to implement Enemies and Bullets collision¶: First, let’s create the explosion class: using Flutter Flame", "completion": "class Explosion extends SpriteAnimationComponent\n    with HasGameReference<SpaceShooterGame> {\n  Explosion({\n    super.position,\n  }) : super(\n          size: Vector2.all(150),\n          anchor: Anchor.center,\n          removeOnFinish: true,\n        );\n\n\n  @override\n  Future<void> onLoad() async {\n    await super.onLoad();\n\n    animation = await game.loadSpriteAnimation(\n      'explosion.png',\n      SpriteAnimationData.sequenced(\n        amount: 6,\n        stepTime: .1,\n        textureSize: Vector2.all(32),\n        loop: false,\n      ),\n    );\n  }\n}"}
{"prompt": "Write Flutter Flame code to Enemies and Bullets collision¶: First, let’s create the explosion class:", "completion": "class Explosion extends SpriteAnimationComponent\n    with HasGameReference<SpaceShooterGame> {\n  Explosion({\n    super.position,\n  }) : super(\n          size: Vector2.all(150),\n          anchor: Anchor.center,\n          removeOnFinish: true,\n        );\n\n\n  @override\n  Future<void> onLoad() async {\n    await super.onLoad();\n\n    animation = await game.loadSpriteAnimation(\n      'explosion.png',\n      SpriteAnimationData.sequenced(\n        amount: 6,\n        stepTime: .1,\n        textureSize: Vector2.all(32),\n        loop: false,\n      ),\n    );\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Enemies and Bullets collision¶: And finally, we make a small change in the onCollisionStart() method in the Enemy class in order to add the explosion to the game:", "completion": "@override\n  void onCollisionStart(\n    Set<Vector2> intersectionPoints,\n    PositionComponent other,\n  ) {\n    super.onCollisionStart(intersectionPoints, other);\n\n    if (other is Bullet) {\n      removeFromParent();\n      other.removeFromParent();\n      game.add(Explosion(position: position));\n    }\n  }"}
{"prompt": "Show me how to implement Enemies and Bullets collision¶: And finally, we make a small change in the onCollisionStart() method in the Enemy class in order to add the explosion to the game: using Flutter Flame", "completion": "@override\n  void onCollisionStart(\n    Set<Vector2> intersectionPoints,\n    PositionComponent other,\n  ) {\n    super.onCollisionStart(intersectionPoints, other);\n\n    if (other is Bullet) {\n      removeFromParent();\n      other.removeFromParent();\n      game.add(Explosion(position: position));\n    }\n  }"}
{"prompt": "Write Flutter Flame code to Enemies and Bullets collision¶: And finally, we make a small change in the onCollisionStart() method in the Enemy class in order to add the explosion to the game:", "completion": "@override\n  void onCollisionStart(\n    Set<Vector2> intersectionPoints,\n    PositionComponent other,\n  ) {\n    super.onCollisionStart(intersectionPoints, other);\n\n    if (other is Bullet) {\n      removeFromParent();\n      other.removeFromParent();\n      game.add(Explosion(position: position));\n    }\n  }"}
{"prompt": "Create a Flutter Flame game component that Enemies and Bullets collision¶: Good hunting pilot, and happy coding!", "completion": "import 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/experimental.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/input.dart';\nimport 'package:flame/parallax.dart';\nimport 'package:flutter/material.dart';\n\nvoid main() {\nrunApp(GameWidget(game: SpaceShooterGame()));\n}\n\nclass SpaceShooterGame extends FlameGame\nwith PanDetector, HasCollisionDetection {\nlate Player player;\n\n@override\nFuture<void> onLoad() async {\nfinal parallax = await loadParallaxComponent(\n[\nParallaxImageData('stars_0.png'),\nParallaxImageData('stars_1.png'),\nParallaxImageData('stars_2.png'),\n],\nbaseVelocity: Vector2(0, -5),\nrepeat: ImageRepeat.repeat,\nvelocityMultiplierDelta: Vector2(0, 5),\n);\nadd(parallax);\n\nplayer = Player();\nadd(player);\n\nadd(\nSpawnComponent(\nfactory: (index) {\nreturn Enemy();\n},\nperiod: 1,\narea: Rectangle.fromLTWH(0, 0, size.x, -Enemy.enemySize),\n),\n);\n}\n\n@override\nvoid onPanUpdate(DragUpdateInfo info) {\nplayer.move(info.delta.global);\n}\n\n@override\nvoid onPanStart(DragStartInfo info) {\nplayer.startShooting();\n}\n\n@override\nvoid onPanEnd(DragEndInfo info) {\nplayer.stopShooting();\n}\n}\n\nclass Player extends SpriteAnimationComponent\nwith HasGameReference<SpaceShooterGame> {\nPlayer()\n: super(\nsize: Vector2(100, 150),\nanchor: Anchor.center,\n);\n\nlate final SpawnComponent _bulletSpawner;\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nanimation = await game.loadSpriteAnimation(\n'player.png',\nSpriteAnimationData.sequenced(\namount: 4,\nstepTime: 0.2,\ntextureSize: Vector2(32, 48),\n),\n);\n\nposition = game.size / 2;\n\n_bulletSpawner = SpawnComponent(\nperiod: 0.2,\nselfPositioning: true,\nfactory: (index) {\nreturn Bullet(\nposition: position +\nVector2(\n0,\n-height / 2,\n),\n);\n},\nautoStart: false,\n);\n\ngame.add(_bulletSpawner);\n}\n\nvoid move(Vector2 delta) {\nposition.add(delta);\n}\n\nvoid startShooting() {\n_bulletSpawner.timer.start();\n}\n\nvoid stopShooting() {\n_bulletSpawner.timer.stop();\n}\n}\n\nclass Bullet extends SpriteAnimationComponent\nwith HasGameReference<SpaceShooterGame> {\nBullet({\nsuper.position,\n}) : super(\nsize: Vector2(25, 50),\nanchor: Anchor.center,\n);\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nanimation = await game.loadSpriteAnimation(\n'bullet.png',\nSpriteAnimationData.sequenced(\namount: 4,\nstepTime: 0.2,\ntextureSize: Vector2(8, 16),\n),\n);\n\nadd(\nRectangleHitbox(\ncollisionType: CollisionType.passive,\n),\n);\n}\n\n@override\nvoid update(double dt) {\nsuper.update(dt);\n\nposition.y += dt * -500;\n\nif (position.y < -height) {\nremoveFromParent();\n}\n}\n}\n\nclass Enemy extends SpriteAnimationComponent\nwith HasGameReference<SpaceShooterGame>, CollisionCallbacks {\nEnemy({\nsuper.position,\n}) : super(\nsize: Vector2.all(enemySize),\nanchor: Anchor.center,\n);\n\nstatic const enemySize = 50.0;\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nanimation = await game.loadSpriteAnimation(\n'enemy.png',\nSpriteAnimationData.sequenced(\namount: 4,\nstepTime: 0.2,\ntextureSize: Vector2.all(16),\n),\n);\n\nadd(RectangleHitbox());\n}\n\n@override\nvoid update(double dt) {\nsuper.update(dt);\n\nposition.y += dt * 250;\n\nif (position.y > game.size.y) {\nremoveFromParent();\n}\n}\n\n@override\nvoid onCollisionStart(\nSet<Vector2> intersectionPoints,\nPositionComponent other,\n) {\nsuper.onCollisionStart(intersectionPoints, other);\n\nif (other is Bullet) {\nremoveFromParent();\nother.removeFromParent();\ngame.add(Explosion(position: position));\n}\n}\n}\n\nclass Explosion extends SpriteAnimationComponent\nwith HasGameReference<SpaceShooterGame> {\nExplosion({\nsuper.position,\n}) : super(\nsize: Vector2.all(150),\nanchor: Anchor.center,\nremoveOnFinish: true,\n);\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nanimation = await game.loadSpriteAnimation(\n'explosion.png',\nSpriteAnimationData.sequenced(\namount: 6,\nstepTime: 0.1,\ntextureSize: Vector2.all(32),\nloop: false,\n),\n);\n}\n}"}
{"prompt": "Show me how to implement Enemies and Bullets collision¶: Good hunting pilot, and happy coding! using Flutter Flame", "completion": "import 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/experimental.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/input.dart';\nimport 'package:flame/parallax.dart';\nimport 'package:flutter/material.dart';\n\nvoid main() {\nrunApp(GameWidget(game: SpaceShooterGame()));\n}\n\nclass SpaceShooterGame extends FlameGame\nwith PanDetector, HasCollisionDetection {\nlate Player player;\n\n@override\nFuture<void> onLoad() async {\nfinal parallax = await loadParallaxComponent(\n[\nParallaxImageData('stars_0.png'),\nParallaxImageData('stars_1.png'),\nParallaxImageData('stars_2.png'),\n],\nbaseVelocity: Vector2(0, -5),\nrepeat: ImageRepeat.repeat,\nvelocityMultiplierDelta: Vector2(0, 5),\n);\nadd(parallax);\n\nplayer = Player();\nadd(player);\n\nadd(\nSpawnComponent(\nfactory: (index) {\nreturn Enemy();\n},\nperiod: 1,\narea: Rectangle.fromLTWH(0, 0, size.x, -Enemy.enemySize),\n),\n);\n}\n\n@override\nvoid onPanUpdate(DragUpdateInfo info) {\nplayer.move(info.delta.global);\n}\n\n@override\nvoid onPanStart(DragStartInfo info) {\nplayer.startShooting();\n}\n\n@override\nvoid onPanEnd(DragEndInfo info) {\nplayer.stopShooting();\n}\n}\n\nclass Player extends SpriteAnimationComponent\nwith HasGameReference<SpaceShooterGame> {\nPlayer()\n: super(\nsize: Vector2(100, 150),\nanchor: Anchor.center,\n);\n\nlate final SpawnComponent _bulletSpawner;\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nanimation = await game.loadSpriteAnimation(\n'player.png',\nSpriteAnimationData.sequenced(\namount: 4,\nstepTime: 0.2,\ntextureSize: Vector2(32, 48),\n),\n);\n\nposition = game.size / 2;\n\n_bulletSpawner = SpawnComponent(\nperiod: 0.2,\nselfPositioning: true,\nfactory: (index) {\nreturn Bullet(\nposition: position +\nVector2(\n0,\n-height / 2,\n),\n);\n},\nautoStart: false,\n);\n\ngame.add(_bulletSpawner);\n}\n\nvoid move(Vector2 delta) {\nposition.add(delta);\n}\n\nvoid startShooting() {\n_bulletSpawner.timer.start();\n}\n\nvoid stopShooting() {\n_bulletSpawner.timer.stop();\n}\n}\n\nclass Bullet extends SpriteAnimationComponent\nwith HasGameReference<SpaceShooterGame> {\nBullet({\nsuper.position,\n}) : super(\nsize: Vector2(25, 50),\nanchor: Anchor.center,\n);\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nanimation = await game.loadSpriteAnimation(\n'bullet.png',\nSpriteAnimationData.sequenced(\namount: 4,\nstepTime: 0.2,\ntextureSize: Vector2(8, 16),\n),\n);\n\nadd(\nRectangleHitbox(\ncollisionType: CollisionType.passive,\n),\n);\n}\n\n@override\nvoid update(double dt) {\nsuper.update(dt);\n\nposition.y += dt * -500;\n\nif (position.y < -height) {\nremoveFromParent();\n}\n}\n}\n\nclass Enemy extends SpriteAnimationComponent\nwith HasGameReference<SpaceShooterGame>, CollisionCallbacks {\nEnemy({\nsuper.position,\n}) : super(\nsize: Vector2.all(enemySize),\nanchor: Anchor.center,\n);\n\nstatic const enemySize = 50.0;\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nanimation = await game.loadSpriteAnimation(\n'enemy.png',\nSpriteAnimationData.sequenced(\namount: 4,\nstepTime: 0.2,\ntextureSize: Vector2.all(16),\n),\n);\n\nadd(RectangleHitbox());\n}\n\n@override\nvoid update(double dt) {\nsuper.update(dt);\n\nposition.y += dt * 250;\n\nif (position.y > game.size.y) {\nremoveFromParent();\n}\n}\n\n@override\nvoid onCollisionStart(\nSet<Vector2> intersectionPoints,\nPositionComponent other,\n) {\nsuper.onCollisionStart(intersectionPoints, other);\n\nif (other is Bullet) {\nremoveFromParent();\nother.removeFromParent();\ngame.add(Explosion(position: position));\n}\n}\n}\n\nclass Explosion extends SpriteAnimationComponent\nwith HasGameReference<SpaceShooterGame> {\nExplosion({\nsuper.position,\n}) : super(\nsize: Vector2.all(150),\nanchor: Anchor.center,\nremoveOnFinish: true,\n);\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nanimation = await game.loadSpriteAnimation(\n'explosion.png',\nSpriteAnimationData.sequenced(\namount: 6,\nstepTime: 0.1,\ntextureSize: Vector2.all(32),\nloop: false,\n),\n);\n}\n}"}
{"prompt": "Write Flutter Flame code to Enemies and Bullets collision¶: Good hunting pilot, and happy coding!", "completion": "import 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/experimental.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/input.dart';\nimport 'package:flame/parallax.dart';\nimport 'package:flutter/material.dart';\n\nvoid main() {\nrunApp(GameWidget(game: SpaceShooterGame()));\n}\n\nclass SpaceShooterGame extends FlameGame\nwith PanDetector, HasCollisionDetection {\nlate Player player;\n\n@override\nFuture<void> onLoad() async {\nfinal parallax = await loadParallaxComponent(\n[\nParallaxImageData('stars_0.png'),\nParallaxImageData('stars_1.png'),\nParallaxImageData('stars_2.png'),\n],\nbaseVelocity: Vector2(0, -5),\nrepeat: ImageRepeat.repeat,\nvelocityMultiplierDelta: Vector2(0, 5),\n);\nadd(parallax);\n\nplayer = Player();\nadd(player);\n\nadd(\nSpawnComponent(\nfactory: (index) {\nreturn Enemy();\n},\nperiod: 1,\narea: Rectangle.fromLTWH(0, 0, size.x, -Enemy.enemySize),\n),\n);\n}\n\n@override\nvoid onPanUpdate(DragUpdateInfo info) {\nplayer.move(info.delta.global);\n}\n\n@override\nvoid onPanStart(DragStartInfo info) {\nplayer.startShooting();\n}\n\n@override\nvoid onPanEnd(DragEndInfo info) {\nplayer.stopShooting();\n}\n}\n\nclass Player extends SpriteAnimationComponent\nwith HasGameReference<SpaceShooterGame> {\nPlayer()\n: super(\nsize: Vector2(100, 150),\nanchor: Anchor.center,\n);\n\nlate final SpawnComponent _bulletSpawner;\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nanimation = await game.loadSpriteAnimation(\n'player.png',\nSpriteAnimationData.sequenced(\namount: 4,\nstepTime: 0.2,\ntextureSize: Vector2(32, 48),\n),\n);\n\nposition = game.size / 2;\n\n_bulletSpawner = SpawnComponent(\nperiod: 0.2,\nselfPositioning: true,\nfactory: (index) {\nreturn Bullet(\nposition: position +\nVector2(\n0,\n-height / 2,\n),\n);\n},\nautoStart: false,\n);\n\ngame.add(_bulletSpawner);\n}\n\nvoid move(Vector2 delta) {\nposition.add(delta);\n}\n\nvoid startShooting() {\n_bulletSpawner.timer.start();\n}\n\nvoid stopShooting() {\n_bulletSpawner.timer.stop();\n}\n}\n\nclass Bullet extends SpriteAnimationComponent\nwith HasGameReference<SpaceShooterGame> {\nBullet({\nsuper.position,\n}) : super(\nsize: Vector2(25, 50),\nanchor: Anchor.center,\n);\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nanimation = await game.loadSpriteAnimation(\n'bullet.png',\nSpriteAnimationData.sequenced(\namount: 4,\nstepTime: 0.2,\ntextureSize: Vector2(8, 16),\n),\n);\n\nadd(\nRectangleHitbox(\ncollisionType: CollisionType.passive,\n),\n);\n}\n\n@override\nvoid update(double dt) {\nsuper.update(dt);\n\nposition.y += dt * -500;\n\nif (position.y < -height) {\nremoveFromParent();\n}\n}\n}\n\nclass Enemy extends SpriteAnimationComponent\nwith HasGameReference<SpaceShooterGame>, CollisionCallbacks {\nEnemy({\nsuper.position,\n}) : super(\nsize: Vector2.all(enemySize),\nanchor: Anchor.center,\n);\n\nstatic const enemySize = 50.0;\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nanimation = await game.loadSpriteAnimation(\n'enemy.png',\nSpriteAnimationData.sequenced(\namount: 4,\nstepTime: 0.2,\ntextureSize: Vector2.all(16),\n),\n);\n\nadd(RectangleHitbox());\n}\n\n@override\nvoid update(double dt) {\nsuper.update(dt);\n\nposition.y += dt * 250;\n\nif (position.y > game.size.y) {\nremoveFromParent();\n}\n}\n\n@override\nvoid onCollisionStart(\nSet<Vector2> intersectionPoints,\nPositionComponent other,\n) {\nsuper.onCollisionStart(intersectionPoints, other);\n\nif (other is Bullet) {\nremoveFromParent();\nother.removeFromParent();\ngame.add(Explosion(position: position));\n}\n}\n}\n\nclass Explosion extends SpriteAnimationComponent\nwith HasGameReference<SpaceShooterGame> {\nExplosion({\nsuper.position,\n}) : super(\nsize: Vector2.all(150),\nanchor: Anchor.center,\nremoveOnFinish: true,\n);\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nanimation = await game.loadSpriteAnimation(\n'explosion.png',\nSpriteAnimationData.sequenced(\namount: 6,\nstepTime: 0.1,\ntextureSize: Vector2.all(32),\nloop: false,\n),\n);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that Rank¶: The Rank class is very similar to Suit. The main difference is that Rank contains two sprites instead of one, separately for ranks of “red” and “black” colors. The full code for the Rank class is as follows:", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/flame.dart';\nimport 'package:flutter/foundation.dart';\n\n@immutable\nclass Rank {\n  factory Rank.fromInt(int value) {\n    assert(value >= 1 && value <= 13);\n    return _singletons[value - 1];\n  }\n\n  Rank._(\n    this.value,\n    this.label,\n    double x1,\n    double y1,\n    double x2,\n    double y2,\n    double w,\n    double h,\n  )   : redSprite = klondikeSprite(x1, y1, w, h),\n        blackSprite = klondikeSprite(x2, y2, w, h);\n\n  final int value;\n  final String label;\n  final Sprite redSprite;\n  final Sprite blackSprite;\n\n  static final List<Rank> _singletons = [\n    Rank._(1, 'A', 335, 164, 789, 161, 120, 129),\n    Rank._(2, '2', 20, 19, 15, 322, 83, 125),\n    Rank._(3, '3', 122, 19, 117, 322, 80, 127),\n    Rank._(4, '4', 213, 12, 208, 315, 93, 132),\n    Rank._(5, '5', 314, 21, 309, 324, 85, 125),\n    Rank._(6, '6', 419, 17, 414, 320, 84, 129),\n    Rank._(7, '7', 509, 21, 505, 324, 92, 128),\n    Rank._(8, '8', 612, 19, 607, 322, 78, 127),\n    Rank._(9, '9', 709, 19, 704, 322, 84, 130),\n    Rank._(10, '10', 810, 20, 805, 322, 137, 127),\n    Rank._(11, 'J', 15, 170, 469, 167, 56, 126),\n    Rank._(12, 'Q', 92, 168, 547, 165, 132, 128),\n    Rank._(13, 'K', 243, 170, 696, 167, 92, 123),\n  ];\n}"}
{"prompt": "Show me how to implement Rank¶: The Rank class is very similar to Suit. The main difference is that Rank contains two sprites instead of one, separately for ranks of “red” and “black” colors. The full code for the Rank class is as follows: using Flutter Flame", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/flame.dart';\nimport 'package:flutter/foundation.dart';\n\n@immutable\nclass Rank {\n  factory Rank.fromInt(int value) {\n    assert(value >= 1 && value <= 13);\n    return _singletons[value - 1];\n  }\n\n  Rank._(\n    this.value,\n    this.label,\n    double x1,\n    double y1,\n    double x2,\n    double y2,\n    double w,\n    double h,\n  )   : redSprite = klondikeSprite(x1, y1, w, h),\n        blackSprite = klondikeSprite(x2, y2, w, h);\n\n  final int value;\n  final String label;\n  final Sprite redSprite;\n  final Sprite blackSprite;\n\n  static final List<Rank> _singletons = [\n    Rank._(1, 'A', 335, 164, 789, 161, 120, 129),\n    Rank._(2, '2', 20, 19, 15, 322, 83, 125),\n    Rank._(3, '3', 122, 19, 117, 322, 80, 127),\n    Rank._(4, '4', 213, 12, 208, 315, 93, 132),\n    Rank._(5, '5', 314, 21, 309, 324, 85, 125),\n    Rank._(6, '6', 419, 17, 414, 320, 84, 129),\n    Rank._(7, '7', 509, 21, 505, 324, 92, 128),\n    Rank._(8, '8', 612, 19, 607, 322, 78, 127),\n    Rank._(9, '9', 709, 19, 704, 322, 84, 130),\n    Rank._(10, '10', 810, 20, 805, 322, 137, 127),\n    Rank._(11, 'J', 15, 170, 469, 167, 56, 126),\n    Rank._(12, 'Q', 92, 168, 547, 165, 132, 128),\n    Rank._(13, 'K', 243, 170, 696, 167, 92, 123),\n  ];\n}"}
{"prompt": "Write Flutter Flame code to Rank¶: The Rank class is very similar to Suit. The main difference is that Rank contains two sprites instead of one, separately for ranks of “red” and “black” colors. The full code for the Rank class is as follows:", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/flame.dart';\nimport 'package:flutter/foundation.dart';\n\n@immutable\nclass Rank {\n  factory Rank.fromInt(int value) {\n    assert(value >= 1 && value <= 13);\n    return _singletons[value - 1];\n  }\n\n  Rank._(\n    this.value,\n    this.label,\n    double x1,\n    double y1,\n    double x2,\n    double y2,\n    double w,\n    double h,\n  )   : redSprite = klondikeSprite(x1, y1, w, h),\n        blackSprite = klondikeSprite(x2, y2, w, h);\n\n  final int value;\n  final String label;\n  final Sprite redSprite;\n  final Sprite blackSprite;\n\n  static final List<Rank> _singletons = [\n    Rank._(1, 'A', 335, 164, 789, 161, 120, 129),\n    Rank._(2, '2', 20, 19, 15, 322, 83, 125),\n    Rank._(3, '3', 122, 19, 117, 322, 80, 127),\n    Rank._(4, '4', 213, 12, 208, 315, 93, 132),\n    Rank._(5, '5', 314, 21, 309, 324, 85, 125),\n    Rank._(6, '6', 419, 17, 414, 320, 84, 129),\n    Rank._(7, '7', 509, 21, 505, 324, 92, 128),\n    Rank._(8, '8', 612, 19, 607, 322, 78, 127),\n    Rank._(9, '9', 709, 19, 704, 322, 84, 130),\n    Rank._(10, '10', 810, 20, 805, 322, 137, 127),\n    Rank._(11, 'J', 15, 170, 469, 167, 56, 126),\n    Rank._(12, 'Q', 92, 168, 547, 165, 132, 128),\n    Rank._(13, 'K', 243, 170, 696, 167, 92, 123),\n  ];\n}"}
{"prompt": "Create a Flutter Flame game component that Card component¶: The constructor of the class will take integer rank and suit, and make the card initially facing down. Also, we initialize the size of the component to be equal to the cardSize constant defined in the KlondikeGame class:", "completion": "Card(int intRank, int intSuit)\n      : rank = Rank.fromInt(intRank),\n        suit = Suit.fromInt(intSuit),\n        _faceUp = false,\n        super(size: KlondikeGame.cardSize);\n\n  final Rank rank;\n  final Suit suit;\n  bool _faceUp;"}
{"prompt": "Show me how to implement Card component¶: The constructor of the class will take integer rank and suit, and make the card initially facing down. Also, we initialize the size of the component to be equal to the cardSize constant defined in the KlondikeGame class: using Flutter Flame", "completion": "Card(int intRank, int intSuit)\n      : rank = Rank.fromInt(intRank),\n        suit = Suit.fromInt(intSuit),\n        _faceUp = false,\n        super(size: KlondikeGame.cardSize);\n\n  final Rank rank;\n  final Suit suit;\n  bool _faceUp;"}
{"prompt": "Write Flutter Flame code to Card component¶: The constructor of the class will take integer rank and suit, and make the card initially facing down. Also, we initialize the size of the component to be equal to the cardSize constant defined in the KlondikeGame class:", "completion": "Card(int intRank, int intSuit)\n      : rank = Rank.fromInt(intRank),\n        suit = Suit.fromInt(intSuit),\n        _faceUp = false,\n        super(size: KlondikeGame.cardSize);\n\n  final Rank rank;\n  final Suit suit;\n  bool _faceUp;"}
{"prompt": "Create a Flutter Flame game component that Card component¶: Before we proceed with implementing the rendering, we need to add some cards into the game. Head over to the KlondikeGame class and add the following at the bottom of the onLoad method:", "completion": "final random = Random();\n    for (var i = 0; i < 7; i++) {\n      for (var j = 0; j < 4; j++) {\n        final card = Card(random.nextInt(13) + 1, random.nextInt(4))\n          ..position = Vector2(100 + i * 1150, 100 + j * 1500)\n          ..addToParent(world);\n        if (random.nextDouble() < 0.9) { // flip face up with 90% probability\n          card.flip();\n        }\n      }\n    }"}
{"prompt": "Show me how to implement Card component¶: Before we proceed with implementing the rendering, we need to add some cards into the game. Head over to the KlondikeGame class and add the following at the bottom of the onLoad method: using Flutter Flame", "completion": "final random = Random();\n    for (var i = 0; i < 7; i++) {\n      for (var j = 0; j < 4; j++) {\n        final card = Card(random.nextInt(13) + 1, random.nextInt(4))\n          ..position = Vector2(100 + i * 1150, 100 + j * 1500)\n          ..addToParent(world);\n        if (random.nextDouble() < 0.9) { // flip face up with 90% probability\n          card.flip();\n        }\n      }\n    }"}
{"prompt": "Write Flutter Flame code to Card component¶: Before we proceed with implementing the rendering, we need to add some cards into the game. Head over to the KlondikeGame class and add the following at the bottom of the onLoad method:", "completion": "final random = Random();\n    for (var i = 0; i < 7; i++) {\n      for (var j = 0; j < 4; j++) {\n        final card = Card(random.nextInt(13) + 1, random.nextInt(4))\n          ..position = Vector2(100 + i * 1150, 100 + j * 1500)\n          ..addToParent(world);\n        if (random.nextDouble() < 0.9) { // flip face up with 90% probability\n          card.flip();\n        }\n      }\n    }"}
{"prompt": "Create a Flutter Flame game component that renderBack()¶: Various properties used in the _renderBack() method are defined as follows:", "completion": "static final Paint backBackgroundPaint = Paint()\n    ..color = const Color(0xff380c02);\n  static final Paint backBorderPaint1 = Paint()\n    ..color = const Color(0xffdbaf58)\n    ..style = PaintingStyle.stroke\n    ..strokeWidth = 10;\n  static final Paint backBorderPaint2 = Paint()\n    ..color = const Color(0x5CEF971B)\n    ..style = PaintingStyle.stroke\n    ..strokeWidth = 35;\n  static final RRect cardRRect = RRect.fromRectAndRadius(\n    KlondikeGame.cardSize.toRect(),\n    const Radius.circular(KlondikeGame.cardRadius),\n  );\n  static final RRect backRRectInner = cardRRect.deflate(40);\n  static final Sprite flameSprite = klondikeSprite(1367, 6, 357, 501);"}
{"prompt": "Show me how to implement renderBack()¶: Various properties used in the _renderBack() method are defined as follows: using Flutter Flame", "completion": "static final Paint backBackgroundPaint = Paint()\n    ..color = const Color(0xff380c02);\n  static final Paint backBorderPaint1 = Paint()\n    ..color = const Color(0xffdbaf58)\n    ..style = PaintingStyle.stroke\n    ..strokeWidth = 10;\n  static final Paint backBorderPaint2 = Paint()\n    ..color = const Color(0x5CEF971B)\n    ..style = PaintingStyle.stroke\n    ..strokeWidth = 35;\n  static final RRect cardRRect = RRect.fromRectAndRadius(\n    KlondikeGame.cardSize.toRect(),\n    const Radius.circular(KlondikeGame.cardRadius),\n  );\n  static final RRect backRRectInner = cardRRect.deflate(40);\n  static final Sprite flameSprite = klondikeSprite(1367, 6, 357, 501);"}
{"prompt": "Write Flutter Flame code to renderBack()¶: Various properties used in the _renderBack() method are defined as follows:", "completion": "static final Paint backBackgroundPaint = Paint()\n    ..color = const Color(0xff380c02);\n  static final Paint backBorderPaint1 = Paint()\n    ..color = const Color(0xffdbaf58)\n    ..style = PaintingStyle.stroke\n    ..strokeWidth = 10;\n  static final Paint backBorderPaint2 = Paint()\n    ..color = const Color(0x5CEF971B)\n    ..style = PaintingStyle.stroke\n    ..strokeWidth = 35;\n  static final RRect cardRRect = RRect.fromRectAndRadius(\n    KlondikeGame.cardSize.toRect(),\n    const Radius.circular(KlondikeGame.cardRadius),\n  );\n  static final RRect backRRectInner = cardRRect.deflate(40);\n  static final Sprite flameSprite = klondikeSprite(1367, 6, 357, 501);"}
{"prompt": "Create a Flutter Flame game component that renderFront()¶: In order to draw the rest of the card, I need one more helper method. This method will draw the provided sprite on the canvas at the specified place (the location is relative to the dimensions of the card). The sprite can be optionally scaled. In addition, if flag rotate=true is passed, the sprite will be drawn as if it was rotated 180º around the center of the card:", "completion": "void _drawSprite(\n    Canvas canvas,\n    Sprite sprite,\n    double relativeX,\n    double relativeY, {\n    double scale = 1,\n    bool rotate = false,\n  }) {\n    if (rotate) {\n      canvas.save();\n      canvas.translate(size.x / 2, size.y / 2);\n      canvas.rotate(pi);\n      canvas.translate(-size.x / 2, -size.y / 2);\n    }\n    sprite.render(\n      canvas,\n      position: Vector2(relativeX * size.x, relativeY * size.y),\n      anchor: Anchor.center,\n      size: sprite.srcSize.scaled(scale),\n    );\n    if (rotate) {\n      canvas.restore();\n    }\n  }"}
{"prompt": "Show me how to implement renderFront()¶: In order to draw the rest of the card, I need one more helper method. This method will draw the provided sprite on the canvas at the specified place (the location is relative to the dimensions of the card). The sprite can be optionally scaled. In addition, if flag rotate=true is passed, the sprite will be drawn as if it was rotated 180º around the center of the card: using Flutter Flame", "completion": "void _drawSprite(\n    Canvas canvas,\n    Sprite sprite,\n    double relativeX,\n    double relativeY, {\n    double scale = 1,\n    bool rotate = false,\n  }) {\n    if (rotate) {\n      canvas.save();\n      canvas.translate(size.x / 2, size.y / 2);\n      canvas.rotate(pi);\n      canvas.translate(-size.x / 2, -size.y / 2);\n    }\n    sprite.render(\n      canvas,\n      position: Vector2(relativeX * size.x, relativeY * size.y),\n      anchor: Anchor.center,\n      size: sprite.srcSize.scaled(scale),\n    );\n    if (rotate) {\n      canvas.restore();\n    }\n  }"}
{"prompt": "Write Flutter Flame code to renderFront()¶: In order to draw the rest of the card, I need one more helper method. This method will draw the provided sprite on the canvas at the specified place (the location is relative to the dimensions of the card). The sprite can be optionally scaled. In addition, if flag rotate=true is passed, the sprite will be drawn as if it was rotated 180º around the center of the card:", "completion": "void _drawSprite(\n    Canvas canvas,\n    Sprite sprite,\n    double relativeX,\n    double relativeY, {\n    double scale = 1,\n    bool rotate = false,\n  }) {\n    if (rotate) {\n      canvas.save();\n      canvas.translate(size.x / 2, size.y / 2);\n      canvas.rotate(pi);\n      canvas.translate(-size.x / 2, -size.y / 2);\n    }\n    sprite.render(\n      canvas,\n      position: Vector2(relativeX * size.x, relativeY * size.y),\n      anchor: Anchor.center,\n      size: sprite.srcSize.scaled(scale),\n    );\n    if (rotate) {\n      canvas.restore();\n    }\n  }"}
{"prompt": "Create a Flutter Flame game component that renderFront()¶: In the next chapter we will discuss how to implement interactions with the cards, that is, how to make them draggable and tappable.", "completion": "import 'dart:math';\nimport 'dart:ui';\n\nimport 'package:flame/components.dart';\nimport '../klondike_game.dart';\nimport '../rank.dart';\nimport '../suit.dart';\n\nclass Card extends PositionComponent {\nCard(int intRank, int intSuit)\n: rank = Rank.fromInt(intRank),\nsuit = Suit.fromInt(intSuit),\n_faceUp = false,\nsuper(size: KlondikeGame.cardSize);\n\nfinal Rank rank;\nfinal Suit suit;\nbool _faceUp;\n\nbool get isFaceUp => _faceUp;\nvoid flip() => _faceUp = !_faceUp;\n\n@override\nString toString() => rank.label + suit.label; // e.g. \"Q♠\" or \"10♦\"\n\n@override\nvoid render(Canvas canvas) {\nif (_faceUp) {\n_renderFront(canvas);\n} else {\n_renderBack(canvas);\n}\n}\n\nstatic final Paint backBackgroundPaint = Paint()\n..color = const Color(0xff380c02);\nstatic final Paint backBorderPaint1 = Paint()\n..color = const Color(0xffdbaf58)\n..style = PaintingStyle.stroke\n..strokeWidth = 10;\nstatic final Paint backBorderPaint2 = Paint()\n..color = const Color(0x5CEF971B)\n..style = PaintingStyle.stroke\n..strokeWidth = 35;\nstatic final RRect cardRRect = RRect.fromRectAndRadius(\nKlondikeGame.cardSize.toRect(),\nconst Radius.circular(KlondikeGame.cardRadius),\n);\nstatic final RRect backRRectInner = cardRRect.deflate(40);\nstatic final Sprite flameSprite = klondikeSprite(1367, 6, 357, 501);\n\nvoid _renderBack(Canvas canvas) {\ncanvas.drawRRect(cardRRect, backBackgroundPaint);\ncanvas.drawRRect(cardRRect, backBorderPaint1);\ncanvas.drawRRect(backRRectInner, backBorderPaint2);\nflameSprite.render(canvas, position: size / 2, anchor: Anchor.center);\n}\n\nstatic final Paint frontBackgroundPaint = Paint()\n..color = const Color(0xff000000);\nstatic final Paint redBorderPaint = Paint()\n..color = const Color(0xffece8a3)\n..style = PaintingStyle.stroke\n..strokeWidth = 10;\nstatic final Paint blackBorderPaint = Paint()\n..color = const Color(0xff7ab2e8)\n..style = PaintingStyle.stroke\n..strokeWidth = 10;\nstatic final blueFilter = Paint()\n..colorFilter = const ColorFilter.mode(\nColor(0x880d8bff),\nBlendMode.srcATop,\n);\nstatic final Sprite redJack = klondikeSprite(81, 565, 562, 488);\nstatic final Sprite redQueen = klondikeSprite(717, 541, 486, 515);\nstatic final Sprite redKing = klondikeSprite(1305, 532, 407, 549);\nstatic final Sprite blackJack = klondikeSprite(81, 565, 562, 488)\n..paint = blueFilter;\nstatic final Sprite blackQueen = klondikeSprite(717, 541, 486, 515)\n..paint = blueFilter;\nstatic final Sprite blackKing = klondikeSprite(1305, 532, 407, 549)\n..paint = blueFilter;\n\nvoid _renderFront(Canvas canvas) {\ncanvas.drawRRect(cardRRect, frontBackgroundPaint);\ncanvas.drawRRect(\ncardRRect,\nsuit.isRed ? redBorderPaint : blackBorderPaint,\n);\n\nfinal rankSprite = suit.isBlack ? rank.blackSprite : rank.redSprite;\nfinal suitSprite = suit.sprite;\n_drawSprite(canvas, rankSprite, 0.1, 0.08);\n_drawSprite(canvas, suitSprite, 0.1, 0.18, scale: 0.5);\n_drawSprite(canvas, rankSprite, 0.1, 0.08, rotate: true);\n_drawSprite(canvas, suitSprite, 0.1, 0.18, scale: 0.5, rotate: true);\nswitch (rank.value) {\ncase 1:\n_drawSprite(canvas, suitSprite, 0.5, 0.5, scale: 2.5);\ncase 2:\n_drawSprite(canvas, suitSprite, 0.5, 0.25);\n_drawSprite(canvas, suitSprite, 0.5, 0.25, rotate: true);\ncase 3:\n_drawSprite(canvas, suitSprite, 0.5, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.5);\n_drawSprite(canvas, suitSprite, 0.5, 0.2, rotate: true);\ncase 4:\n_drawSprite(canvas, suitSprite, 0.3, 0.25);\n_drawSprite(canvas, suitSprite, 0.7, 0.25);\n_drawSprite(canvas, suitSprite, 0.3, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.25, rotate: true);\ncase 5:\n_drawSprite(canvas, suitSprite, 0.3, 0.25);\n_drawSprite(canvas, suitSprite, 0.7, 0.25);\n_drawSprite(canvas, suitSprite, 0.3, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.5, 0.5);\ncase 6:\n_drawSprite(canvas, suitSprite, 0.3, 0.25);\n_drawSprite(canvas, suitSprite, 0.7, 0.25);\n_drawSprite(canvas, suitSprite, 0.3, 0.5);\n_drawSprite(canvas, suitSprite, 0.7, 0.5);\n_drawSprite(canvas, suitSprite, 0.3, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.25, rotate: true);\ncase 7:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.35);\n_drawSprite(canvas, suitSprite, 0.3, 0.5);\n_drawSprite(canvas, suitSprite, 0.7, 0.5);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\ncase 8:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.35);\n_drawSprite(canvas, suitSprite, 0.3, 0.5);\n_drawSprite(canvas, suitSprite, 0.7, 0.5);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.5, 0.35, rotate: true);\ncase 9:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.3);\n_drawSprite(canvas, suitSprite, 0.3, 0.4);\n_drawSprite(canvas, suitSprite, 0.7, 0.4);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.3, 0.4, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.4, rotate: true);\ncase 10:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.3);\n_drawSprite(canvas, suitSprite, 0.3, 0.4);\n_drawSprite(canvas, suitSprite, 0.7, 0.4);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.5, 0.3, rotate: true);\n_drawSprite(canvas, suitSprite, 0.3, 0.4, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.4, rotate: true);\ncase 11:\n_drawSprite(canvas, suit.isRed ? redJack : blackJack, 0.5, 0.5);\ncase 12:\n_drawSprite(canvas, suit.isRed ? redQueen : blackQueen, 0.5, 0.5);\ncase 13:\n_drawSprite(canvas, suit.isRed ? redKing : blackKing, 0.5, 0.5);\n}\n}\n\nvoid _drawSprite(\nCanvas canvas,\nSprite sprite,\ndouble relativeX,\ndouble relativeY, {\ndouble scale = 1,\nbool rotate = false,\n}) {\nif (rotate) {\ncanvas.save();\ncanvas.translate(size.x / 2, size.y / 2);\ncanvas.rotate(pi);\ncanvas.translate(-size.x / 2, -size.y / 2);\n}\nsprite.render(\ncanvas,\nposition: Vector2(relativeX * size.x, relativeY * size.y),\nanchor: Anchor.center,\nsize: sprite.srcSize.scaled(scale),\n);\nif (rotate) {\ncanvas.restore();\n}\n}\n}"}
{"prompt": "Show me how to implement renderFront()¶: In the next chapter we will discuss how to implement interactions with the cards, that is, how to make them draggable and tappable. using Flutter Flame", "completion": "import 'dart:math';\nimport 'dart:ui';\n\nimport 'package:flame/components.dart';\nimport '../klondike_game.dart';\nimport '../rank.dart';\nimport '../suit.dart';\n\nclass Card extends PositionComponent {\nCard(int intRank, int intSuit)\n: rank = Rank.fromInt(intRank),\nsuit = Suit.fromInt(intSuit),\n_faceUp = false,\nsuper(size: KlondikeGame.cardSize);\n\nfinal Rank rank;\nfinal Suit suit;\nbool _faceUp;\n\nbool get isFaceUp => _faceUp;\nvoid flip() => _faceUp = !_faceUp;\n\n@override\nString toString() => rank.label + suit.label; // e.g. \"Q♠\" or \"10♦\"\n\n@override\nvoid render(Canvas canvas) {\nif (_faceUp) {\n_renderFront(canvas);\n} else {\n_renderBack(canvas);\n}\n}\n\nstatic final Paint backBackgroundPaint = Paint()\n..color = const Color(0xff380c02);\nstatic final Paint backBorderPaint1 = Paint()\n..color = const Color(0xffdbaf58)\n..style = PaintingStyle.stroke\n..strokeWidth = 10;\nstatic final Paint backBorderPaint2 = Paint()\n..color = const Color(0x5CEF971B)\n..style = PaintingStyle.stroke\n..strokeWidth = 35;\nstatic final RRect cardRRect = RRect.fromRectAndRadius(\nKlondikeGame.cardSize.toRect(),\nconst Radius.circular(KlondikeGame.cardRadius),\n);\nstatic final RRect backRRectInner = cardRRect.deflate(40);\nstatic final Sprite flameSprite = klondikeSprite(1367, 6, 357, 501);\n\nvoid _renderBack(Canvas canvas) {\ncanvas.drawRRect(cardRRect, backBackgroundPaint);\ncanvas.drawRRect(cardRRect, backBorderPaint1);\ncanvas.drawRRect(backRRectInner, backBorderPaint2);\nflameSprite.render(canvas, position: size / 2, anchor: Anchor.center);\n}\n\nstatic final Paint frontBackgroundPaint = Paint()\n..color = const Color(0xff000000);\nstatic final Paint redBorderPaint = Paint()\n..color = const Color(0xffece8a3)\n..style = PaintingStyle.stroke\n..strokeWidth = 10;\nstatic final Paint blackBorderPaint = Paint()\n..color = const Color(0xff7ab2e8)\n..style = PaintingStyle.stroke\n..strokeWidth = 10;\nstatic final blueFilter = Paint()\n..colorFilter = const ColorFilter.mode(\nColor(0x880d8bff),\nBlendMode.srcATop,\n);\nstatic final Sprite redJack = klondikeSprite(81, 565, 562, 488);\nstatic final Sprite redQueen = klondikeSprite(717, 541, 486, 515);\nstatic final Sprite redKing = klondikeSprite(1305, 532, 407, 549);\nstatic final Sprite blackJack = klondikeSprite(81, 565, 562, 488)\n..paint = blueFilter;\nstatic final Sprite blackQueen = klondikeSprite(717, 541, 486, 515)\n..paint = blueFilter;\nstatic final Sprite blackKing = klondikeSprite(1305, 532, 407, 549)\n..paint = blueFilter;\n\nvoid _renderFront(Canvas canvas) {\ncanvas.drawRRect(cardRRect, frontBackgroundPaint);\ncanvas.drawRRect(\ncardRRect,\nsuit.isRed ? redBorderPaint : blackBorderPaint,\n);\n\nfinal rankSprite = suit.isBlack ? rank.blackSprite : rank.redSprite;\nfinal suitSprite = suit.sprite;\n_drawSprite(canvas, rankSprite, 0.1, 0.08);\n_drawSprite(canvas, suitSprite, 0.1, 0.18, scale: 0.5);\n_drawSprite(canvas, rankSprite, 0.1, 0.08, rotate: true);\n_drawSprite(canvas, suitSprite, 0.1, 0.18, scale: 0.5, rotate: true);\nswitch (rank.value) {\ncase 1:\n_drawSprite(canvas, suitSprite, 0.5, 0.5, scale: 2.5);\ncase 2:\n_drawSprite(canvas, suitSprite, 0.5, 0.25);\n_drawSprite(canvas, suitSprite, 0.5, 0.25, rotate: true);\ncase 3:\n_drawSprite(canvas, suitSprite, 0.5, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.5);\n_drawSprite(canvas, suitSprite, 0.5, 0.2, rotate: true);\ncase 4:\n_drawSprite(canvas, suitSprite, 0.3, 0.25);\n_drawSprite(canvas, suitSprite, 0.7, 0.25);\n_drawSprite(canvas, suitSprite, 0.3, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.25, rotate: true);\ncase 5:\n_drawSprite(canvas, suitSprite, 0.3, 0.25);\n_drawSprite(canvas, suitSprite, 0.7, 0.25);\n_drawSprite(canvas, suitSprite, 0.3, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.5, 0.5);\ncase 6:\n_drawSprite(canvas, suitSprite, 0.3, 0.25);\n_drawSprite(canvas, suitSprite, 0.7, 0.25);\n_drawSprite(canvas, suitSprite, 0.3, 0.5);\n_drawSprite(canvas, suitSprite, 0.7, 0.5);\n_drawSprite(canvas, suitSprite, 0.3, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.25, rotate: true);\ncase 7:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.35);\n_drawSprite(canvas, suitSprite, 0.3, 0.5);\n_drawSprite(canvas, suitSprite, 0.7, 0.5);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\ncase 8:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.35);\n_drawSprite(canvas, suitSprite, 0.3, 0.5);\n_drawSprite(canvas, suitSprite, 0.7, 0.5);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.5, 0.35, rotate: true);\ncase 9:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.3);\n_drawSprite(canvas, suitSprite, 0.3, 0.4);\n_drawSprite(canvas, suitSprite, 0.7, 0.4);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.3, 0.4, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.4, rotate: true);\ncase 10:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.3);\n_drawSprite(canvas, suitSprite, 0.3, 0.4);\n_drawSprite(canvas, suitSprite, 0.7, 0.4);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.5, 0.3, rotate: true);\n_drawSprite(canvas, suitSprite, 0.3, 0.4, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.4, rotate: true);\ncase 11:\n_drawSprite(canvas, suit.isRed ? redJack : blackJack, 0.5, 0.5);\ncase 12:\n_drawSprite(canvas, suit.isRed ? redQueen : blackQueen, 0.5, 0.5);\ncase 13:\n_drawSprite(canvas, suit.isRed ? redKing : blackKing, 0.5, 0.5);\n}\n}\n\nvoid _drawSprite(\nCanvas canvas,\nSprite sprite,\ndouble relativeX,\ndouble relativeY, {\ndouble scale = 1,\nbool rotate = false,\n}) {\nif (rotate) {\ncanvas.save();\ncanvas.translate(size.x / 2, size.y / 2);\ncanvas.rotate(pi);\ncanvas.translate(-size.x / 2, -size.y / 2);\n}\nsprite.render(\ncanvas,\nposition: Vector2(relativeX * size.x, relativeY * size.y),\nanchor: Anchor.center,\nsize: sprite.srcSize.scaled(scale),\n);\nif (rotate) {\ncanvas.restore();\n}\n}\n}"}
{"prompt": "Write Flutter Flame code to renderFront()¶: In the next chapter we will discuss how to implement interactions with the cards, that is, how to make them draggable and tappable.", "completion": "import 'dart:math';\nimport 'dart:ui';\n\nimport 'package:flame/components.dart';\nimport '../klondike_game.dart';\nimport '../rank.dart';\nimport '../suit.dart';\n\nclass Card extends PositionComponent {\nCard(int intRank, int intSuit)\n: rank = Rank.fromInt(intRank),\nsuit = Suit.fromInt(intSuit),\n_faceUp = false,\nsuper(size: KlondikeGame.cardSize);\n\nfinal Rank rank;\nfinal Suit suit;\nbool _faceUp;\n\nbool get isFaceUp => _faceUp;\nvoid flip() => _faceUp = !_faceUp;\n\n@override\nString toString() => rank.label + suit.label; // e.g. \"Q♠\" or \"10♦\"\n\n@override\nvoid render(Canvas canvas) {\nif (_faceUp) {\n_renderFront(canvas);\n} else {\n_renderBack(canvas);\n}\n}\n\nstatic final Paint backBackgroundPaint = Paint()\n..color = const Color(0xff380c02);\nstatic final Paint backBorderPaint1 = Paint()\n..color = const Color(0xffdbaf58)\n..style = PaintingStyle.stroke\n..strokeWidth = 10;\nstatic final Paint backBorderPaint2 = Paint()\n..color = const Color(0x5CEF971B)\n..style = PaintingStyle.stroke\n..strokeWidth = 35;\nstatic final RRect cardRRect = RRect.fromRectAndRadius(\nKlondikeGame.cardSize.toRect(),\nconst Radius.circular(KlondikeGame.cardRadius),\n);\nstatic final RRect backRRectInner = cardRRect.deflate(40);\nstatic final Sprite flameSprite = klondikeSprite(1367, 6, 357, 501);\n\nvoid _renderBack(Canvas canvas) {\ncanvas.drawRRect(cardRRect, backBackgroundPaint);\ncanvas.drawRRect(cardRRect, backBorderPaint1);\ncanvas.drawRRect(backRRectInner, backBorderPaint2);\nflameSprite.render(canvas, position: size / 2, anchor: Anchor.center);\n}\n\nstatic final Paint frontBackgroundPaint = Paint()\n..color = const Color(0xff000000);\nstatic final Paint redBorderPaint = Paint()\n..color = const Color(0xffece8a3)\n..style = PaintingStyle.stroke\n..strokeWidth = 10;\nstatic final Paint blackBorderPaint = Paint()\n..color = const Color(0xff7ab2e8)\n..style = PaintingStyle.stroke\n..strokeWidth = 10;\nstatic final blueFilter = Paint()\n..colorFilter = const ColorFilter.mode(\nColor(0x880d8bff),\nBlendMode.srcATop,\n);\nstatic final Sprite redJack = klondikeSprite(81, 565, 562, 488);\nstatic final Sprite redQueen = klondikeSprite(717, 541, 486, 515);\nstatic final Sprite redKing = klondikeSprite(1305, 532, 407, 549);\nstatic final Sprite blackJack = klondikeSprite(81, 565, 562, 488)\n..paint = blueFilter;\nstatic final Sprite blackQueen = klondikeSprite(717, 541, 486, 515)\n..paint = blueFilter;\nstatic final Sprite blackKing = klondikeSprite(1305, 532, 407, 549)\n..paint = blueFilter;\n\nvoid _renderFront(Canvas canvas) {\ncanvas.drawRRect(cardRRect, frontBackgroundPaint);\ncanvas.drawRRect(\ncardRRect,\nsuit.isRed ? redBorderPaint : blackBorderPaint,\n);\n\nfinal rankSprite = suit.isBlack ? rank.blackSprite : rank.redSprite;\nfinal suitSprite = suit.sprite;\n_drawSprite(canvas, rankSprite, 0.1, 0.08);\n_drawSprite(canvas, suitSprite, 0.1, 0.18, scale: 0.5);\n_drawSprite(canvas, rankSprite, 0.1, 0.08, rotate: true);\n_drawSprite(canvas, suitSprite, 0.1, 0.18, scale: 0.5, rotate: true);\nswitch (rank.value) {\ncase 1:\n_drawSprite(canvas, suitSprite, 0.5, 0.5, scale: 2.5);\ncase 2:\n_drawSprite(canvas, suitSprite, 0.5, 0.25);\n_drawSprite(canvas, suitSprite, 0.5, 0.25, rotate: true);\ncase 3:\n_drawSprite(canvas, suitSprite, 0.5, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.5);\n_drawSprite(canvas, suitSprite, 0.5, 0.2, rotate: true);\ncase 4:\n_drawSprite(canvas, suitSprite, 0.3, 0.25);\n_drawSprite(canvas, suitSprite, 0.7, 0.25);\n_drawSprite(canvas, suitSprite, 0.3, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.25, rotate: true);\ncase 5:\n_drawSprite(canvas, suitSprite, 0.3, 0.25);\n_drawSprite(canvas, suitSprite, 0.7, 0.25);\n_drawSprite(canvas, suitSprite, 0.3, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.5, 0.5);\ncase 6:\n_drawSprite(canvas, suitSprite, 0.3, 0.25);\n_drawSprite(canvas, suitSprite, 0.7, 0.25);\n_drawSprite(canvas, suitSprite, 0.3, 0.5);\n_drawSprite(canvas, suitSprite, 0.7, 0.5);\n_drawSprite(canvas, suitSprite, 0.3, 0.25, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.25, rotate: true);\ncase 7:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.35);\n_drawSprite(canvas, suitSprite, 0.3, 0.5);\n_drawSprite(canvas, suitSprite, 0.7, 0.5);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\ncase 8:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.35);\n_drawSprite(canvas, suitSprite, 0.3, 0.5);\n_drawSprite(canvas, suitSprite, 0.7, 0.5);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.5, 0.35, rotate: true);\ncase 9:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.3);\n_drawSprite(canvas, suitSprite, 0.3, 0.4);\n_drawSprite(canvas, suitSprite, 0.7, 0.4);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.3, 0.4, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.4, rotate: true);\ncase 10:\n_drawSprite(canvas, suitSprite, 0.3, 0.2);\n_drawSprite(canvas, suitSprite, 0.7, 0.2);\n_drawSprite(canvas, suitSprite, 0.5, 0.3);\n_drawSprite(canvas, suitSprite, 0.3, 0.4);\n_drawSprite(canvas, suitSprite, 0.7, 0.4);\n_drawSprite(canvas, suitSprite, 0.3, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.2, rotate: true);\n_drawSprite(canvas, suitSprite, 0.5, 0.3, rotate: true);\n_drawSprite(canvas, suitSprite, 0.3, 0.4, rotate: true);\n_drawSprite(canvas, suitSprite, 0.7, 0.4, rotate: true);\ncase 11:\n_drawSprite(canvas, suit.isRed ? redJack : blackJack, 0.5, 0.5);\ncase 12:\n_drawSprite(canvas, suit.isRed ? redQueen : blackQueen, 0.5, 0.5);\ncase 13:\n_drawSprite(canvas, suit.isRed ? redKing : blackKing, 0.5, 0.5);\n}\n}\n\nvoid _drawSprite(\nCanvas canvas,\nSprite sprite,\ndouble relativeX,\ndouble relativeY, {\ndouble scale = 1,\nbool rotate = false,\n}) {\nif (rotate) {\ncanvas.save();\ncanvas.translate(size.x / 2, size.y / 2);\ncanvas.rotate(pi);\ncanvas.translate(-size.x / 2, -size.y / 2);\n}\nsprite.render(\ncanvas,\nposition: Vector2(relativeX * size.x, relativeY * size.y),\nanchor: Anchor.center,\nsize: sprite.srcSize.scaled(scale),\n);\nif (rotate) {\ncanvas.restore();\n}\n}\n}"}
{"prompt": "Create a Flutter Flame game component that renderFront()¶: In the next chapter we will discuss how to implement interactions with the cards, that is, how to make them draggable and tappable.", "completion": "import 'package:flame/components.dart';\n\nclass Foundation extends PositionComponent {\n@override\nbool get debugMode => true;\n}"}
{"prompt": "Show me how to implement renderFront()¶: In the next chapter we will discuss how to implement interactions with the cards, that is, how to make them draggable and tappable. using Flutter Flame", "completion": "import 'package:flame/components.dart';\n\nclass Foundation extends PositionComponent {\n@override\nbool get debugMode => true;\n}"}
{"prompt": "Write Flutter Flame code to renderFront()¶: In the next chapter we will discuss how to implement interactions with the cards, that is, how to make them draggable and tappable.", "completion": "import 'package:flame/components.dart';\n\nclass Foundation extends PositionComponent {\n@override\nbool get debugMode => true;\n}"}
{"prompt": "Create a Flutter Flame game component that renderFront()¶: In the next chapter we will discuss how to implement interactions with the cards, that is, how to make them draggable and tappable.", "completion": "import 'package:flame/components.dart';\n\nclass Pile extends PositionComponent {\n@override\nbool get debugMode => true;\n}"}
{"prompt": "Show me how to implement renderFront()¶: In the next chapter we will discuss how to implement interactions with the cards, that is, how to make them draggable and tappable. using Flutter Flame", "completion": "import 'package:flame/components.dart';\n\nclass Pile extends PositionComponent {\n@override\nbool get debugMode => true;\n}"}
{"prompt": "Write Flutter Flame code to renderFront()¶: In the next chapter we will discuss how to implement interactions with the cards, that is, how to make them draggable and tappable.", "completion": "import 'package:flame/components.dart';\n\nclass Pile extends PositionComponent {\n@override\nbool get debugMode => true;\n}"}
{"prompt": "Create a Flutter Flame game component that renderFront()¶: In the next chapter we will discuss how to implement interactions with the cards, that is, how to make them draggable and tappable.", "completion": "import 'package:flame/components.dart';\n\nclass Stock extends PositionComponent {\n@override\nbool get debugMode => true;\n}"}
{"prompt": "Show me how to implement renderFront()¶: In the next chapter we will discuss how to implement interactions with the cards, that is, how to make them draggable and tappable. using Flutter Flame", "completion": "import 'package:flame/components.dart';\n\nclass Stock extends PositionComponent {\n@override\nbool get debugMode => true;\n}"}
{"prompt": "Write Flutter Flame code to renderFront()¶: In the next chapter we will discuss how to implement interactions with the cards, that is, how to make them draggable and tappable.", "completion": "import 'package:flame/components.dart';\n\nclass Stock extends PositionComponent {\n@override\nbool get debugMode => true;\n}"}
{"prompt": "Create a Flutter Flame game component that renderFront()¶: In the next chapter we will discuss how to implement interactions with the cards, that is, how to make them draggable and tappable.", "completion": "import 'package:flame/components.dart';\n\nclass Waste extends PositionComponent {\n@override\nbool get debugMode => true;\n}"}
{"prompt": "Show me how to implement renderFront()¶: In the next chapter we will discuss how to implement interactions with the cards, that is, how to make them draggable and tappable. using Flutter Flame", "completion": "import 'package:flame/components.dart';\n\nclass Waste extends PositionComponent {\n@override\nbool get debugMode => true;\n}"}
{"prompt": "Write Flutter Flame code to renderFront()¶: In the next chapter we will discuss how to implement interactions with the cards, that is, how to make them draggable and tappable.", "completion": "import 'package:flame/components.dart';\n\nclass Waste extends PositionComponent {\n@override\nbool get debugMode => true;\n}"}
{"prompt": "Create a Flutter Flame game component that renderFront()¶: In the next chapter we will discuss how to implement interactions with the cards, that is, how to make them draggable and tappable.", "completion": "import 'dart:math';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/flame.dart';\nimport 'package:flame/game.dart';\n\nimport 'components/card.dart';\nimport 'components/foundation.dart';\nimport 'components/pile.dart';\nimport 'components/stock.dart';\nimport 'components/waste.dart';\n\nclass KlondikeGame extends FlameGame {\nstatic const double cardGap = 175.0;\nstatic const double cardWidth = 1000.0;\nstatic const double cardHeight = 1400.0;\nstatic const double cardRadius = 100.0;\nstatic final Vector2 cardSize = Vector2(cardWidth, cardHeight);\n\n@override\nFuture<void> onLoad() async {\nawait Flame.images.load('klondike-sprites.png');\n\nfinal stock = Stock()\n..size = cardSize\n..position = Vector2(cardGap, cardGap);\nfinal waste = Waste()\n..size = cardSize\n..position = Vector2(cardWidth + 2 * cardGap, cardGap);\nfinal foundations = List.generate(\n4,\n(i) => Foundation()\n..size = cardSize\n..position =\nVector2((i + 3) * (cardWidth + cardGap) + cardGap, cardGap),\n);\nfinal piles = List.generate(\n7,\n(i) => Pile()\n..size = cardSize\n..position = Vector2(\ncardGap + i * (cardWidth + cardGap),\ncardHeight + 2 * cardGap,\n),\n);\n\nworld.add(stock);\nworld.add(waste);\nworld.addAll(foundations);\nworld.addAll(piles);\n\ncamera.viewfinder.visibleGameSize =\nVector2(cardWidth * 7 + cardGap * 8, 4 * cardHeight + 3 * cardGap);\ncamera.viewfinder.position = Vector2(cardWidth * 3.5 + cardGap * 4, 0);\ncamera.viewfinder.anchor = Anchor.topCenter;\n\nfinal random = Random();\nfor (var i = 0; i < 7; i++) {\nfor (var j = 0; j < 4; j++) {\nfinal card = Card(random.nextInt(13) + 1, random.nextInt(4))\n..position = Vector2(100 + i * 1150, 100 + j * 1500)\n..addToParent(world);\n// flip the card face-up with 90% probability\nif (random.nextDouble() < 0.9) {\ncard.flip();\n}\n}\n}\n}\n}\n\nSprite klondikeSprite(double x, double y, double width, double height) {\nreturn Sprite(\nFlame.images.fromCache('klondike-sprites.png'),\nsrcPosition: Vector2(x, y),\nsrcSize: Vector2(width, height),\n);\n}"}
{"prompt": "Show me how to implement renderFront()¶: In the next chapter we will discuss how to implement interactions with the cards, that is, how to make them draggable and tappable. using Flutter Flame", "completion": "import 'dart:math';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/flame.dart';\nimport 'package:flame/game.dart';\n\nimport 'components/card.dart';\nimport 'components/foundation.dart';\nimport 'components/pile.dart';\nimport 'components/stock.dart';\nimport 'components/waste.dart';\n\nclass KlondikeGame extends FlameGame {\nstatic const double cardGap = 175.0;\nstatic const double cardWidth = 1000.0;\nstatic const double cardHeight = 1400.0;\nstatic const double cardRadius = 100.0;\nstatic final Vector2 cardSize = Vector2(cardWidth, cardHeight);\n\n@override\nFuture<void> onLoad() async {\nawait Flame.images.load('klondike-sprites.png');\n\nfinal stock = Stock()\n..size = cardSize\n..position = Vector2(cardGap, cardGap);\nfinal waste = Waste()\n..size = cardSize\n..position = Vector2(cardWidth + 2 * cardGap, cardGap);\nfinal foundations = List.generate(\n4,\n(i) => Foundation()\n..size = cardSize\n..position =\nVector2((i + 3) * (cardWidth + cardGap) + cardGap, cardGap),\n);\nfinal piles = List.generate(\n7,\n(i) => Pile()\n..size = cardSize\n..position = Vector2(\ncardGap + i * (cardWidth + cardGap),\ncardHeight + 2 * cardGap,\n),\n);\n\nworld.add(stock);\nworld.add(waste);\nworld.addAll(foundations);\nworld.addAll(piles);\n\ncamera.viewfinder.visibleGameSize =\nVector2(cardWidth * 7 + cardGap * 8, 4 * cardHeight + 3 * cardGap);\ncamera.viewfinder.position = Vector2(cardWidth * 3.5 + cardGap * 4, 0);\ncamera.viewfinder.anchor = Anchor.topCenter;\n\nfinal random = Random();\nfor (var i = 0; i < 7; i++) {\nfor (var j = 0; j < 4; j++) {\nfinal card = Card(random.nextInt(13) + 1, random.nextInt(4))\n..position = Vector2(100 + i * 1150, 100 + j * 1500)\n..addToParent(world);\n// flip the card face-up with 90% probability\nif (random.nextDouble() < 0.9) {\ncard.flip();\n}\n}\n}\n}\n}\n\nSprite klondikeSprite(double x, double y, double width, double height) {\nreturn Sprite(\nFlame.images.fromCache('klondike-sprites.png'),\nsrcPosition: Vector2(x, y),\nsrcSize: Vector2(width, height),\n);\n}"}
{"prompt": "Write Flutter Flame code to renderFront()¶: In the next chapter we will discuss how to implement interactions with the cards, that is, how to make them draggable and tappable.", "completion": "import 'dart:math';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/flame.dart';\nimport 'package:flame/game.dart';\n\nimport 'components/card.dart';\nimport 'components/foundation.dart';\nimport 'components/pile.dart';\nimport 'components/stock.dart';\nimport 'components/waste.dart';\n\nclass KlondikeGame extends FlameGame {\nstatic const double cardGap = 175.0;\nstatic const double cardWidth = 1000.0;\nstatic const double cardHeight = 1400.0;\nstatic const double cardRadius = 100.0;\nstatic final Vector2 cardSize = Vector2(cardWidth, cardHeight);\n\n@override\nFuture<void> onLoad() async {\nawait Flame.images.load('klondike-sprites.png');\n\nfinal stock = Stock()\n..size = cardSize\n..position = Vector2(cardGap, cardGap);\nfinal waste = Waste()\n..size = cardSize\n..position = Vector2(cardWidth + 2 * cardGap, cardGap);\nfinal foundations = List.generate(\n4,\n(i) => Foundation()\n..size = cardSize\n..position =\nVector2((i + 3) * (cardWidth + cardGap) + cardGap, cardGap),\n);\nfinal piles = List.generate(\n7,\n(i) => Pile()\n..size = cardSize\n..position = Vector2(\ncardGap + i * (cardWidth + cardGap),\ncardHeight + 2 * cardGap,\n),\n);\n\nworld.add(stock);\nworld.add(waste);\nworld.addAll(foundations);\nworld.addAll(piles);\n\ncamera.viewfinder.visibleGameSize =\nVector2(cardWidth * 7 + cardGap * 8, 4 * cardHeight + 3 * cardGap);\ncamera.viewfinder.position = Vector2(cardWidth * 3.5 + cardGap * 4, 0);\ncamera.viewfinder.anchor = Anchor.topCenter;\n\nfinal random = Random();\nfor (var i = 0; i < 7; i++) {\nfor (var j = 0; j < 4; j++) {\nfinal card = Card(random.nextInt(13) + 1, random.nextInt(4))\n..position = Vector2(100 + i * 1150, 100 + j * 1500)\n..addToParent(world);\n// flip the card face-up with 90% probability\nif (random.nextDouble() < 0.9) {\ncard.flip();\n}\n}\n}\n}\n}\n\nSprite klondikeSprite(double x, double y, double width, double height) {\nreturn Sprite(\nFlame.images.fromCache('klondike-sprites.png'),\nsrcPosition: Vector2(x, y),\nsrcSize: Vector2(width, height),\n);\n}"}
{"prompt": "Create a Flutter Flame game component that renderFront()¶: In the next chapter we will discuss how to implement interactions with the cards, that is, how to make them draggable and tappable.", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'klondike_game.dart';\n\nvoid main() {\nfinal game = KlondikeGame();\nrunApp(GameWidget(game: game));\n}"}
{"prompt": "Show me how to implement renderFront()¶: In the next chapter we will discuss how to implement interactions with the cards, that is, how to make them draggable and tappable. using Flutter Flame", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'klondike_game.dart';\n\nvoid main() {\nfinal game = KlondikeGame();\nrunApp(GameWidget(game: game));\n}"}
{"prompt": "Write Flutter Flame code to renderFront()¶: In the next chapter we will discuss how to implement interactions with the cards, that is, how to make them draggable and tappable.", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/widgets.dart';\n\nimport 'klondike_game.dart';\n\nvoid main() {\nfinal game = KlondikeGame();\nrunApp(GameWidget(game: game));\n}"}
{"prompt": "Create a Flutter Flame game component that renderFront()¶: In the next chapter we will discuss how to implement interactions with the cards, that is, how to make them draggable and tappable.", "completion": "import 'package:flame/components.dart';\nimport 'package:flutter/foundation.dart';\nimport 'klondike_game.dart';\n\n@immutable\nclass Rank {\nfactory Rank.fromInt(int value) {\nassert(\nvalue >= 1 && value <= 13,\n'value is outside of the bounds of what a rank can be',\n);\nreturn _singletons[value - 1];\n}\n\nRank._(\nthis.value,\nthis.label,\ndouble x1,\ndouble y1,\ndouble x2,\ndouble y2,\ndouble w,\ndouble h,\n)   : redSprite = klondikeSprite(x1, y1, w, h),\nblackSprite = klondikeSprite(x2, y2, w, h);\n\nfinal int value;\nfinal String label;\nfinal Sprite redSprite;\nfinal Sprite blackSprite;\n\nstatic final List<Rank> _singletons = [\nRank._(1, 'A', 335, 164, 789, 161, 120, 129),\nRank._(2, '2', 20, 19, 15, 322, 83, 125),\nRank._(3, '3', 122, 19, 117, 322, 80, 127),\nRank._(4, '4', 213, 12, 208, 315, 93, 132),\nRank._(5, '5', 314, 21, 309, 324, 85, 125),\nRank._(6, '6', 419, 17, 414, 320, 84, 129),\nRank._(7, '7', 509, 21, 505, 324, 92, 128),\nRank._(8, '8', 612, 19, 607, 322, 78, 127),\nRank._(9, '9', 709, 19, 704, 322, 84, 130),\nRank._(10, '10', 810, 20, 805, 322, 137, 127),\nRank._(11, 'J', 15, 170, 469, 167, 56, 126),\nRank._(12, 'Q', 92, 168, 547, 165, 132, 128),\nRank._(13, 'K', 243, 170, 696, 167, 92, 123),\n];\n}"}
{"prompt": "Show me how to implement renderFront()¶: In the next chapter we will discuss how to implement interactions with the cards, that is, how to make them draggable and tappable. using Flutter Flame", "completion": "import 'package:flame/components.dart';\nimport 'package:flutter/foundation.dart';\nimport 'klondike_game.dart';\n\n@immutable\nclass Rank {\nfactory Rank.fromInt(int value) {\nassert(\nvalue >= 1 && value <= 13,\n'value is outside of the bounds of what a rank can be',\n);\nreturn _singletons[value - 1];\n}\n\nRank._(\nthis.value,\nthis.label,\ndouble x1,\ndouble y1,\ndouble x2,\ndouble y2,\ndouble w,\ndouble h,\n)   : redSprite = klondikeSprite(x1, y1, w, h),\nblackSprite = klondikeSprite(x2, y2, w, h);\n\nfinal int value;\nfinal String label;\nfinal Sprite redSprite;\nfinal Sprite blackSprite;\n\nstatic final List<Rank> _singletons = [\nRank._(1, 'A', 335, 164, 789, 161, 120, 129),\nRank._(2, '2', 20, 19, 15, 322, 83, 125),\nRank._(3, '3', 122, 19, 117, 322, 80, 127),\nRank._(4, '4', 213, 12, 208, 315, 93, 132),\nRank._(5, '5', 314, 21, 309, 324, 85, 125),\nRank._(6, '6', 419, 17, 414, 320, 84, 129),\nRank._(7, '7', 509, 21, 505, 324, 92, 128),\nRank._(8, '8', 612, 19, 607, 322, 78, 127),\nRank._(9, '9', 709, 19, 704, 322, 84, 130),\nRank._(10, '10', 810, 20, 805, 322, 137, 127),\nRank._(11, 'J', 15, 170, 469, 167, 56, 126),\nRank._(12, 'Q', 92, 168, 547, 165, 132, 128),\nRank._(13, 'K', 243, 170, 696, 167, 92, 123),\n];\n}"}
{"prompt": "Write Flutter Flame code to renderFront()¶: In the next chapter we will discuss how to implement interactions with the cards, that is, how to make them draggable and tappable.", "completion": "import 'package:flame/components.dart';\nimport 'package:flutter/foundation.dart';\nimport 'klondike_game.dart';\n\n@immutable\nclass Rank {\nfactory Rank.fromInt(int value) {\nassert(\nvalue >= 1 && value <= 13,\n'value is outside of the bounds of what a rank can be',\n);\nreturn _singletons[value - 1];\n}\n\nRank._(\nthis.value,\nthis.label,\ndouble x1,\ndouble y1,\ndouble x2,\ndouble y2,\ndouble w,\ndouble h,\n)   : redSprite = klondikeSprite(x1, y1, w, h),\nblackSprite = klondikeSprite(x2, y2, w, h);\n\nfinal int value;\nfinal String label;\nfinal Sprite redSprite;\nfinal Sprite blackSprite;\n\nstatic final List<Rank> _singletons = [\nRank._(1, 'A', 335, 164, 789, 161, 120, 129),\nRank._(2, '2', 20, 19, 15, 322, 83, 125),\nRank._(3, '3', 122, 19, 117, 322, 80, 127),\nRank._(4, '4', 213, 12, 208, 315, 93, 132),\nRank._(5, '5', 314, 21, 309, 324, 85, 125),\nRank._(6, '6', 419, 17, 414, 320, 84, 129),\nRank._(7, '7', 509, 21, 505, 324, 92, 128),\nRank._(8, '8', 612, 19, 607, 322, 78, 127),\nRank._(9, '9', 709, 19, 704, 322, 84, 130),\nRank._(10, '10', 810, 20, 805, 322, 137, 127),\nRank._(11, 'J', 15, 170, 469, 167, 56, 126),\nRank._(12, 'Q', 92, 168, 547, 165, 132, 128),\nRank._(13, 'K', 243, 170, 696, 167, 92, 123),\n];\n}"}
{"prompt": "Create a Flutter Flame game component that renderFront()¶: In the next chapter we will discuss how to implement interactions with the cards, that is, how to make them draggable and tappable.", "completion": "import 'package:flame/sprite.dart';\nimport 'package:flutter/foundation.dart';\nimport 'klondike_game.dart';\n\n@immutable\nclass Suit {\nfactory Suit.fromInt(int index) {\nassert(\nindex >= 0 && index <= 3,\n'index is outside of the bounds of what a suit can be',\n);\nreturn _singletons[index];\n}\n\nSuit._(this.value, this.label, double x, double y, double w, double h)\n: sprite = klondikeSprite(x, y, w, h);\n\nfinal int value;\nfinal String label;\nfinal Sprite sprite;\n\nstatic final List<Suit> _singletons = [\nSuit._(0, '♥', 1176, 17, 172, 183),\nSuit._(1, '♦', 973, 14, 177, 182),\nSuit._(2, '♣', 974, 226, 184, 172),\nSuit._(3, '♠', 1178, 220, 176, 182),\n];\n\n/// Hearts and Diamonds are red, while Clubs and Spades are black.\nbool get isRed => value <= 1;\nbool get isBlack => value >= 2;\n}"}
{"prompt": "Show me how to implement renderFront()¶: In the next chapter we will discuss how to implement interactions with the cards, that is, how to make them draggable and tappable. using Flutter Flame", "completion": "import 'package:flame/sprite.dart';\nimport 'package:flutter/foundation.dart';\nimport 'klondike_game.dart';\n\n@immutable\nclass Suit {\nfactory Suit.fromInt(int index) {\nassert(\nindex >= 0 && index <= 3,\n'index is outside of the bounds of what a suit can be',\n);\nreturn _singletons[index];\n}\n\nSuit._(this.value, this.label, double x, double y, double w, double h)\n: sprite = klondikeSprite(x, y, w, h);\n\nfinal int value;\nfinal String label;\nfinal Sprite sprite;\n\nstatic final List<Suit> _singletons = [\nSuit._(0, '♥', 1176, 17, 172, 183),\nSuit._(1, '♦', 973, 14, 177, 182),\nSuit._(2, '♣', 974, 226, 184, 172),\nSuit._(3, '♠', 1178, 220, 176, 182),\n];\n\n/// Hearts and Diamonds are red, while Clubs and Spades are black.\nbool get isRed => value <= 1;\nbool get isBlack => value >= 2;\n}"}
{"prompt": "Write Flutter Flame code to renderFront()¶: In the next chapter we will discuss how to implement interactions with the cards, that is, how to make them draggable and tappable.", "completion": "import 'package:flame/sprite.dart';\nimport 'package:flutter/foundation.dart';\nimport 'klondike_game.dart';\n\n@immutable\nclass Suit {\nfactory Suit.fromInt(int index) {\nassert(\nindex >= 0 && index <= 3,\n'index is outside of the bounds of what a suit can be',\n);\nreturn _singletons[index];\n}\n\nSuit._(this.value, this.label, double x, double y, double w, double h)\n: sprite = klondikeSprite(x, y, w, h);\n\nfinal int value;\nfinal String label;\nfinal Sprite sprite;\n\nstatic final List<Suit> _singletons = [\nSuit._(0, '♥', 1176, 17, 172, 183),\nSuit._(1, '♦', 973, 14, 177, 182),\nSuit._(2, '♣', 974, 226, 184, 172),\nSuit._(3, '♠', 1178, 220, 176, 182),\n];\n\n/// Hearts and Diamonds are red, while Clubs and Spades are black.\nbool get isRed => value <= 1;\nbool get isBlack => value >= 2;\n}"}
{"prompt": "Create a Flutter Flame game component that Standalone usage¶: It can manually be used by instantiating it:", "completion": "import 'package:flame/cache.dart';\nfinal imagesLoader = Images();\nImage image = await imagesLoader.load('yourImage.png');"}
{"prompt": "Show me how to implement Standalone usage¶: It can manually be used by instantiating it: using Flutter Flame", "completion": "import 'package:flame/cache.dart';\nfinal imagesLoader = Images();\nImage image = await imagesLoader.load('yourImage.png');"}
{"prompt": "Write Flutter Flame code to Standalone usage¶: It can manually be used by instantiating it:", "completion": "import 'package:flame/cache.dart';\nfinal imagesLoader = Images();\nImage image = await imagesLoader.load('yourImage.png');"}
{"prompt": "Create a Flutter Flame game component that Flame.images¶: Example:", "completion": "import 'package:flame/flame.dart';\nimport 'package:flame/sprite.dart';\n\n// inside an async context\nImage image = await Flame.images.load('player.png');\n\nfinal playerSprite = Sprite(image);"}
{"prompt": "Show me how to implement Flame.images¶: Example: using Flutter Flame", "completion": "import 'package:flame/flame.dart';\nimport 'package:flame/sprite.dart';\n\n// inside an async context\nImage image = await Flame.images.load('player.png');\n\nfinal playerSprite = Sprite(image);"}
{"prompt": "Write Flutter Flame code to Flame.images¶: Example:", "completion": "import 'package:flame/flame.dart';\nimport 'package:flame/sprite.dart';\n\n// inside an async context\nImage image = await Flame.images.load('player.png');\n\nfinal playerSprite = Sprite(image);"}
{"prompt": "Create a Flutter Flame game component that Game.images¶: Example:", "completion": "class MyGame extends Game {\n\n  Sprite player;\n\n  @override\n  Future<void> onLoad() async {\n    // Note that you could also use Sprite.load for this.\n    final playerImage = await images.load('player.png');\n    player = Sprite(playerImage);\n  }\n}"}
{"prompt": "Show me how to implement Game.images¶: Example: using Flutter Flame", "completion": "class MyGame extends Game {\n\n  Sprite player;\n\n  @override\n  Future<void> onLoad() async {\n    // Note that you could also use Sprite.load for this.\n    final playerImage = await images.load('player.png');\n    player = Sprite(playerImage);\n  }\n}"}
{"prompt": "Write Flutter Flame code to Game.images¶: Example:", "completion": "class MyGame extends Game {\n\n  Sprite player;\n\n  @override\n  Future<void> onLoad() async {\n    // Note that you could also use Sprite.load for this.\n    final playerImage = await images.load('player.png');\n    player = Sprite(playerImage);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Game.images¶: Loaded assets can also be retrieved while the game is running by images.fromCache, for example:", "completion": "class MyGame extends Game {\n\n  // attributes omitted\n\n  @override\n  Future<void> onLoad() async {\n    // other loads omitted\n    await images.load('bullet.png');\n  }\n\n  void shoot() {\n    // This is just an example, in your game you probably don't want to\n    // instantiate new [Sprite] objects every time you shoot.\n    final bulletSprite = Sprite(images.fromCache('bullet.png'));\n    _bullets.add(bulletSprite);\n  }\n}"}
{"prompt": "Show me how to implement Game.images¶: Loaded assets can also be retrieved while the game is running by images.fromCache, for example: using Flutter Flame", "completion": "class MyGame extends Game {\n\n  // attributes omitted\n\n  @override\n  Future<void> onLoad() async {\n    // other loads omitted\n    await images.load('bullet.png');\n  }\n\n  void shoot() {\n    // This is just an example, in your game you probably don't want to\n    // instantiate new [Sprite] objects every time you shoot.\n    final bulletSprite = Sprite(images.fromCache('bullet.png'));\n    _bullets.add(bulletSprite);\n  }\n}"}
{"prompt": "Write Flutter Flame code to Game.images¶: Loaded assets can also be retrieved while the game is running by images.fromCache, for example:", "completion": "class MyGame extends Game {\n\n  // attributes omitted\n\n  @override\n  Future<void> onLoad() async {\n    // other loads omitted\n    await images.load('bullet.png');\n  }\n\n  void shoot() {\n    // This is just an example, in your game you probably don't want to\n    // instantiate new [Sprite] objects every time you shoot.\n    final bulletSprite = Sprite(images.fromCache('bullet.png'));\n    _bullets.add(bulletSprite);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Loading images over the network¶: With that said, it is quite simple to load images from the network once a http client package is chosen by the user. The following snippet shows how an Image can be fetched from the web using the http package.", "completion": "import 'package:http/http.dart' as http;\nimport 'package:flutter/painting.dart';\n\nfinal response = await http.get('https://url.com/image.png');\nfinal image = await decodeImageFromList(response.bytes);"}
{"prompt": "Show me how to implement Loading images over the network¶: With that said, it is quite simple to load images from the network once a http client package is chosen by the user. The following snippet shows how an Image can be fetched from the web using the http package. using Flutter Flame", "completion": "import 'package:http/http.dart' as http;\nimport 'package:flutter/painting.dart';\n\nfinal response = await http.get('https://url.com/image.png');\nfinal image = await decodeImageFromList(response.bytes);"}
{"prompt": "Write Flutter Flame code to Loading images over the network¶: With that said, it is quite simple to load images from the network once a http client package is chosen by the user. The following snippet shows how an Image can be fetched from the web using the http package.", "completion": "import 'package:http/http.dart' as http;\nimport 'package:flutter/painting.dart';\n\nfinal response = await http.get('https://url.com/image.png');\nfinal image = await decodeImageFromList(response.bytes);"}
{"prompt": "Create a Flutter Flame game component that Sprite¶: You can also specify the coordinates in the original image where the sprite is located. This allows you to use sprite sheets and reduce the number of images in memory, for example:", "completion": "final image = await images.load('player.png');\nfinal playerFrame = Sprite(\n  image,\n  srcPosition: Vector2(32.0, 0),\n  srcSize: Vector2(16.0, 16.0),\n);"}
{"prompt": "Show me how to implement Sprite¶: You can also specify the coordinates in the original image where the sprite is located. This allows you to use sprite sheets and reduce the number of images in memory, for example: using Flutter Flame", "completion": "final image = await images.load('player.png');\nfinal playerFrame = Sprite(\n  image,\n  srcPosition: Vector2(32.0, 0),\n  srcSize: Vector2(16.0, 16.0),\n);"}
{"prompt": "Write Flutter Flame code to Sprite¶: You can also specify the coordinates in the original image where the sprite is located. This allows you to use sprite sheets and reduce the number of images in memory, for example:", "completion": "final image = await images.load('player.png');\nfinal playerFrame = Sprite(\n  image,\n  srcPosition: Vector2(32.0, 0),\n  srcSize: Vector2(16.0, 16.0),\n);"}
{"prompt": "Create a Flutter Flame game component that ImageComposition¶: For such use cases Flame comes with the ImageComposition class. This allows you to add multiple images, each at their own position, onto a new image:", "completion": "final composition = ImageComposition()\n  ..add(image1, Vector2(0, 0))\n  ..add(image2, Vector2(64, 0));\n  ..add(image3,\n    Vector2(128, 0),\n    source: Rect.fromLTWH(32, 32, 64, 64),\n  );\n  \nImage image = await composition.compose();\nImage imageSync = composition.composeSync();"}
{"prompt": "Show me how to implement ImageComposition¶: For such use cases Flame comes with the ImageComposition class. This allows you to add multiple images, each at their own position, onto a new image: using Flutter Flame", "completion": "final composition = ImageComposition()\n  ..add(image1, Vector2(0, 0))\n  ..add(image2, Vector2(64, 0));\n  ..add(image3,\n    Vector2(128, 0),\n    source: Rect.fromLTWH(32, 32, 64, 64),\n  );\n  \nImage image = await composition.compose();\nImage imageSync = composition.composeSync();"}
{"prompt": "Write Flutter Flame code to ImageComposition¶: For such use cases Flame comes with the ImageComposition class. This allows you to add multiple images, each at their own position, onto a new image:", "completion": "final composition = ImageComposition()\n  ..add(image1, Vector2(0, 0))\n  ..add(image2, Vector2(64, 0));\n  ..add(image3,\n    Vector2(128, 0),\n    source: Rect.fromLTWH(32, 32, 64, 64),\n  );\n  \nImage image = await composition.compose();\nImage imageSync = composition.composeSync();"}
{"prompt": "Create a Flutter Flame game component that Animation¶: Example:", "completion": "class MyGame extends Game {\n  SpriteAnimationTicker a;\n\n  MyGame() {\n    a = SpriteAnimationTicker(SpriteAnimation(...));\n  }\n\n  void update(double dt) {\n    a.update(dt);\n  }\n\n  void render(Canvas c) {\n    a.getSprite().render(c);\n  }\n}"}
{"prompt": "Show me how to implement Animation¶: Example: using Flutter Flame", "completion": "class MyGame extends Game {\n  SpriteAnimationTicker a;\n\n  MyGame() {\n    a = SpriteAnimationTicker(SpriteAnimation(...));\n  }\n\n  void update(double dt) {\n    a.update(dt);\n  }\n\n  void render(Canvas c) {\n    a.getSprite().render(c);\n  }\n}"}
{"prompt": "Write Flutter Flame code to Animation¶: Example:", "completion": "class MyGame extends Game {\n  SpriteAnimationTicker a;\n\n  MyGame() {\n    a = SpriteAnimationTicker(SpriteAnimation(...));\n  }\n\n  void update(double dt) {\n    a.update(dt);\n  }\n\n  void render(Canvas c) {\n    a.getSprite().render(c);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Animation¶: A better alternative to generate a list of sprites is to use the fromFrameData constructor:", "completion": "const amountOfFrames = 8;\nfinal a = SpriteAnimation.fromFrameData(\n    imageInstance,\n    SpriteAnimationFrame.sequenced(\n      amount: amountOfFrames,\n      textureSize: Vector2(16.0, 16.0),\n      stepTime: 0.1,\n    ),\n);"}
{"prompt": "Show me how to implement Animation¶: A better alternative to generate a list of sprites is to use the fromFrameData constructor: using Flutter Flame", "completion": "const amountOfFrames = 8;\nfinal a = SpriteAnimation.fromFrameData(\n    imageInstance,\n    SpriteAnimationFrame.sequenced(\n      amount: amountOfFrames,\n      textureSize: Vector2(16.0, 16.0),\n      stepTime: 0.1,\n    ),\n);"}
{"prompt": "Write Flutter Flame code to Animation¶: A better alternative to generate a list of sprites is to use the fromFrameData constructor:", "completion": "const amountOfFrames = 8;\nfinal a = SpriteAnimation.fromFrameData(\n    imageInstance,\n    SpriteAnimationFrame.sequenced(\n      amount: amountOfFrames,\n      textureSize: Vector2(16.0, 16.0),\n      stepTime: 0.1,\n    ),\n);"}
{"prompt": "Create a Flutter Flame game component that SpriteSheet¶: Sprite sheets are big images with several frames of the same sprite on it and is a very good way to organize and store your animations. Flame provides a very simple utility class to deal with SpriteSheets, using which you can load your sprite sheet image and extract animations from it as well. Following is a simple example of how to use it:", "completion": "import 'package:flame/sprite.dart';\n\nfinal spriteSheet = SpriteSheet(\n  image: imageInstance,\n  srcSize: Vector2.all(16.0),\n);\n\nfinal animation = spriteSheet.createAnimation(0, stepTime: 0.1);"}
{"prompt": "Show me how to implement SpriteSheet¶: Sprite sheets are big images with several frames of the same sprite on it and is a very good way to organize and store your animations. Flame provides a very simple utility class to deal with SpriteSheets, using which you can load your sprite sheet image and extract animations from it as well. Following is a simple example of how to use it: using Flutter Flame", "completion": "import 'package:flame/sprite.dart';\n\nfinal spriteSheet = SpriteSheet(\n  image: imageInstance,\n  srcSize: Vector2.all(16.0),\n);\n\nfinal animation = spriteSheet.createAnimation(0, stepTime: 0.1);"}
{"prompt": "Write Flutter Flame code to SpriteSheet¶: Sprite sheets are big images with several frames of the same sprite on it and is a very good way to organize and store your animations. Flame provides a very simple utility class to deal with SpriteSheets, using which you can load your sprite sheet image and extract animations from it as well. Following is a simple example of how to use it:", "completion": "import 'package:flame/sprite.dart';\n\nfinal spriteSheet = SpriteSheet(\n  image: imageInstance,\n  srcSize: Vector2.all(16.0),\n);\n\nfinal animation = spriteSheet.createAnimation(0, stepTime: 0.1);"}
{"prompt": "Create a Flutter Flame game component that Loading Assets¶: For Ember to be displayed, we will need to load the assets. This can be done in main.dart, but by so doing, we will quickly clutter the file. To keep our game organized, we should create files that have a single focus. So let’s create a file in the lib folder called ember_quest.dart. In that file, we will add:", "completion": "import 'package:flame/game.dart';\n\nclass EmberQuestGame extends FlameGame {\n  EmberQuestGame();\n\n  @override\n  Future<void> onLoad() async {\n    await images.loadAll([\n      'block.png',\n      'ember.png',\n      'ground.png',\n      'heart_half.png',\n      'heart.png',\n      'star.png',\n      'water_enemy.png',\n    ]);\n\n  }\n}"}
{"prompt": "Show me how to implement Loading Assets¶: For Ember to be displayed, we will need to load the assets. This can be done in main.dart, but by so doing, we will quickly clutter the file. To keep our game organized, we should create files that have a single focus. So let’s create a file in the lib folder called ember_quest.dart. In that file, we will add: using Flutter Flame", "completion": "import 'package:flame/game.dart';\n\nclass EmberQuestGame extends FlameGame {\n  EmberQuestGame();\n\n  @override\n  Future<void> onLoad() async {\n    await images.loadAll([\n      'block.png',\n      'ember.png',\n      'ground.png',\n      'heart_half.png',\n      'heart.png',\n      'star.png',\n      'water_enemy.png',\n    ]);\n\n  }\n}"}
{"prompt": "Write Flutter Flame code to Loading Assets¶: For Ember to be displayed, we will need to load the assets. This can be done in main.dart, but by so doing, we will quickly clutter the file. To keep our game organized, we should create files that have a single focus. So let’s create a file in the lib folder called ember_quest.dart. In that file, we will add:", "completion": "import 'package:flame/game.dart';\n\nclass EmberQuestGame extends FlameGame {\n  EmberQuestGame();\n\n  @override\n  Future<void> onLoad() async {\n    await images.loadAll([\n      'block.png',\n      'ember.png',\n      'ground.png',\n      'heart_half.png',\n      'heart.png',\n      'star.png',\n      'water_enemy.png',\n    ]);\n\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Scaffolding¶: So now that we have our game file, let’s prepare the main.dart file to receive our newly created FlameGame. Change your entire main.dart file to the following:", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/material.dart';\n\nimport 'ember_quest.dart';\n\nvoid main() {\n  runApp(\n    const GameWidget<EmberQuestGame>.controlled(\n      gameFactory: EmberQuestGame.new,\n    ),\n  );\n}"}
{"prompt": "Show me how to implement Scaffolding¶: So now that we have our game file, let’s prepare the main.dart file to receive our newly created FlameGame. Change your entire main.dart file to the following: using Flutter Flame", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/material.dart';\n\nimport 'ember_quest.dart';\n\nvoid main() {\n  runApp(\n    const GameWidget<EmberQuestGame>.controlled(\n      gameFactory: EmberQuestGame.new,\n    ),\n  );\n}"}
{"prompt": "Write Flutter Flame code to Scaffolding¶: So now that we have our game file, let’s prepare the main.dart file to receive our newly created FlameGame. Change your entire main.dart file to the following:", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/material.dart';\n\nimport 'ember_quest.dart';\n\nvoid main() {\n  runApp(\n    const GameWidget<EmberQuestGame>.controlled(\n      gameFactory: EmberQuestGame.new,\n    ),\n  );\n}"}
{"prompt": "Create a Flutter Flame game component that CameraComponent and World¶: To move around in the world we are going the use the built-in CameraComponent and World that exists on the FlameGame class. We are going to add all our components to the world and follow the player with the camera.", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/game.dart';\n\nclass EmberQuestGame extends FlameGame {\n  @override\n  Future<void> onLoad() async {\n    await images.loadAll([\n      'block.png',\n      'ember.png',\n      'ground.png',\n      'heart_half.png',\n      'heart.png',\n      'star.png',\n      'water_enemy.png',\n    ]);\n\n    // Everything in this tutorial assumes that the position\n    // of the `CameraComponent`s viewfinder (where the camera is looking)\n    // is in the top left corner, that's why we set the anchor here.\n    camera.viewfinder.anchor = Anchor.topLeft;\n  }\n}"}
{"prompt": "Show me how to implement CameraComponent and World¶: To move around in the world we are going the use the built-in CameraComponent and World that exists on the FlameGame class. We are going to add all our components to the world and follow the player with the camera. using Flutter Flame", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/game.dart';\n\nclass EmberQuestGame extends FlameGame {\n  @override\n  Future<void> onLoad() async {\n    await images.loadAll([\n      'block.png',\n      'ember.png',\n      'ground.png',\n      'heart_half.png',\n      'heart.png',\n      'star.png',\n      'water_enemy.png',\n    ]);\n\n    // Everything in this tutorial assumes that the position\n    // of the `CameraComponent`s viewfinder (where the camera is looking)\n    // is in the top left corner, that's why we set the anchor here.\n    camera.viewfinder.anchor = Anchor.topLeft;\n  }\n}"}
{"prompt": "Write Flutter Flame code to CameraComponent and World¶: To move around in the world we are going the use the built-in CameraComponent and World that exists on the FlameGame class. We are going to add all our components to the world and follow the player with the camera.", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/game.dart';\n\nclass EmberQuestGame extends FlameGame {\n  @override\n  Future<void> onLoad() async {\n    await images.loadAll([\n      'block.png',\n      'ember.png',\n      'ground.png',\n      'heart_half.png',\n      'heart.png',\n      'star.png',\n      'water_enemy.png',\n    ]);\n\n    // Everything in this tutorial assumes that the position\n    // of the `CameraComponent`s viewfinder (where the camera is looking)\n    // is in the top left corner, that's why we set the anchor here.\n    camera.viewfinder.anchor = Anchor.topLeft;\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Ember Time¶: Keeping your game files organized can always be a challenge. I like to keep things logically organized by how they will be involved in my game. So for Ember, let’s create the following folder, lib/actors and in that folder, create ember.dart. In that file, add the following code:", "completion": "import 'package:flame/components.dart';\n\nimport '../ember_quest.dart';\n\nclass EmberPlayer extends SpriteAnimationComponent\n    with HasGameReference<EmberQuestGame> {\n  EmberPlayer({\n    required super.position,\n  }) : super(size: Vector2.all(64), anchor: Anchor.center);\n\n  @override\n  void onLoad() {\n    animation = SpriteAnimation.fromFrameData(\n      game.images.fromCache('ember.png'),\n      SpriteAnimationData.sequenced(\n        amount: 4,\n        textureSize: Vector2.all(16),\n        stepTime: 0.12,\n      ),\n    );\n  }\n}"}
{"prompt": "Show me how to implement Ember Time¶: Keeping your game files organized can always be a challenge. I like to keep things logically organized by how they will be involved in my game. So for Ember, let’s create the following folder, lib/actors and in that folder, create ember.dart. In that file, add the following code: using Flutter Flame", "completion": "import 'package:flame/components.dart';\n\nimport '../ember_quest.dart';\n\nclass EmberPlayer extends SpriteAnimationComponent\n    with HasGameReference<EmberQuestGame> {\n  EmberPlayer({\n    required super.position,\n  }) : super(size: Vector2.all(64), anchor: Anchor.center);\n\n  @override\n  void onLoad() {\n    animation = SpriteAnimation.fromFrameData(\n      game.images.fromCache('ember.png'),\n      SpriteAnimationData.sequenced(\n        amount: 4,\n        textureSize: Vector2.all(16),\n        stepTime: 0.12,\n      ),\n    );\n  }\n}"}
{"prompt": "Write Flutter Flame code to Ember Time¶: Keeping your game files organized can always be a challenge. I like to keep things logically organized by how they will be involved in my game. So for Ember, let’s create the following folder, lib/actors and in that folder, create ember.dart. In that file, add the following code:", "completion": "import 'package:flame/components.dart';\n\nimport '../ember_quest.dart';\n\nclass EmberPlayer extends SpriteAnimationComponent\n    with HasGameReference<EmberQuestGame> {\n  EmberPlayer({\n    required super.position,\n  }) : super(size: Vector2.all(64), anchor: Anchor.center);\n\n  @override\n  void onLoad() {\n    animation = SpriteAnimation.fromFrameData(\n      game.images.fromCache('ember.png'),\n      SpriteAnimationData.sequenced(\n        amount: 4,\n        textureSize: Vector2.all(16),\n        stepTime: 0.12,\n      ),\n    );\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Ember Time¶: Now before you rush to run the game again, we have to add Ember to the game world. To do this, go back to ember_quest.dart and add the following:", "completion": "import 'package:flame/game.dart';\n\nimport 'actors/ember.dart';\n\nclass EmberQuestGame extends FlameGame {\n  late EmberPlayer _ember;\n  \n  @override\n  Future<void> onLoad() async {\n    await images.loadAll([\n      'block.png',\n      'ember.png',\n      'ground.png',\n      'heart_half.png',\n      'heart.png',\n      'star.png',\n      'water_enemy.png',\n    ]);\n\n    camera.viewfinder.anchor = Anchor.topLeft;\n    \n    _ember = EmberPlayer(\n      position: Vector2(128, canvasSize.y - 70),\n    );\n    world.add(_ember);\n  }\n}"}
{"prompt": "Show me how to implement Ember Time¶: Now before you rush to run the game again, we have to add Ember to the game world. To do this, go back to ember_quest.dart and add the following: using Flutter Flame", "completion": "import 'package:flame/game.dart';\n\nimport 'actors/ember.dart';\n\nclass EmberQuestGame extends FlameGame {\n  late EmberPlayer _ember;\n  \n  @override\n  Future<void> onLoad() async {\n    await images.loadAll([\n      'block.png',\n      'ember.png',\n      'ground.png',\n      'heart_half.png',\n      'heart.png',\n      'star.png',\n      'water_enemy.png',\n    ]);\n\n    camera.viewfinder.anchor = Anchor.topLeft;\n    \n    _ember = EmberPlayer(\n      position: Vector2(128, canvasSize.y - 70),\n    );\n    world.add(_ember);\n  }\n}"}
{"prompt": "Write Flutter Flame code to Ember Time¶: Now before you rush to run the game again, we have to add Ember to the game world. To do this, go back to ember_quest.dart and add the following:", "completion": "import 'package:flame/game.dart';\n\nimport 'actors/ember.dart';\n\nclass EmberQuestGame extends FlameGame {\n  late EmberPlayer _ember;\n  \n  @override\n  Future<void> onLoad() async {\n    await images.loadAll([\n      'block.png',\n      'ember.png',\n      'ground.png',\n      'heart_half.png',\n      'heart.png',\n      'star.png',\n      'water_enemy.png',\n    ]);\n\n    camera.viewfinder.anchor = Anchor.topLeft;\n    \n    _ember = EmberPlayer(\n      position: Vector2(128, canvasSize.y - 70),\n    );\n    world.add(_ember);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Adding Enemies¶: First, let’s create an Enemy class that will represent the enemies in game:", "completion": "class Enemy extends SpriteAnimationComponent\n    with HasGameReference<SpaceShooterGame> {\n\n  Enemy({\n    super.position,\n  }) : super(\n          size: Vector2.all(enemySize),\n          anchor: Anchor.center,\n        );\n\n\n  static const enemySize = 50.0;\n\n  @override\n  Future<void> onLoad() async {\n    await super.onLoad();\n\n    animation = await game.loadSpriteAnimation(\n      'enemy.png',\n      SpriteAnimationData.sequenced(\n        amount: 4,\n        stepTime: .2,\n        textureSize: Vector2.all(16),\n      ),\n    );\n  }\n\n  @override\n  void update(double dt) {\n    super.update(dt);\n\n    position.y += dt * 250;\n\n    if (position.y > game.size.y) {\n      removeFromParent();\n    }\n  }\n}"}
{"prompt": "Show me how to implement Adding Enemies¶: First, let’s create an Enemy class that will represent the enemies in game: using Flutter Flame", "completion": "class Enemy extends SpriteAnimationComponent\n    with HasGameReference<SpaceShooterGame> {\n\n  Enemy({\n    super.position,\n  }) : super(\n          size: Vector2.all(enemySize),\n          anchor: Anchor.center,\n        );\n\n\n  static const enemySize = 50.0;\n\n  @override\n  Future<void> onLoad() async {\n    await super.onLoad();\n\n    animation = await game.loadSpriteAnimation(\n      'enemy.png',\n      SpriteAnimationData.sequenced(\n        amount: 4,\n        stepTime: .2,\n        textureSize: Vector2.all(16),\n      ),\n    );\n  }\n\n  @override\n  void update(double dt) {\n    super.update(dt);\n\n    position.y += dt * 250;\n\n    if (position.y > game.size.y) {\n      removeFromParent();\n    }\n  }\n}"}
{"prompt": "Write Flutter Flame code to Adding Enemies¶: First, let’s create an Enemy class that will represent the enemies in game:", "completion": "class Enemy extends SpriteAnimationComponent\n    with HasGameReference<SpaceShooterGame> {\n\n  Enemy({\n    super.position,\n  }) : super(\n          size: Vector2.all(enemySize),\n          anchor: Anchor.center,\n        );\n\n\n  static const enemySize = 50.0;\n\n  @override\n  Future<void> onLoad() async {\n    await super.onLoad();\n\n    animation = await game.loadSpriteAnimation(\n      'enemy.png',\n      SpriteAnimationData.sequenced(\n        amount: 4,\n        stepTime: .2,\n        textureSize: Vector2.all(16),\n      ),\n    );\n  }\n\n  @override\n  void update(double dt) {\n    super.update(dt);\n\n    position.y += dt * 250;\n\n    if (position.y > game.size.y) {\n      removeFromParent();\n    }\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Adding Enemies¶: Once again, we could manually add all the time based events in the game’s update() method, maintain a random instance to get the enemy x position and so on and so forth, but Flame provides us with a way to avoid having to write all that by ourselves: we can use the SpawnComponent! So in the SpaceShooterGame.onLoad() method let’s add the following code:", "completion": "add(\n      SpawnComponent(\n        factory: (index) {\n          return Enemy();\n        },\n        period: 1,\n        area: Rectangle.fromLTWH(0, 0, size.x, -Enemy.enemySize),\n      ),\n    );"}
{"prompt": "Show me how to implement Adding Enemies¶: Once again, we could manually add all the time based events in the game’s update() method, maintain a random instance to get the enemy x position and so on and so forth, but Flame provides us with a way to avoid having to write all that by ourselves: we can use the SpawnComponent! So in the SpaceShooterGame.onLoad() method let’s add the following code: using Flutter Flame", "completion": "add(\n      SpawnComponent(\n        factory: (index) {\n          return Enemy();\n        },\n        period: 1,\n        area: Rectangle.fromLTWH(0, 0, size.x, -Enemy.enemySize),\n      ),\n    );"}
{"prompt": "Write Flutter Flame code to Adding Enemies¶: Once again, we could manually add all the time based events in the game’s update() method, maintain a random instance to get the enemy x position and so on and so forth, but Flame provides us with a way to avoid having to write all that by ourselves: we can use the SpawnComponent! So in the SpaceShooterGame.onLoad() method let’s add the following code:", "completion": "add(\n      SpawnComponent(\n        factory: (index) {\n          return Enemy();\n        },\n        period: 1,\n        area: Rectangle.fromLTWH(0, 0, size.x, -Enemy.enemySize),\n      ),\n    );"}
{"prompt": "Create a Flutter Flame game component that Adding Enemies¶: And this concludes this short step!", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/experimental.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/input.dart';\nimport 'package:flame/parallax.dart';\nimport 'package:flutter/material.dart';\n\nvoid main() {\nrunApp(GameWidget(game: SpaceShooterGame()));\n}\n\nclass SpaceShooterGame extends FlameGame with PanDetector {\nlate Player player;\n\n@override\nFuture<void> onLoad() async {\nfinal parallax = await loadParallaxComponent(\n[\nParallaxImageData('stars_0.png'),\nParallaxImageData('stars_1.png'),\nParallaxImageData('stars_2.png'),\n],\nbaseVelocity: Vector2(0, -5),\nrepeat: ImageRepeat.repeat,\nvelocityMultiplierDelta: Vector2(0, 5),\n);\nadd(parallax);\n\nplayer = Player();\nadd(player);\n\nadd(\nSpawnComponent(\nfactory: (index) {\nreturn Enemy();\n},\nperiod: 1,\narea: Rectangle.fromLTWH(0, 0, size.x, -Enemy.enemySize),\n),\n);\n}\n\n@override\nvoid onPanUpdate(DragUpdateInfo info) {\nplayer.move(info.delta.global);\n}\n\n@override\nvoid onPanStart(DragStartInfo info) {\nplayer.startShooting();\n}\n\n@override\nvoid onPanEnd(DragEndInfo info) {\nplayer.stopShooting();\n}\n}\n\nclass Player extends SpriteAnimationComponent\nwith HasGameReference<SpaceShooterGame> {\nPlayer()\n: super(\nsize: Vector2(100, 150),\nanchor: Anchor.center,\n);\n\nlate final SpawnComponent _bulletSpawner;\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nanimation = await game.loadSpriteAnimation(\n'player.png',\nSpriteAnimationData.sequenced(\namount: 4,\nstepTime: 0.2,\ntextureSize: Vector2(32, 48),\n),\n);\n\nposition = game.size / 2;\n\n_bulletSpawner = SpawnComponent(\nperiod: 0.2,\nselfPositioning: true,\nfactory: (index) {\nreturn Bullet(\nposition: position +\nVector2(\n0,\n-height / 2,\n),\n);\n},\nautoStart: false,\n);\n\ngame.add(_bulletSpawner);\n}\n\nvoid move(Vector2 delta) {\nposition.add(delta);\n}\n\nvoid startShooting() {\n_bulletSpawner.timer.start();\n}\n\nvoid stopShooting() {\n_bulletSpawner.timer.stop();\n}\n}\n\nclass Bullet extends SpriteAnimationComponent\nwith HasGameReference<SpaceShooterGame> {\nBullet({\nsuper.position,\n}) : super(\nsize: Vector2(25, 50),\nanchor: Anchor.center,\n);\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nanimation = await game.loadSpriteAnimation(\n'bullet.png',\nSpriteAnimationData.sequenced(\namount: 4,\nstepTime: 0.2,\ntextureSize: Vector2(8, 16),\n),\n);\n}\n\n@override\nvoid update(double dt) {\nsuper.update(dt);\n\nposition.y += dt * -500;\n\nif (position.y < -height) {\nremoveFromParent();\n}\n}\n}\n\nclass Enemy extends SpriteAnimationComponent\nwith HasGameReference<SpaceShooterGame> {\nEnemy({\nsuper.position,\n}) : super(\nsize: Vector2.all(enemySize),\nanchor: Anchor.center,\n);\n\nstatic const enemySize = 50.0;\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nanimation = await game.loadSpriteAnimation(\n'enemy.png',\nSpriteAnimationData.sequenced(\namount: 4,\nstepTime: 0.2,\ntextureSize: Vector2.all(16),\n),\n);\n}\n\n@override\nvoid update(double dt) {\nsuper.update(dt);\n\nposition.y += dt * 250;\n\nif (position.y > game.size.y) {\nremoveFromParent();\n}\n}\n}"}
{"prompt": "Show me how to implement Adding Enemies¶: And this concludes this short step! using Flutter Flame", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/experimental.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/input.dart';\nimport 'package:flame/parallax.dart';\nimport 'package:flutter/material.dart';\n\nvoid main() {\nrunApp(GameWidget(game: SpaceShooterGame()));\n}\n\nclass SpaceShooterGame extends FlameGame with PanDetector {\nlate Player player;\n\n@override\nFuture<void> onLoad() async {\nfinal parallax = await loadParallaxComponent(\n[\nParallaxImageData('stars_0.png'),\nParallaxImageData('stars_1.png'),\nParallaxImageData('stars_2.png'),\n],\nbaseVelocity: Vector2(0, -5),\nrepeat: ImageRepeat.repeat,\nvelocityMultiplierDelta: Vector2(0, 5),\n);\nadd(parallax);\n\nplayer = Player();\nadd(player);\n\nadd(\nSpawnComponent(\nfactory: (index) {\nreturn Enemy();\n},\nperiod: 1,\narea: Rectangle.fromLTWH(0, 0, size.x, -Enemy.enemySize),\n),\n);\n}\n\n@override\nvoid onPanUpdate(DragUpdateInfo info) {\nplayer.move(info.delta.global);\n}\n\n@override\nvoid onPanStart(DragStartInfo info) {\nplayer.startShooting();\n}\n\n@override\nvoid onPanEnd(DragEndInfo info) {\nplayer.stopShooting();\n}\n}\n\nclass Player extends SpriteAnimationComponent\nwith HasGameReference<SpaceShooterGame> {\nPlayer()\n: super(\nsize: Vector2(100, 150),\nanchor: Anchor.center,\n);\n\nlate final SpawnComponent _bulletSpawner;\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nanimation = await game.loadSpriteAnimation(\n'player.png',\nSpriteAnimationData.sequenced(\namount: 4,\nstepTime: 0.2,\ntextureSize: Vector2(32, 48),\n),\n);\n\nposition = game.size / 2;\n\n_bulletSpawner = SpawnComponent(\nperiod: 0.2,\nselfPositioning: true,\nfactory: (index) {\nreturn Bullet(\nposition: position +\nVector2(\n0,\n-height / 2,\n),\n);\n},\nautoStart: false,\n);\n\ngame.add(_bulletSpawner);\n}\n\nvoid move(Vector2 delta) {\nposition.add(delta);\n}\n\nvoid startShooting() {\n_bulletSpawner.timer.start();\n}\n\nvoid stopShooting() {\n_bulletSpawner.timer.stop();\n}\n}\n\nclass Bullet extends SpriteAnimationComponent\nwith HasGameReference<SpaceShooterGame> {\nBullet({\nsuper.position,\n}) : super(\nsize: Vector2(25, 50),\nanchor: Anchor.center,\n);\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nanimation = await game.loadSpriteAnimation(\n'bullet.png',\nSpriteAnimationData.sequenced(\namount: 4,\nstepTime: 0.2,\ntextureSize: Vector2(8, 16),\n),\n);\n}\n\n@override\nvoid update(double dt) {\nsuper.update(dt);\n\nposition.y += dt * -500;\n\nif (position.y < -height) {\nremoveFromParent();\n}\n}\n}\n\nclass Enemy extends SpriteAnimationComponent\nwith HasGameReference<SpaceShooterGame> {\nEnemy({\nsuper.position,\n}) : super(\nsize: Vector2.all(enemySize),\nanchor: Anchor.center,\n);\n\nstatic const enemySize = 50.0;\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nanimation = await game.loadSpriteAnimation(\n'enemy.png',\nSpriteAnimationData.sequenced(\namount: 4,\nstepTime: 0.2,\ntextureSize: Vector2.all(16),\n),\n);\n}\n\n@override\nvoid update(double dt) {\nsuper.update(dt);\n\nposition.y += dt * 250;\n\nif (position.y > game.size.y) {\nremoveFromParent();\n}\n}\n}"}
{"prompt": "Write Flutter Flame code to Adding Enemies¶: And this concludes this short step!", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/experimental.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/input.dart';\nimport 'package:flame/parallax.dart';\nimport 'package:flutter/material.dart';\n\nvoid main() {\nrunApp(GameWidget(game: SpaceShooterGame()));\n}\n\nclass SpaceShooterGame extends FlameGame with PanDetector {\nlate Player player;\n\n@override\nFuture<void> onLoad() async {\nfinal parallax = await loadParallaxComponent(\n[\nParallaxImageData('stars_0.png'),\nParallaxImageData('stars_1.png'),\nParallaxImageData('stars_2.png'),\n],\nbaseVelocity: Vector2(0, -5),\nrepeat: ImageRepeat.repeat,\nvelocityMultiplierDelta: Vector2(0, 5),\n);\nadd(parallax);\n\nplayer = Player();\nadd(player);\n\nadd(\nSpawnComponent(\nfactory: (index) {\nreturn Enemy();\n},\nperiod: 1,\narea: Rectangle.fromLTWH(0, 0, size.x, -Enemy.enemySize),\n),\n);\n}\n\n@override\nvoid onPanUpdate(DragUpdateInfo info) {\nplayer.move(info.delta.global);\n}\n\n@override\nvoid onPanStart(DragStartInfo info) {\nplayer.startShooting();\n}\n\n@override\nvoid onPanEnd(DragEndInfo info) {\nplayer.stopShooting();\n}\n}\n\nclass Player extends SpriteAnimationComponent\nwith HasGameReference<SpaceShooterGame> {\nPlayer()\n: super(\nsize: Vector2(100, 150),\nanchor: Anchor.center,\n);\n\nlate final SpawnComponent _bulletSpawner;\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nanimation = await game.loadSpriteAnimation(\n'player.png',\nSpriteAnimationData.sequenced(\namount: 4,\nstepTime: 0.2,\ntextureSize: Vector2(32, 48),\n),\n);\n\nposition = game.size / 2;\n\n_bulletSpawner = SpawnComponent(\nperiod: 0.2,\nselfPositioning: true,\nfactory: (index) {\nreturn Bullet(\nposition: position +\nVector2(\n0,\n-height / 2,\n),\n);\n},\nautoStart: false,\n);\n\ngame.add(_bulletSpawner);\n}\n\nvoid move(Vector2 delta) {\nposition.add(delta);\n}\n\nvoid startShooting() {\n_bulletSpawner.timer.start();\n}\n\nvoid stopShooting() {\n_bulletSpawner.timer.stop();\n}\n}\n\nclass Bullet extends SpriteAnimationComponent\nwith HasGameReference<SpaceShooterGame> {\nBullet({\nsuper.position,\n}) : super(\nsize: Vector2(25, 50),\nanchor: Anchor.center,\n);\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nanimation = await game.loadSpriteAnimation(\n'bullet.png',\nSpriteAnimationData.sequenced(\namount: 4,\nstepTime: 0.2,\ntextureSize: Vector2(8, 16),\n),\n);\n}\n\n@override\nvoid update(double dt) {\nsuper.update(dt);\n\nposition.y += dt * -500;\n\nif (position.y < -height) {\nremoveFromParent();\n}\n}\n}\n\nclass Enemy extends SpriteAnimationComponent\nwith HasGameReference<SpaceShooterGame> {\nEnemy({\nsuper.position,\n}) : super(\nsize: Vector2.all(enemySize),\nanchor: Anchor.center,\n);\n\nstatic const enemySize = 50.0;\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nanimation = await game.loadSpriteAnimation(\n'enemy.png',\nSpriteAnimationData.sequenced(\namount: 4,\nstepTime: 0.2,\ntextureSize: Vector2.all(16),\n),\n);\n}\n\n@override\nvoid update(double dt) {\nsuper.update(dt);\n\nposition.y += dt * 250;\n\nif (position.y > game.size.y) {\nremoveFromParent();\n}\n}\n}"}
{"prompt": "Create a Flutter Flame game component that Palette¶: In the Material Flutter package there is a Colors class that provides common colors as constants:", "completion": "import 'package:flutter/material.dart' show Colors;\n\nconst black = Colors.black;"}
{"prompt": "Show me how to implement Palette¶: In the Material Flutter package there is a Colors class that provides common colors as constants: using Flutter Flame", "completion": "import 'package:flutter/material.dart' show Colors;\n\nconst black = Colors.black;"}
{"prompt": "Write Flutter Flame code to Palette¶: In the Material Flutter package there is a Colors class that provides common colors as constants:", "completion": "import 'package:flutter/material.dart' show Colors;\n\nconst black = Colors.black;"}
{"prompt": "Create a Flutter Flame game component that Palette¶: However, the idea is that you can create your own palette, following the BasicPalette example, and add the color palette/scheme of your game. Then you will be able to statically access any color in your components and classes. Below is an example of a Palette implementation, from the example game BGUG:", "completion": "import 'dart:ui';\n\nimport 'package:flame/palette.dart';\n\nclass Palette {\n  static PaletteEntry white = BasicPalette.white;\n\n  static PaletteEntry toastBackground = PaletteEntry(Color(0xFFAC3232));\n  static PaletteEntry toastText = PaletteEntry(Color(0xFFDA9A00));\n\n  static PaletteEntry grey = PaletteEntry(Color(0xFF404040));\n  static PaletteEntry green = PaletteEntry(Color(0xFF54a286));\n}"}
{"prompt": "Show me how to implement Palette¶: However, the idea is that you can create your own palette, following the BasicPalette example, and add the color palette/scheme of your game. Then you will be able to statically access any color in your components and classes. Below is an example of a Palette implementation, from the example game BGUG: using Flutter Flame", "completion": "import 'dart:ui';\n\nimport 'package:flame/palette.dart';\n\nclass Palette {\n  static PaletteEntry white = BasicPalette.white;\n\n  static PaletteEntry toastBackground = PaletteEntry(Color(0xFFAC3232));\n  static PaletteEntry toastText = PaletteEntry(Color(0xFFDA9A00));\n\n  static PaletteEntry grey = PaletteEntry(Color(0xFF404040));\n  static PaletteEntry green = PaletteEntry(Color(0xFF54a286));\n}"}
{"prompt": "Write Flutter Flame code to Palette¶: However, the idea is that you can create your own palette, following the BasicPalette example, and add the color palette/scheme of your game. Then you will be able to statically access any color in your components and classes. Below is an example of a Palette implementation, from the example game BGUG:", "completion": "import 'dart:ui';\n\nimport 'package:flame/palette.dart';\n\nclass Palette {\n  static PaletteEntry white = BasicPalette.white;\n\n  static PaletteEntry toastBackground = PaletteEntry(Color(0xFFAC3232));\n  static PaletteEntry toastText = PaletteEntry(Color(0xFFDA9A00));\n\n  static PaletteEntry grey = PaletteEntry(Color(0xFF404040));\n  static PaletteEntry green = PaletteEntry(Color(0xFF54a286));\n}"}
{"prompt": "Create a Flutter Flame game component that TextComponent¶: Simple usage:", "completion": "class MyGame extends FlameGame {\n  @override\n  void onLoad() {\n    add(\n      TextComponent(\n        text: 'Hello, Flame',\n        position: Vector2.all(16.0),\n      ),\n    );\n  }\n}"}
{"prompt": "Show me how to implement TextComponent¶: Simple usage: using Flutter Flame", "completion": "class MyGame extends FlameGame {\n  @override\n  void onLoad() {\n    add(\n      TextComponent(\n        text: 'Hello, Flame',\n        position: Vector2.all(16.0),\n      ),\n    );\n  }\n}"}
{"prompt": "Write Flutter Flame code to TextComponent¶: Simple usage:", "completion": "class MyGame extends FlameGame {\n  @override\n  void onLoad() {\n    add(\n      TextComponent(\n        text: 'Hello, Flame',\n        position: Vector2.all(16.0),\n      ),\n    );\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that TextComponent¶: In order to configure aspects of the rendering like font family, size, color, etc, you need to provide (or amend) a TextRenderer with such information; while you can read more details about this interface below, the simplest implementation you can use is the TextPaint, which takes a Flutter TextStyle:", "completion": "final regular = TextPaint(\n  style: TextStyle(\n    fontSize: 48.0,\n    color: BasicPalette.white.color,\n  ),\n);\n\nclass MyGame extends FlameGame {\n  @override\n  void onLoad() {\n    add(\n      TextComponent(\n        text: 'Hello, Flame',\n        textRenderer: regular,\n        anchor: Anchor.topCenter,\n        position: Vector2(size.width / 2, 32.0),\n      ),\n    );\n  }\n}"}
{"prompt": "Show me how to implement TextComponent¶: In order to configure aspects of the rendering like font family, size, color, etc, you need to provide (or amend) a TextRenderer with such information; while you can read more details about this interface below, the simplest implementation you can use is the TextPaint, which takes a Flutter TextStyle: using Flutter Flame", "completion": "final regular = TextPaint(\n  style: TextStyle(\n    fontSize: 48.0,\n    color: BasicPalette.white.color,\n  ),\n);\n\nclass MyGame extends FlameGame {\n  @override\n  void onLoad() {\n    add(\n      TextComponent(\n        text: 'Hello, Flame',\n        textRenderer: regular,\n        anchor: Anchor.topCenter,\n        position: Vector2(size.width / 2, 32.0),\n      ),\n    );\n  }\n}"}
{"prompt": "Write Flutter Flame code to TextComponent¶: In order to configure aspects of the rendering like font family, size, color, etc, you need to provide (or amend) a TextRenderer with such information; while you can read more details about this interface below, the simplest implementation you can use is the TextPaint, which takes a Flutter TextStyle:", "completion": "final regular = TextPaint(\n  style: TextStyle(\n    fontSize: 48.0,\n    color: BasicPalette.white.color,\n  ),\n);\n\nclass MyGame extends FlameGame {\n  @override\n  void onLoad() {\n    add(\n      TextComponent(\n        text: 'Hello, Flame',\n        textRenderer: regular,\n        anchor: Anchor.topCenter,\n        position: Vector2(size.width / 2, 32.0),\n      ),\n    );\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that TextBoxComponent¶: Example usage:", "completion": "class MyTextBox extends TextBoxComponent {\n  MyTextBox(String text) : super(\n    text: text,\n    textRenderer: tiny,\n    boxConfig: TextBoxConfig(timePerChar: 0.05),\n  );\n\n  final bgPaint = Paint()..color = Color(0xFFFF00FF);\n  final borderPaint = Paint()..color = Color(0xFF000000)..style = PaintingStyle.stroke;\n\n  @override\n  void render(Canvas canvas) {\n    Rect rect = Rect.fromLTWH(0, 0, width, height);\n    canvas.drawRect(rect, bgPaint);\n    canvas.drawRect(rect.deflate(boxConfig.margin), borderPaint);\n    super.render(canvas);\n  }\n}"}
{"prompt": "Show me how to implement TextBoxComponent¶: Example usage: using Flutter Flame", "completion": "class MyTextBox extends TextBoxComponent {\n  MyTextBox(String text) : super(\n    text: text,\n    textRenderer: tiny,\n    boxConfig: TextBoxConfig(timePerChar: 0.05),\n  );\n\n  final bgPaint = Paint()..color = Color(0xFFFF00FF);\n  final borderPaint = Paint()..color = Color(0xFF000000)..style = PaintingStyle.stroke;\n\n  @override\n  void render(Canvas canvas) {\n    Rect rect = Rect.fromLTWH(0, 0, width, height);\n    canvas.drawRect(rect, bgPaint);\n    canvas.drawRect(rect.deflate(boxConfig.margin), borderPaint);\n    super.render(canvas);\n  }\n}"}
{"prompt": "Write Flutter Flame code to TextBoxComponent¶: Example usage:", "completion": "class MyTextBox extends TextBoxComponent {\n  MyTextBox(String text) : super(\n    text: text,\n    textRenderer: tiny,\n    boxConfig: TextBoxConfig(timePerChar: 0.05),\n  );\n\n  final bgPaint = Paint()..color = Color(0xFFFF00FF);\n  final borderPaint = Paint()..color = Color(0xFF000000)..style = PaintingStyle.stroke;\n\n  @override\n  void render(Canvas canvas) {\n    Rect rect = Rect.fromLTWH(0, 0, width, height);\n    canvas.drawRect(rect, bgPaint);\n    canvas.drawRect(rect.deflate(boxConfig.margin), borderPaint);\n    super.render(canvas);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that ScrollTextBoxComponent¶: Example usage:", "completion": "class MyScrollableText extends ScrollTextBoxComponent {\n  MyScrollableText(Vector2 frameSize, String text) : super(\n    size: frameSize,\n    text: text,\n    textRenderer: regular, \n    boxConfig: TextBoxConfig(timePerChar: 0.05),\n  );\n}"}
{"prompt": "Show me how to implement ScrollTextBoxComponent¶: Example usage: using Flutter Flame", "completion": "class MyScrollableText extends ScrollTextBoxComponent {\n  MyScrollableText(Vector2 frameSize, String text) : super(\n    size: frameSize,\n    text: text,\n    textRenderer: regular, \n    boxConfig: TextBoxConfig(timePerChar: 0.05),\n  );\n}"}
{"prompt": "Write Flutter Flame code to ScrollTextBoxComponent¶: Example usage:", "completion": "class MyScrollableText extends ScrollTextBoxComponent {\n  MyScrollableText(Vector2 frameSize, String text) : super(\n    size: frameSize,\n    text: text,\n    textRenderer: regular, \n    boxConfig: TextBoxConfig(timePerChar: 0.05),\n  );\n}"}
{"prompt": "Create a Flutter Flame game component that TextElementComponent¶: A simple example is to create a DocumentRoot to render a sequence of block elements (think of an HTML “div”) containing rich text:", "completion": "final document = DocumentRoot([\n    HeaderNode.simple('1984', level: 1),\n    ParagraphNode.simple(\n      'Anything could be true. The so-called laws of nature were nonsense.',\n    ),\n    // ...\n  ]);\n  final element = TextElementComponent.fromDocument(\n    document: document,\n    position: Vector2(100, 50),\n    size: Vector2(400, 200),\n  );"}
{"prompt": "Show me how to implement TextElementComponent¶: A simple example is to create a DocumentRoot to render a sequence of block elements (think of an HTML “div”) containing rich text: using Flutter Flame", "completion": "final document = DocumentRoot([\n    HeaderNode.simple('1984', level: 1),\n    ParagraphNode.simple(\n      'Anything could be true. The so-called laws of nature were nonsense.',\n    ),\n    // ...\n  ]);\n  final element = TextElementComponent.fromDocument(\n    document: document,\n    position: Vector2(100, 50),\n    size: Vector2(400, 200),\n  );"}
{"prompt": "Write Flutter Flame code to TextElementComponent¶: A simple example is to create a DocumentRoot to render a sequence of block elements (think of an HTML “div”) containing rich text:", "completion": "final document = DocumentRoot([\n    HeaderNode.simple('1984', level: 1),\n    ParagraphNode.simple(\n      'Anything could be true. The so-called laws of nature were nonsense.',\n    ),\n    // ...\n  ]);\n  final element = TextElementComponent.fromDocument(\n    document: document,\n    position: Vector2(100, 50),\n    size: Vector2(400, 200),\n  );"}
{"prompt": "Create a Flutter Flame game component that TextElementComponent¶: An example applying a style to the document (which can include the size but other parameters as well):", "completion": "final style = DocumentStyle(\n    width: 400,\n    height: 200,\n    padding: const EdgeInsets.symmetric(vertical: 10, horizontal: 14),\n    background: BackgroundStyle(\n      color: const Color(0xFF4E322E),\n      borderColor: const Color(0xFF000000),\n      borderWidth: 2.0,\n    ),\n  );\n  final document = DocumentRoot([ ... ]);\n  final element = TextElementComponent.fromDocument(\n    document: document,\n    style: style,\n    position: Vector2(100, 50),\n  );"}
{"prompt": "Show me how to implement TextElementComponent¶: An example applying a style to the document (which can include the size but other parameters as well): using Flutter Flame", "completion": "final style = DocumentStyle(\n    width: 400,\n    height: 200,\n    padding: const EdgeInsets.symmetric(vertical: 10, horizontal: 14),\n    background: BackgroundStyle(\n      color: const Color(0xFF4E322E),\n      borderColor: const Color(0xFF000000),\n      borderWidth: 2.0,\n    ),\n  );\n  final document = DocumentRoot([ ... ]);\n  final element = TextElementComponent.fromDocument(\n    document: document,\n    style: style,\n    position: Vector2(100, 50),\n  );"}
{"prompt": "Write Flutter Flame code to TextElementComponent¶: An example applying a style to the document (which can include the size but other parameters as well):", "completion": "final style = DocumentStyle(\n    width: 400,\n    height: 200,\n    padding: const EdgeInsets.symmetric(vertical: 10, horizontal: 14),\n    background: BackgroundStyle(\n      color: const Color(0xFF4E322E),\n      borderColor: const Color(0xFF000000),\n      borderWidth: 2.0,\n    ),\n  );\n  final document = DocumentRoot([ ... ]);\n  final element = TextElementComponent.fromDocument(\n    document: document,\n    style: style,\n    position: Vector2(100, 50),\n  );"}
{"prompt": "Create a Flutter Flame game component that Flame Markdown¶: Just use the FlameMarkdown helper class and the toDocument method to convert a markdown string into a DocumentRoot (which can then be used to create a TextElementComponent):", "completion": "import 'package:flame/text.dart';\nimport 'package:flame_markdown/flame_markdown.dart';\n\n// ...\nfinal component = await TextElementComponent.fromDocument(\n  document: FlameMarkdown.toDocument(\n    '# Header\\n'\n    '\\n'\n    'This is a **bold** text, and this is *italic*.\\n'\n    '\\n'\n    'This is a second paragraph.\\n',\n  ),\n  style: ...,\n  position: ...,\n  size: ...,\n);"}
{"prompt": "Show me how to implement Flame Markdown¶: Just use the FlameMarkdown helper class and the toDocument method to convert a markdown string into a DocumentRoot (which can then be used to create a TextElementComponent): using Flutter Flame", "completion": "import 'package:flame/text.dart';\nimport 'package:flame_markdown/flame_markdown.dart';\n\n// ...\nfinal component = await TextElementComponent.fromDocument(\n  document: FlameMarkdown.toDocument(\n    '# Header\\n'\n    '\\n'\n    'This is a **bold** text, and this is *italic*.\\n'\n    '\\n'\n    'This is a second paragraph.\\n',\n  ),\n  style: ...,\n  position: ...,\n  size: ...,\n);"}
{"prompt": "Write Flutter Flame code to Flame Markdown¶: Just use the FlameMarkdown helper class and the toDocument method to convert a markdown string into a DocumentRoot (which can then be used to create a TextElementComponent):", "completion": "import 'package:flame/text.dart';\nimport 'package:flame_markdown/flame_markdown.dart';\n\n// ...\nfinal component = await TextElementComponent.fromDocument(\n  document: FlameMarkdown.toDocument(\n    '# Header\\n'\n    '\\n'\n    'This is a **bold** text, and this is *italic*.\\n'\n    '\\n'\n    'This is a second paragraph.\\n',\n  ),\n  style: ...,\n  position: ...,\n  size: ...,\n);"}
{"prompt": "Create a Flutter Flame game component that TextRenderer¶: However the renderer provides a helper method to directly create the element and render it:", "completion": "textRenderer.render(\n  canvas,\n  'Flame is awesome',\n  Vector2(10, 10),\n  anchor: Anchor.topCenter,\n);"}
{"prompt": "Show me how to implement TextRenderer¶: However the renderer provides a helper method to directly create the element and render it: using Flutter Flame", "completion": "textRenderer.render(\n  canvas,\n  'Flame is awesome',\n  Vector2(10, 10),\n  anchor: Anchor.topCenter,\n);"}
{"prompt": "Write Flutter Flame code to TextRenderer¶: However the renderer provides a helper method to directly create the element and render it:", "completion": "textRenderer.render(\n  canvas,\n  'Flame is awesome',\n  Vector2(10, 10),\n  anchor: Anchor.topCenter,\n);"}
{"prompt": "Create a Flutter Flame game component that Inline Text Elements¶: These methods are intended to be overwritten by the implementations of InlineTextElement, and probably will not be called directly by users; because a convenient render method is provided:", "completion": "void render(\n    Canvas canvas,\n    Vector2 position, {\n    Anchor anchor = Anchor.topLeft,\n  })"}
{"prompt": "Show me how to implement Inline Text Elements¶: These methods are intended to be overwritten by the implementations of InlineTextElement, and probably will not be called directly by users; because a convenient render method is provided: using Flutter Flame", "completion": "void render(\n    Canvas canvas,\n    Vector2 position, {\n    Anchor anchor = Anchor.topLeft,\n  })"}
{"prompt": "Write Flutter Flame code to Inline Text Elements¶: These methods are intended to be overwritten by the implementations of InlineTextElement, and probably will not be called directly by users; because a convenient render method is provided:", "completion": "void render(\n    Canvas canvas,\n    Vector2 position, {\n    Anchor anchor = Anchor.topLeft,\n  })"}
{"prompt": "Create a Flutter Flame game component that Component¶: Example:", "completion": "void main() {\n  final component1 = Component(children: [Component(), Component()]);\n  final component2 = Component();\n  component2.add(Component());\n  component2.addAll([Component(), Component()]);\n}"}
{"prompt": "Show me how to implement Component¶: Example: using Flutter Flame", "completion": "void main() {\n  final component1 = Component(children: [Component(), Component()]);\n  final component2 = Component();\n  component2.add(Component());\n  component2.addAll([Component(), Component()]);\n}"}
{"prompt": "Write Flutter Flame code to Component¶: Example:", "completion": "void main() {\n  final component1 = Component(children: [Component(), Component()]);\n  final component2 = Component();\n  component2.add(Component());\n  component2.addAll([Component(), Component()]);\n}"}
{"prompt": "Create a Flutter Flame game component that Priority¶: Example:", "completion": "class MyGame extends FlameGame {\n  @override\n  void onLoad() {\n    final myComponent = PositionComponent(priority: 5);\n    add(myComponent);\n  }\n}"}
{"prompt": "Show me how to implement Priority¶: Example: using Flutter Flame", "completion": "class MyGame extends FlameGame {\n  @override\n  void onLoad() {\n    final myComponent = PositionComponent(priority: 5);\n    add(myComponent);\n  }\n}"}
{"prompt": "Write Flutter Flame code to Priority¶: Example:", "completion": "class MyGame extends FlameGame {\n  @override\n  void onLoad() {\n    final myComponent = PositionComponent(priority: 5);\n    add(myComponent);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Priority¶: In the following example we first initialize the component with priority 1, and then when the user taps the component we change its priority to 2:", "completion": "class MyComponent extends PositionComponent with TapCallbacks {\n\n  MyComponent() : super(priority: 1);\n\n  @override\n  void onTapDown(TapDownEvent event) {\n    priority = 2;\n  }\n}"}
{"prompt": "Show me how to implement Priority¶: In the following example we first initialize the component with priority 1, and then when the user taps the component we change its priority to 2: using Flutter Flame", "completion": "class MyComponent extends PositionComponent with TapCallbacks {\n\n  MyComponent() : super(priority: 1);\n\n  @override\n  void onTapDown(TapDownEvent event) {\n    priority = 2;\n  }\n}"}
{"prompt": "Write Flutter Flame code to Priority¶: In the following example we first initialize the component with priority 1, and then when the user taps the component we change its priority to 2:", "completion": "class MyComponent extends PositionComponent with TapCallbacks {\n\n  MyComponent() : super(priority: 1);\n\n  @override\n  void onTapDown(TapDownEvent event) {\n    priority = 2;\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Composability of components¶: Example of usage, where visibility of two components are handled by a wrapper:", "completion": "class GameOverPanel extends PositionComponent {\n  bool visible = false;\n  final Image spriteImage;\n\n  GameOverPanel(this.spriteImage);\n\n  @override\n  void onLoad() {\n    final gameOverText = GameOverText(spriteImage); // GameOverText is a Component\n    final gameOverButton = GameOverButton(spriteImage); // GameOverRestart is a SpriteComponent\n\n    add(gameOverText);\n    add(gameOverButton);\n  }\n\n  @override\n  void render(Canvas canvas) {\n    if (visible) {\n    } // If not visible none of the children will be rendered\n  }\n}"}
{"prompt": "Show me how to implement Composability of components¶: Example of usage, where visibility of two components are handled by a wrapper: using Flutter Flame", "completion": "class GameOverPanel extends PositionComponent {\n  bool visible = false;\n  final Image spriteImage;\n\n  GameOverPanel(this.spriteImage);\n\n  @override\n  void onLoad() {\n    final gameOverText = GameOverText(spriteImage); // GameOverText is a Component\n    final gameOverButton = GameOverButton(spriteImage); // GameOverRestart is a SpriteComponent\n\n    add(gameOverText);\n    add(gameOverButton);\n  }\n\n  @override\n  void render(Canvas canvas) {\n    if (visible) {\n    } // If not visible none of the children will be rendered\n  }\n}"}
{"prompt": "Write Flutter Flame code to Composability of components¶: Example of usage, where visibility of two components are handled by a wrapper:", "completion": "class GameOverPanel extends PositionComponent {\n  bool visible = false;\n  final Image spriteImage;\n\n  GameOverPanel(this.spriteImage);\n\n  @override\n  void onLoad() {\n    final gameOverText = GameOverText(spriteImage); // GameOverText is a Component\n    final gameOverButton = GameOverButton(spriteImage); // GameOverRestart is a SpriteComponent\n\n    add(gameOverText);\n    add(gameOverButton);\n  }\n\n  @override\n  void render(Canvas canvas) {\n    if (visible) {\n    } // If not visible none of the children will be rendered\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Composability of components¶: The second method is to use the children: parameter in the component’s constructor. This approach more closely resembles the standard Flutter API:", "completion": "class MyGame extends FlameGame {\n  @override\n  void onLoad() {\n    add(\n      PositionComponent(\n        position: Vector2(30, 0),\n        children: [\n          HighScoreDisplay(),\n          HitPointsDisplay(),\n          FpsComponent(),\n        ],\n      ),\n    );\n  }\n}"}
{"prompt": "Show me how to implement Composability of components¶: The second method is to use the children: parameter in the component’s constructor. This approach more closely resembles the standard Flutter API: using Flutter Flame", "completion": "class MyGame extends FlameGame {\n  @override\n  void onLoad() {\n    add(\n      PositionComponent(\n        position: Vector2(30, 0),\n        children: [\n          HighScoreDisplay(),\n          HitPointsDisplay(),\n          FpsComponent(),\n        ],\n      ),\n    );\n  }\n}"}
{"prompt": "Write Flutter Flame code to Composability of components¶: The second method is to use the children: parameter in the component’s constructor. This approach more closely resembles the standard Flutter API:", "completion": "class MyGame extends FlameGame {\n  @override\n  void onLoad() {\n    add(\n      PositionComponent(\n        position: Vector2(30, 0),\n        children: [\n          HighScoreDisplay(),\n          HitPointsDisplay(),\n          FpsComponent(),\n        ],\n      ),\n    );\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Access to the World from a Component¶: Example:", "completion": "class MyComponent extends Component with HasWorldReference<MyWorld>,\n    TapCallbacks {\n  @override\n  void onTapDown(TapDownEvent info) {\n    // world is of type MyWorld\n    world.add(AnotherComponent());\n  }\n}"}
{"prompt": "Show me how to implement Access to the World from a Component¶: Example: using Flutter Flame", "completion": "class MyComponent extends Component with HasWorldReference<MyWorld>,\n    TapCallbacks {\n  @override\n  void onTapDown(TapDownEvent info) {\n    // world is of type MyWorld\n    world.add(AnotherComponent());\n  }\n}"}
{"prompt": "Write Flutter Flame code to Access to the World from a Component¶: Example:", "completion": "class MyComponent extends Component with HasWorldReference<MyWorld>,\n    TapCallbacks {\n  @override\n  void onTapDown(TapDownEvent info) {\n    // world is of type MyWorld\n    world.add(AnotherComponent());\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Ensuring a component has a given parent¶: Example:", "completion": "class MyComponent extends Component with ParentIsA<MyParentComponent> {\n  @override\n  void onLoad() {\n    // parent is of type MyParentComponent\n    print(parent.myValue);\n  }\n}"}
{"prompt": "Show me how to implement Ensuring a component has a given parent¶: Example: using Flutter Flame", "completion": "class MyComponent extends Component with ParentIsA<MyParentComponent> {\n  @override\n  void onLoad() {\n    // parent is of type MyParentComponent\n    print(parent.myValue);\n  }\n}"}
{"prompt": "Write Flutter Flame code to Ensuring a component has a given parent¶: Example:", "completion": "class MyComponent extends Component with ParentIsA<MyParentComponent> {\n  @override\n  void onLoad() {\n    // parent is of type MyParentComponent\n    print(parent.myValue);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Ensuring a component has a given ancestor¶: Example:", "completion": "class MyComponent extends Component with HasAncestor<MyAncestorComponent> {\n  @override\n  void onLoad() {\n    // ancestor is of type MyAncestorComponent.\n    print(ancestor.myValue);\n  }\n}"}
{"prompt": "Show me how to implement Ensuring a component has a given ancestor¶: Example: using Flutter Flame", "completion": "class MyComponent extends Component with HasAncestor<MyAncestorComponent> {\n  @override\n  void onLoad() {\n    // ancestor is of type MyAncestorComponent.\n    print(ancestor.myValue);\n  }\n}"}
{"prompt": "Write Flutter Flame code to Ensuring a component has a given ancestor¶: Example:", "completion": "class MyComponent extends Component with HasAncestor<MyAncestorComponent> {\n  @override\n  void onLoad() {\n    // ancestor is of type MyAncestorComponent.\n    print(ancestor.myValue);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Component Keys¶: To register a component with a key, simply pass a key to the key argument on the component’s constructor:", "completion": "final myComponent = Component(\n  key: ComponentKey.named('player'),\n);"}
{"prompt": "Show me how to implement Component Keys¶: To register a component with a key, simply pass a key to the key argument on the component’s constructor: using Flutter Flame", "completion": "final myComponent = Component(\n  key: ComponentKey.named('player'),\n);"}
{"prompt": "Write Flutter Flame code to Component Keys¶: To register a component with a key, simply pass a key to the key argument on the component’s constructor:", "completion": "final myComponent = Component(\n  key: ComponentKey.named('player'),\n);"}
{"prompt": "Create a Flutter Flame game component that Component Keys¶: There are two types of keys, unique and named. Unique keys are based on equality of the key instance, meaning that:", "completion": "final key = ComponentKey.unique();\nfinal key2 = key;\nprint(key == key2); // true\nprint(key == ComponentKey.unique()); // false"}
{"prompt": "Show me how to implement Component Keys¶: There are two types of keys, unique and named. Unique keys are based on equality of the key instance, meaning that: using Flutter Flame", "completion": "final key = ComponentKey.unique();\nfinal key2 = key;\nprint(key == key2); // true\nprint(key == ComponentKey.unique()); // false"}
{"prompt": "Write Flutter Flame code to Component Keys¶: There are two types of keys, unique and named. Unique keys are based on equality of the key instance, meaning that:", "completion": "final key = ComponentKey.unique();\nfinal key2 = key;\nprint(key == key2); // true\nprint(key == ComponentKey.unique()); // false"}
{"prompt": "Create a Flutter Flame game component that Component Keys¶: Named ones are based on the name that it receives, so:", "completion": "final key1 = ComponentKey.named('player');\nfinal key2 = ComponentKey.named('player');\nprint(key1 == key2); // true"}
{"prompt": "Show me how to implement Component Keys¶: Named ones are based on the name that it receives, so: using Flutter Flame", "completion": "final key1 = ComponentKey.named('player');\nfinal key2 = ComponentKey.named('player');\nprint(key1 == key2); // true"}
{"prompt": "Write Flutter Flame code to Component Keys¶: Named ones are based on the name that it receives, so:", "completion": "final key1 = ComponentKey.named('player');\nfinal key2 = ComponentKey.named('player');\nprint(key1 == key2); // true"}
{"prompt": "Create a Flutter Flame game component that Querying child components¶: Example:", "completion": "@override\nvoid onLoad() {\n  children.register<PositionComponent>();\n}"}
{"prompt": "Show me how to implement Querying child components¶: Example: using Flutter Flame", "completion": "@override\nvoid onLoad() {\n  children.register<PositionComponent>();\n}"}
{"prompt": "Write Flutter Flame code to Querying child components¶: Example:", "completion": "@override\nvoid onLoad() {\n  children.register<PositionComponent>();\n}"}
{"prompt": "Create a Flutter Flame game component that Querying child components¶: In the example above a query is registered for PositionComponents, and an example of how to query the registered component type can be seen below.", "completion": "@override\nvoid update(double dt) {\n  final allPositionComponents = children.query<PositionComponent>();\n}"}
{"prompt": "Show me how to implement Querying child components¶: In the example above a query is registered for PositionComponents, and an example of how to query the registered component type can be seen below. using Flutter Flame", "completion": "@override\nvoid update(double dt) {\n  final allPositionComponents = children.query<PositionComponent>();\n}"}
{"prompt": "Write Flutter Flame code to Querying child components¶: In the example above a query is registered for PositionComponents, and an example of how to query the registered component type can be seen below.", "completion": "@override\nvoid update(double dt) {\n  final allPositionComponents = children.query<PositionComponent>();\n}"}
{"prompt": "Create a Flutter Flame game component that Visibility of components¶: However, adding and removing components from the tree will trigger lifecycle steps for that component (such as calling onRemove and onMount). It is also an asynchronous process and care needs to be taken to ensure the component has finished removing before it is added again if you are removing and adding a component in quick succession.", "completion": "/// Example of handling the removal and adding of a child component\n/// in quick succession\nvoid show() async {\n  // Need to await the [removed] future first, just in case the\n  // component is still in the process of being removed.\n  await myChildComponent.removed;\n  add(myChildComponent);\n}\n\nvoid hide() {\n  remove(myChildComponent);\n}"}
{"prompt": "Show me how to implement Visibility of components¶: However, adding and removing components from the tree will trigger lifecycle steps for that component (such as calling onRemove and onMount). It is also an asynchronous process and care needs to be taken to ensure the component has finished removing before it is added again if you are removing and adding a component in quick succession. using Flutter Flame", "completion": "/// Example of handling the removal and adding of a child component\n/// in quick succession\nvoid show() async {\n  // Need to await the [removed] future first, just in case the\n  // component is still in the process of being removed.\n  await myChildComponent.removed;\n  add(myChildComponent);\n}\n\nvoid hide() {\n  remove(myChildComponent);\n}"}
{"prompt": "Write Flutter Flame code to Visibility of components¶: However, adding and removing components from the tree will trigger lifecycle steps for that component (such as calling onRemove and onMount). It is also an asynchronous process and care needs to be taken to ensure the component has finished removing before it is added again if you are removing and adding a component in quick succession.", "completion": "/// Example of handling the removal and adding of a child component\n/// in quick succession\nvoid show() async {\n  // Need to await the [removed] future first, just in case the\n  // component is still in the process of being removed.\n  await myChildComponent.removed;\n  add(myChildComponent);\n}\n\nvoid hide() {\n  remove(myChildComponent);\n}"}
{"prompt": "Create a Flutter Flame game component that Visibility of components¶: An alternative method to show and hide a component is to use the HasVisibility mixin, which may be used on any class that inherits from Component. This mixin introduces the isVisible property. Simply set isVisible to false to hide the component, and true to show it again, without removing it from the tree. This affects the visibility of the component and all it’s descendants (children).", "completion": "/// Example that implements HasVisibility\nclass MyComponent extends PositionComponent with HasVisibility {}\n\n/// Usage of the isVisible property\nfinal myComponent = MyComponent();\nadd(myComponent);\n\nmyComponent.isVisible = false;"}
{"prompt": "Show me how to implement Visibility of components¶: An alternative method to show and hide a component is to use the HasVisibility mixin, which may be used on any class that inherits from Component. This mixin introduces the isVisible property. Simply set isVisible to false to hide the component, and true to show it again, without removing it from the tree. This affects the visibility of the component and all it’s descendants (children). using Flutter Flame", "completion": "/// Example that implements HasVisibility\nclass MyComponent extends PositionComponent with HasVisibility {}\n\n/// Usage of the isVisible property\nfinal myComponent = MyComponent();\nadd(myComponent);\n\nmyComponent.isVisible = false;"}
{"prompt": "Write Flutter Flame code to Visibility of components¶: An alternative method to show and hide a component is to use the HasVisibility mixin, which may be used on any class that inherits from Component. This mixin introduces the isVisible property. Simply set isVisible to false to hide the component, and true to show it again, without removing it from the tree. This affects the visibility of the component and all it’s descendants (children).", "completion": "/// Example that implements HasVisibility\nclass MyComponent extends PositionComponent with HasVisibility {}\n\n/// Usage of the isVisible property\nfinal myComponent = MyComponent();\nadd(myComponent);\n\nmyComponent.isVisible = false;"}
{"prompt": "Create a Flutter Flame game component that Visibility of components¶: The mixin works by preventing the renderTree method, therefore if renderTree is being overridden, a manual check for isVisible should be included to retain this functionality.", "completion": "class MyComponent extends PositionComponent with HasVisibility {\n\n  @override\n  void renderTree(Canvas canvas) {\n    // Check for visibility\n    if (isVisible) {\n      // Custom code here\n\n      // Continue rendering the tree\n      super.renderTree(canvas);\n    }\n  }\n}"}
{"prompt": "Show me how to implement Visibility of components¶: The mixin works by preventing the renderTree method, therefore if renderTree is being overridden, a manual check for isVisible should be included to retain this functionality. using Flutter Flame", "completion": "class MyComponent extends PositionComponent with HasVisibility {\n\n  @override\n  void renderTree(Canvas canvas) {\n    // Check for visibility\n    if (isVisible) {\n      // Custom code here\n\n      // Continue rendering the tree\n      super.renderTree(canvas);\n    }\n  }\n}"}
{"prompt": "Write Flutter Flame code to Visibility of components¶: The mixin works by preventing the renderTree method, therefore if renderTree is being overridden, a manual check for isVisible should be included to retain this functionality.", "completion": "class MyComponent extends PositionComponent with HasVisibility {\n\n  @override\n  void renderTree(Canvas canvas) {\n    // Check for visibility\n    if (isVisible) {\n      // Custom code here\n\n      // Continue rendering the tree\n      super.renderTree(canvas);\n    }\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Anchor¶: 90", "completion": "import 'dart:async';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/palette.dart';\n\nclass AnchorGame extends FlameGame {\nfinal _parentAnchorText = TextComponent(position: Vector2.all(5));\nfinal _childAnchorText = TextComponent(position: Vector2(5, 30));\n\nlate _AnchoredRectangle _redComponent;\nlate _AnchoredRectangle _blueComponent;\n\n@override\nFuture<void> onLoad() async {\n_redComponent = _AnchoredRectangle(\nsize: size / 4,\nposition: size / 2,\npaint: BasicPalette.red.paint(),\n);\n\n_blueComponent = _AnchoredRectangle(\nsize: size / 8,\npaint: BasicPalette.blue.paint(),\n);\n\nawait _redComponent.addAll([\n_blueComponent,\nCircleComponent(radius: 2, anchor: Anchor.center),\n]);\n\nawait addAll([\n_redComponent,\n_parentAnchorText,\n_childAnchorText,\nCircleComponent(\nradius: 4,\nposition: size / 2,\nanchor: Anchor.center,\n),\n]);\n}\n\n@override\nvoid update(double dt) {\n_parentAnchorText.text = 'Parent: ${_redComponent.anchor}';\n_childAnchorText.text = 'Child: ${_blueComponent.anchor}';\nsuper.update(dt);\n}\n}\n\nclass _AnchoredRectangle extends RectangleComponent with TapCallbacks {\n_AnchoredRectangle({\nsuper.position,\nsuper.size,\nsuper.paint,\n});\n\n@override\nvoid onTapDown(TapDownEvent event) {\nvar index = Anchor.values.indexOf(anchor) + 1;\nif (index == Anchor.values.length) {\nindex = 0;\n}\nanchor = Anchor.values.elementAt(index);\nsuper.onTapDown(event);\n}\n}"}
{"prompt": "Show me how to implement Anchor¶: 90 using Flutter Flame", "completion": "import 'dart:async';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/palette.dart';\n\nclass AnchorGame extends FlameGame {\nfinal _parentAnchorText = TextComponent(position: Vector2.all(5));\nfinal _childAnchorText = TextComponent(position: Vector2(5, 30));\n\nlate _AnchoredRectangle _redComponent;\nlate _AnchoredRectangle _blueComponent;\n\n@override\nFuture<void> onLoad() async {\n_redComponent = _AnchoredRectangle(\nsize: size / 4,\nposition: size / 2,\npaint: BasicPalette.red.paint(),\n);\n\n_blueComponent = _AnchoredRectangle(\nsize: size / 8,\npaint: BasicPalette.blue.paint(),\n);\n\nawait _redComponent.addAll([\n_blueComponent,\nCircleComponent(radius: 2, anchor: Anchor.center),\n]);\n\nawait addAll([\n_redComponent,\n_parentAnchorText,\n_childAnchorText,\nCircleComponent(\nradius: 4,\nposition: size / 2,\nanchor: Anchor.center,\n),\n]);\n}\n\n@override\nvoid update(double dt) {\n_parentAnchorText.text = 'Parent: ${_redComponent.anchor}';\n_childAnchorText.text = 'Child: ${_blueComponent.anchor}';\nsuper.update(dt);\n}\n}\n\nclass _AnchoredRectangle extends RectangleComponent with TapCallbacks {\n_AnchoredRectangle({\nsuper.position,\nsuper.size,\nsuper.paint,\n});\n\n@override\nvoid onTapDown(TapDownEvent event) {\nvar index = Anchor.values.indexOf(anchor) + 1;\nif (index == Anchor.values.length) {\nindex = 0;\n}\nanchor = Anchor.values.elementAt(index);\nsuper.onTapDown(event);\n}\n}"}
{"prompt": "Write Flutter Flame code to Anchor¶: 90", "completion": "import 'dart:async';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/palette.dart';\n\nclass AnchorGame extends FlameGame {\nfinal _parentAnchorText = TextComponent(position: Vector2.all(5));\nfinal _childAnchorText = TextComponent(position: Vector2(5, 30));\n\nlate _AnchoredRectangle _redComponent;\nlate _AnchoredRectangle _blueComponent;\n\n@override\nFuture<void> onLoad() async {\n_redComponent = _AnchoredRectangle(\nsize: size / 4,\nposition: size / 2,\npaint: BasicPalette.red.paint(),\n);\n\n_blueComponent = _AnchoredRectangle(\nsize: size / 8,\npaint: BasicPalette.blue.paint(),\n);\n\nawait _redComponent.addAll([\n_blueComponent,\nCircleComponent(radius: 2, anchor: Anchor.center),\n]);\n\nawait addAll([\n_redComponent,\n_parentAnchorText,\n_childAnchorText,\nCircleComponent(\nradius: 4,\nposition: size / 2,\nanchor: Anchor.center,\n),\n]);\n}\n\n@override\nvoid update(double dt) {\n_parentAnchorText.text = 'Parent: ${_redComponent.anchor}';\n_childAnchorText.text = 'Child: ${_blueComponent.anchor}';\nsuper.update(dt);\n}\n}\n\nclass _AnchoredRectangle extends RectangleComponent with TapCallbacks {\n_AnchoredRectangle({\nsuper.position,\nsuper.size,\nsuper.paint,\n});\n\n@override\nvoid onTapDown(TapDownEvent event) {\nvar index = Anchor.values.indexOf(anchor) + 1;\nif (index == Anchor.values.length) {\nindex = 0;\n}\nanchor = Anchor.values.elementAt(index);\nsuper.onTapDown(event);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that Anchor¶: When position or absolutePosition of a component is queried, the returned coordinates are that of the anchor of the component. In case if you want to find the position of a specific anchor point of a component which is not actually the anchor of that component, you can use the positionOfAnchor and absolutePositionOfAnchor method.", "completion": "final comp = PositionComponent(\n  size: Vector2.all(20),\n  anchor: Anchor.center,\n);\n\n// Returns (0,0)\nfinal p1 = component.position;\n\n// Returns (10, 10)\nfinal p2 = component.positionOfAnchor(Anchor.bottomRight);"}
{"prompt": "Show me how to implement Anchor¶: When position or absolutePosition of a component is queried, the returned coordinates are that of the anchor of the component. In case if you want to find the position of a specific anchor point of a component which is not actually the anchor of that component, you can use the positionOfAnchor and absolutePositionOfAnchor method. using Flutter Flame", "completion": "final comp = PositionComponent(\n  size: Vector2.all(20),\n  anchor: Anchor.center,\n);\n\n// Returns (0,0)\nfinal p1 = component.position;\n\n// Returns (10, 10)\nfinal p2 = component.positionOfAnchor(Anchor.bottomRight);"}
{"prompt": "Write Flutter Flame code to Anchor¶: When position or absolutePosition of a component is queried, the returned coordinates are that of the anchor of the component. In case if you want to find the position of a specific anchor point of a component which is not actually the anchor of that component, you can use the positionOfAnchor and absolutePositionOfAnchor method.", "completion": "final comp = PositionComponent(\n  size: Vector2.all(20),\n  anchor: Anchor.center,\n);\n\n// Returns (0,0)\nfinal p1 = component.position;\n\n// Returns (10, 10)\nfinal p2 = component.positionOfAnchor(Anchor.bottomRight);"}
{"prompt": "Create a Flutter Flame game component that PositionComponent children¶: All children of the PositionComponent will be transformed in relation to the parent, which means that the position, angle and scale will be relative to the parents state. So if you, for example, wanted to position a child in the center of the parent you would do this:", "completion": "@override\nvoid onLoad() {\n  final parent = PositionComponent(\n    position: Vector2(100, 100),\n    size: Vector2(100, 100),\n  );\n  final child = PositionComponent(\n    position: parent.size / 2,\n    anchor: Anchor.center,\n  );\n  parent.add(child);\n}"}
{"prompt": "Show me how to implement PositionComponent children¶: All children of the PositionComponent will be transformed in relation to the parent, which means that the position, angle and scale will be relative to the parents state. So if you, for example, wanted to position a child in the center of the parent you would do this: using Flutter Flame", "completion": "@override\nvoid onLoad() {\n  final parent = PositionComponent(\n    position: Vector2(100, 100),\n    size: Vector2(100, 100),\n  );\n  final child = PositionComponent(\n    position: parent.size / 2,\n    anchor: Anchor.center,\n  );\n  parent.add(child);\n}"}
{"prompt": "Write Flutter Flame code to PositionComponent children¶: All children of the PositionComponent will be transformed in relation to the parent, which means that the position, angle and scale will be relative to the parents state. So if you, for example, wanted to position a child in the center of the parent you would do this:", "completion": "@override\nvoid onLoad() {\n  final parent = PositionComponent(\n    position: Vector2(100, 100),\n    size: Vector2(100, 100),\n  );\n  final child = PositionComponent(\n    position: parent.size / 2,\n    anchor: Anchor.center,\n  );\n  parent.add(child);\n}"}
{"prompt": "Create a Flutter Flame game component that SpriteComponent¶: The most commonly used implementation of PositionComponent is SpriteComponent, and it can be created with a Sprite:", "completion": "import 'package:flame/components/component.dart';\n\nclass MyGame extends FlameGame {\n  late final SpriteComponent player;\n\n  @override\n  Future<void> onLoad() async {\n    final sprite = await Sprite.load('player.png');\n    final size = Vector2.all(128.0);\n    final player = SpriteComponent(size: size, sprite: sprite);\n\n    // Vector2(0.0, 0.0) by default, can also be set in the constructor\n    player.position = Vector2(10, 20);\n\n    // 0 by default, can also be set in the constructor\n    player.angle = 0;\n\n    // Adds the component\n    add(player);\n  }\n}"}
{"prompt": "Show me how to implement SpriteComponent¶: The most commonly used implementation of PositionComponent is SpriteComponent, and it can be created with a Sprite: using Flutter Flame", "completion": "import 'package:flame/components/component.dart';\n\nclass MyGame extends FlameGame {\n  late final SpriteComponent player;\n\n  @override\n  Future<void> onLoad() async {\n    final sprite = await Sprite.load('player.png');\n    final size = Vector2.all(128.0);\n    final player = SpriteComponent(size: size, sprite: sprite);\n\n    // Vector2(0.0, 0.0) by default, can also be set in the constructor\n    player.position = Vector2(10, 20);\n\n    // 0 by default, can also be set in the constructor\n    player.angle = 0;\n\n    // Adds the component\n    add(player);\n  }\n}"}
{"prompt": "Write Flutter Flame code to SpriteComponent¶: The most commonly used implementation of PositionComponent is SpriteComponent, and it can be created with a Sprite:", "completion": "import 'package:flame/components/component.dart';\n\nclass MyGame extends FlameGame {\n  late final SpriteComponent player;\n\n  @override\n  Future<void> onLoad() async {\n    final sprite = await Sprite.load('player.png');\n    final size = Vector2.all(128.0);\n    final player = SpriteComponent(size: size, sprite: sprite);\n\n    // Vector2(0.0, 0.0) by default, can also be set in the constructor\n    player.position = Vector2(10, 20);\n\n    // 0 by default, can also be set in the constructor\n    player.angle = 0;\n\n    // Adds the component\n    add(player);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that SpriteAnimationComponent¶: This will create a simple three frame animation using 3 different images:", "completion": "@override\nFuture<void> onLoad() async {\n  final sprites = [0, 1, 2]\n      .map((i) => Sprite.load('player_$i.png'));\n  final animation = SpriteAnimation.spriteList(\n    await Future.wait(sprites),\n    stepTime: 0.01,\n  );\n  this.player = SpriteAnimationComponent(\n    animation: animation,\n    size: Vector2.all(64.0),\n  );\n}"}
{"prompt": "Show me how to implement SpriteAnimationComponent¶: This will create a simple three frame animation using 3 different images: using Flutter Flame", "completion": "@override\nFuture<void> onLoad() async {\n  final sprites = [0, 1, 2]\n      .map((i) => Sprite.load('player_$i.png'));\n  final animation = SpriteAnimation.spriteList(\n    await Future.wait(sprites),\n    stepTime: 0.01,\n  );\n  this.player = SpriteAnimationComponent(\n    animation: animation,\n    size: Vector2.all(64.0),\n  );\n}"}
{"prompt": "Write Flutter Flame code to SpriteAnimationComponent¶: This will create a simple three frame animation using 3 different images:", "completion": "@override\nFuture<void> onLoad() async {\n  final sprites = [0, 1, 2]\n      .map((i) => Sprite.load('player_$i.png'));\n  final animation = SpriteAnimation.spriteList(\n    await Future.wait(sprites),\n    stepTime: 0.01,\n  );\n  this.player = SpriteAnimationComponent(\n    animation: animation,\n    size: Vector2.all(64.0),\n  );\n}"}
{"prompt": "Create a Flutter Flame game component that SpriteAnimationComponent¶: If you have a sprite sheet, you can use the sequenced constructor from the SpriteAnimationData class (check more details on Images > Animation):", "completion": "@override\nFuture<void> onLoad() async {\n  final size = Vector2.all(64.0);\n  final data = SpriteAnimationData.sequenced(\n    textureSize: size,\n    amount: 2,\n    stepTime: 0.1,\n  );\n  this.player = SpriteAnimationComponent.fromFrameData(\n    await images.load('player.png'),\n    data,\n  );\n}"}
{"prompt": "Show me how to implement SpriteAnimationComponent¶: If you have a sprite sheet, you can use the sequenced constructor from the SpriteAnimationData class (check more details on Images > Animation): using Flutter Flame", "completion": "@override\nFuture<void> onLoad() async {\n  final size = Vector2.all(64.0);\n  final data = SpriteAnimationData.sequenced(\n    textureSize: size,\n    amount: 2,\n    stepTime: 0.1,\n  );\n  this.player = SpriteAnimationComponent.fromFrameData(\n    await images.load('player.png'),\n    data,\n  );\n}"}
{"prompt": "Write Flutter Flame code to SpriteAnimationComponent¶: If you have a sprite sheet, you can use the sequenced constructor from the SpriteAnimationData class (check more details on Images > Animation):", "completion": "@override\nFuture<void> onLoad() async {\n  final size = Vector2.all(64.0);\n  final data = SpriteAnimationData.sequenced(\n    textureSize: size,\n    amount: 2,\n    stepTime: 0.1,\n  );\n  this.player = SpriteAnimationComponent.fromFrameData(\n    await images.load('player.png'),\n    data,\n  );\n}"}
{"prompt": "Create a Flutter Flame game component that SpriteAnimationGroupComponent¶: Example:", "completion": "enum RobotState {\n  idle,\n  running,\n}\n\nfinal running = await loadSpriteAnimation(/* omitted */);\nfinal idle = await loadSpriteAnimation(/* omitted */);\n\nfinal robot = SpriteAnimationGroupComponent<RobotState>(\n  animations: {\n    RobotState.running: running,\n    RobotState.idle: idle,\n  },\n  current: RobotState.idle,\n);\n\n// Changes current animation to \"running\"\nrobot.current = RobotState.running;"}
{"prompt": "Show me how to implement SpriteAnimationGroupComponent¶: Example: using Flutter Flame", "completion": "enum RobotState {\n  idle,\n  running,\n}\n\nfinal running = await loadSpriteAnimation(/* omitted */);\nfinal idle = await loadSpriteAnimation(/* omitted */);\n\nfinal robot = SpriteAnimationGroupComponent<RobotState>(\n  animations: {\n    RobotState.running: running,\n    RobotState.idle: idle,\n  },\n  current: RobotState.idle,\n);\n\n// Changes current animation to \"running\"\nrobot.current = RobotState.running;"}
{"prompt": "Write Flutter Flame code to SpriteAnimationGroupComponent¶: Example:", "completion": "enum RobotState {\n  idle,\n  running,\n}\n\nfinal running = await loadSpriteAnimation(/* omitted */);\nfinal idle = await loadSpriteAnimation(/* omitted */);\n\nfinal robot = SpriteAnimationGroupComponent<RobotState>(\n  animations: {\n    RobotState.running: running,\n    RobotState.idle: idle,\n  },\n  current: RobotState.idle,\n);\n\n// Changes current animation to \"running\"\nrobot.current = RobotState.running;"}
{"prompt": "Create a Flutter Flame game component that SpriteAnimationGroupComponent¶: Example:", "completion": "enum RobotState { idle, running, jump }\n\nfinal running = await loadSpriteAnimation(/* omitted */);\nfinal idle = await loadSpriteAnimation(/* omitted */);\n\nfinal robot = SpriteAnimationGroupComponent<RobotState>(\n  animations: {\n    RobotState.running: running,\n    RobotState.idle: idle,\n  },\n  current: RobotState.idle,\n);\n\nrobot.animationTickers?[RobotState.running]?.onStart = () {\n  // Do something on start of running animation.\n};\n\nrobot.animationTickers?[RobotState.jump]?.onStart = () {\n  // Do something on start of jump animation.\n};\n\nrobot.animationTickers?[RobotState.jump]?.onComplete = () {\n  // Do something on complete of jump animation.\n};\n\nrobot.animationTickers?[RobotState.idle]?.onFrame = (currentIndex) {\n  // Do something based on current frame index of idle animation.\n};"}
{"prompt": "Show me how to implement SpriteAnimationGroupComponent¶: Example: using Flutter Flame", "completion": "enum RobotState { idle, running, jump }\n\nfinal running = await loadSpriteAnimation(/* omitted */);\nfinal idle = await loadSpriteAnimation(/* omitted */);\n\nfinal robot = SpriteAnimationGroupComponent<RobotState>(\n  animations: {\n    RobotState.running: running,\n    RobotState.idle: idle,\n  },\n  current: RobotState.idle,\n);\n\nrobot.animationTickers?[RobotState.running]?.onStart = () {\n  // Do something on start of running animation.\n};\n\nrobot.animationTickers?[RobotState.jump]?.onStart = () {\n  // Do something on start of jump animation.\n};\n\nrobot.animationTickers?[RobotState.jump]?.onComplete = () {\n  // Do something on complete of jump animation.\n};\n\nrobot.animationTickers?[RobotState.idle]?.onFrame = (currentIndex) {\n  // Do something based on current frame index of idle animation.\n};"}
{"prompt": "Write Flutter Flame code to SpriteAnimationGroupComponent¶: Example:", "completion": "enum RobotState { idle, running, jump }\n\nfinal running = await loadSpriteAnimation(/* omitted */);\nfinal idle = await loadSpriteAnimation(/* omitted */);\n\nfinal robot = SpriteAnimationGroupComponent<RobotState>(\n  animations: {\n    RobotState.running: running,\n    RobotState.idle: idle,\n  },\n  current: RobotState.idle,\n);\n\nrobot.animationTickers?[RobotState.running]?.onStart = () {\n  // Do something on start of running animation.\n};\n\nrobot.animationTickers?[RobotState.jump]?.onStart = () {\n  // Do something on start of jump animation.\n};\n\nrobot.animationTickers?[RobotState.jump]?.onComplete = () {\n  // Do something on complete of jump animation.\n};\n\nrobot.animationTickers?[RobotState.idle]?.onFrame = (currentIndex) {\n  // Do something based on current frame index of idle animation.\n};"}
{"prompt": "Create a Flutter Flame game component that SpriteGroupComponent¶: Example:", "completion": "class PlayerComponent extends SpriteGroupComponent<ButtonState>\n    with HasGameReference<SpriteGroupExample>, TapCallbacks {\n  @override\n  Future<void>? onLoad() async {\n    final pressedSprite = await gameRef.loadSprite(/* omitted */);\n    final unpressedSprite = await gameRef.loadSprite(/* omitted */);\n\n    sprites = {\n      ButtonState.pressed: pressedSprite,\n      ButtonState.unpressed: unpressedSprite,\n    };\n\n    current = ButtonState.unpressed;\n  }\n\n  // tap methods handler omitted...\n}"}
{"prompt": "Show me how to implement SpriteGroupComponent¶: Example: using Flutter Flame", "completion": "class PlayerComponent extends SpriteGroupComponent<ButtonState>\n    with HasGameReference<SpriteGroupExample>, TapCallbacks {\n  @override\n  Future<void>? onLoad() async {\n    final pressedSprite = await gameRef.loadSprite(/* omitted */);\n    final unpressedSprite = await gameRef.loadSprite(/* omitted */);\n\n    sprites = {\n      ButtonState.pressed: pressedSprite,\n      ButtonState.unpressed: unpressedSprite,\n    };\n\n    current = ButtonState.unpressed;\n  }\n\n  // tap methods handler omitted...\n}"}
{"prompt": "Write Flutter Flame code to SpriteGroupComponent¶: Example:", "completion": "class PlayerComponent extends SpriteGroupComponent<ButtonState>\n    with HasGameReference<SpriteGroupExample>, TapCallbacks {\n  @override\n  Future<void>? onLoad() async {\n    final pressedSprite = await gameRef.loadSprite(/* omitted */);\n    final unpressedSprite = await gameRef.loadSprite(/* omitted */);\n\n    sprites = {\n      ButtonState.pressed: pressedSprite,\n      ButtonState.unpressed: unpressedSprite,\n    };\n\n    current = ButtonState.unpressed;\n  }\n\n  // tap methods handler omitted...\n}"}
{"prompt": "Create a Flutter Flame game component that SpawnComponent¶: The factory function takes an int as an argument, which is the index of the component that is being spawned, so if for example 4 components have been spawned already the 5th component will have the index 4, since the indexing starts at 0.", "completion": "SpawnComponent(\n  factory: (i) => MyComponent(size: Vector2(10, 20)),\n  period: 0.5,\n  area: Circle(Vector2(100, 200), 150),\n);"}
{"prompt": "Show me how to implement SpawnComponent¶: The factory function takes an int as an argument, which is the index of the component that is being spawned, so if for example 4 components have been spawned already the 5th component will have the index 4, since the indexing starts at 0. using Flutter Flame", "completion": "SpawnComponent(\n  factory: (i) => MyComponent(size: Vector2(10, 20)),\n  period: 0.5,\n  area: Circle(Vector2(100, 200), 150),\n);"}
{"prompt": "Write Flutter Flame code to SpawnComponent¶: The factory function takes an int as an argument, which is the index of the component that is being spawned, so if for example 4 components have been spawned already the 5th component will have the index 4, since the indexing starts at 0.", "completion": "SpawnComponent(\n  factory: (i) => MyComponent(size: Vector2(10, 20)),\n  period: 0.5,\n  area: Circle(Vector2(100, 200), 150),\n);"}
{"prompt": "Create a Flutter Flame game component that SpawnComponent¶: If you don’t want the spawning rate to be static, you can use the SpawnComponent.periodRange constructor with the minPeriod and maxPeriod arguments instead. In the following example the component would be spawned randomly within the circle and the time between each new spawned component is between 0.5 to 10 seconds.", "completion": "SpawnComponent.periodRange(\n  factory: (i) => MyComponent(size: Vector2(10, 20)),\n  minPeriod: 0.5,\n  maxPeriod: 10,\n  area: Circle(Vector2(100, 200), 150),\n);"}
{"prompt": "Show me how to implement SpawnComponent¶: If you don’t want the spawning rate to be static, you can use the SpawnComponent.periodRange constructor with the minPeriod and maxPeriod arguments instead. In the following example the component would be spawned randomly within the circle and the time between each new spawned component is between 0.5 to 10 seconds. using Flutter Flame", "completion": "SpawnComponent.periodRange(\n  factory: (i) => MyComponent(size: Vector2(10, 20)),\n  minPeriod: 0.5,\n  maxPeriod: 10,\n  area: Circle(Vector2(100, 200), 150),\n);"}
{"prompt": "Write Flutter Flame code to SpawnComponent¶: If you don’t want the spawning rate to be static, you can use the SpawnComponent.periodRange constructor with the minPeriod and maxPeriod arguments instead. In the following example the component would be spawned randomly within the circle and the time between each new spawned component is between 0.5 to 10 seconds.", "completion": "SpawnComponent.periodRange(\n  factory: (i) => MyComponent(size: Vector2(10, 20)),\n  minPeriod: 0.5,\n  maxPeriod: 10,\n  area: Circle(Vector2(100, 200), 150),\n);"}
{"prompt": "Create a Flutter Flame game component that SpawnComponent¶: If you want to set the position yourself within the factory function, you can use set selfPositioning = true in the constructors and you will be able to set the positions yourself and ignore the area argument.", "completion": "SpawnComponent(\n  factory: (i) =>\n    MyComponent(position: Vector2(100, 200), size: Vector2(10, 20)),\n  selfPositioning: true,\n  period: 0.5,\n);"}
{"prompt": "Show me how to implement SpawnComponent¶: If you want to set the position yourself within the factory function, you can use set selfPositioning = true in the constructors and you will be able to set the positions yourself and ignore the area argument. using Flutter Flame", "completion": "SpawnComponent(\n  factory: (i) =>\n    MyComponent(position: Vector2(100, 200), size: Vector2(10, 20)),\n  selfPositioning: true,\n  period: 0.5,\n);"}
{"prompt": "Write Flutter Flame code to SpawnComponent¶: If you want to set the position yourself within the factory function, you can use set selfPositioning = true in the constructors and you will be able to set the positions yourself and ignore the area argument.", "completion": "SpawnComponent(\n  factory: (i) =>\n    MyComponent(position: Vector2(100, 200), size: Vector2(10, 20)),\n  selfPositioning: true,\n  period: 0.5,\n);"}
{"prompt": "Create a Flutter Flame game component that SvgComponent¶: This component uses an instance of Svg class to represent a Component that has a svg that is rendered in the game:", "completion": "@override\nFuture<void> onLoad() async {\n  final svg = await Svg.load('android.svg');\n  final android = SvgComponent.fromSvg(\n    svg,\n    position: Vector2.all(100),\n    size: Vector2.all(100),\n  );\n}"}
{"prompt": "Show me how to implement SvgComponent¶: This component uses an instance of Svg class to represent a Component that has a svg that is rendered in the game: using Flutter Flame", "completion": "@override\nFuture<void> onLoad() async {\n  final svg = await Svg.load('android.svg');\n  final android = SvgComponent.fromSvg(\n    svg,\n    position: Vector2.all(100),\n    size: Vector2.all(100),\n  );\n}"}
{"prompt": "Write Flutter Flame code to SvgComponent¶: This component uses an instance of Svg class to represent a Component that has a svg that is rendered in the game:", "completion": "@override\nFuture<void> onLoad() async {\n  final svg = await Svg.load('android.svg');\n  final android = SvgComponent.fromSvg(\n    svg,\n    position: Vector2.all(100),\n    size: Vector2.all(100),\n  );\n}"}
{"prompt": "Create a Flutter Flame game component that ParallaxComponent¶: The simplest ParallaxComponent is created like this:", "completion": "@override\nFuture<void> onLoad() async {\n  final parallaxComponent = await loadParallaxComponent([\n    ParallaxImageData('bg.png'),\n    ParallaxImageData('trees.png'),\n  ]);\n  add(parallaxComponent);\n}"}
{"prompt": "Show me how to implement ParallaxComponent¶: The simplest ParallaxComponent is created like this: using Flutter Flame", "completion": "@override\nFuture<void> onLoad() async {\n  final parallaxComponent = await loadParallaxComponent([\n    ParallaxImageData('bg.png'),\n    ParallaxImageData('trees.png'),\n  ]);\n  add(parallaxComponent);\n}"}
{"prompt": "Write Flutter Flame code to ParallaxComponent¶: The simplest ParallaxComponent is created like this:", "completion": "@override\nFuture<void> onLoad() async {\n  final parallaxComponent = await loadParallaxComponent([\n    ParallaxImageData('bg.png'),\n    ParallaxImageData('trees.png'),\n  ]);\n  add(parallaxComponent);\n}"}
{"prompt": "Create a Flutter Flame game component that ParallaxComponent¶: A ParallaxComponent can also “load itself” by implementing the onLoad method:", "completion": "class MyParallaxComponent extends ParallaxComponent<MyGame> {\n  @override\n  Future<void> onLoad() async {\n    parallax = await gameRef.loadParallax([\n      ParallaxImageData('bg.png'),\n      ParallaxImageData('trees.png'),\n    ]);\n  }\n}\n\nclass MyGame extends FlameGame {\n  @override\n  void onLoad() {\n    add(MyParallaxComponent());\n  }\n}"}
{"prompt": "Show me how to implement ParallaxComponent¶: A ParallaxComponent can also “load itself” by implementing the onLoad method: using Flutter Flame", "completion": "class MyParallaxComponent extends ParallaxComponent<MyGame> {\n  @override\n  Future<void> onLoad() async {\n    parallax = await gameRef.loadParallax([\n      ParallaxImageData('bg.png'),\n      ParallaxImageData('trees.png'),\n    ]);\n  }\n}\n\nclass MyGame extends FlameGame {\n  @override\n  void onLoad() {\n    add(MyParallaxComponent());\n  }\n}"}
{"prompt": "Write Flutter Flame code to ParallaxComponent¶: A ParallaxComponent can also “load itself” by implementing the onLoad method:", "completion": "class MyParallaxComponent extends ParallaxComponent<MyGame> {\n  @override\n  Future<void> onLoad() async {\n    parallax = await gameRef.loadParallax([\n      ParallaxImageData('bg.png'),\n      ParallaxImageData('trees.png'),\n    ]);\n  }\n}\n\nclass MyGame extends FlameGame {\n  @override\n  void onLoad() {\n    add(MyParallaxComponent());\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that ParallaxComponent¶: They simplest way is to set the named optional parameters baseVelocity and velocityMultiplierDelta in the load helper function. For example if you want to move your background images along the X-axis with a faster speed the “closer” the image is:", "completion": "@override\nFuture<void> onLoad() async {\n  final parallaxComponent = await loadParallaxComponent(\n    _dataList,\n    baseVelocity: Vector2(20, 0),\n    velocityMultiplierDelta: Vector2(1.8, 1.0),\n  );\n}"}
{"prompt": "Show me how to implement ParallaxComponent¶: They simplest way is to set the named optional parameters baseVelocity and velocityMultiplierDelta in the load helper function. For example if you want to move your background images along the X-axis with a faster speed the “closer” the image is: using Flutter Flame", "completion": "@override\nFuture<void> onLoad() async {\n  final parallaxComponent = await loadParallaxComponent(\n    _dataList,\n    baseVelocity: Vector2(20, 0),\n    velocityMultiplierDelta: Vector2(1.8, 1.0),\n  );\n}"}
{"prompt": "Write Flutter Flame code to ParallaxComponent¶: They simplest way is to set the named optional parameters baseVelocity and velocityMultiplierDelta in the load helper function. For example if you want to move your background images along the X-axis with a faster speed the “closer” the image is:", "completion": "@override\nFuture<void> onLoad() async {\n  final parallaxComponent = await loadParallaxComponent(\n    _dataList,\n    baseVelocity: Vector2(20, 0),\n    velocityMultiplierDelta: Vector2(1.8, 1.0),\n  );\n}"}
{"prompt": "Create a Flutter Flame game component that ParallaxComponent¶: You can set the baseSpeed and layerDelta at any time, for example if your character jumps or your game speeds up.", "completion": "@override\nvoid onLoad() {\n  final parallax = parallaxComponent.parallax;\n  parallax.baseSpeed = Vector2(100, 0);\n  parallax.velocityMultiplierDelta = Vector2(2.0, 1.0);\n}"}
{"prompt": "Show me how to implement ParallaxComponent¶: You can set the baseSpeed and layerDelta at any time, for example if your character jumps or your game speeds up. using Flutter Flame", "completion": "@override\nvoid onLoad() {\n  final parallax = parallaxComponent.parallax;\n  parallax.baseSpeed = Vector2(100, 0);\n  parallax.velocityMultiplierDelta = Vector2(2.0, 1.0);\n}"}
{"prompt": "Write Flutter Flame code to ParallaxComponent¶: You can set the baseSpeed and layerDelta at any time, for example if your character jumps or your game speeds up.", "completion": "@override\nvoid onLoad() {\n  final parallax = parallaxComponent.parallax;\n  parallax.baseSpeed = Vector2(100, 0);\n  parallax.velocityMultiplierDelta = Vector2(2.0, 1.0);\n}"}
{"prompt": "Create a Flutter Flame game component that ParallaxComponent¶: Advanced example:", "completion": "final images = [\n  loadParallaxImage(\n    'stars.jpg',\n    repeat: ImageRepeat.repeat,\n    alignment: Alignment.center,\n    fill: LayerFill.width,\n  ),\n  loadParallaxImage(\n    'planets.jpg',\n    repeat: ImageRepeat.repeatY,\n    alignment: Alignment.bottomLeft,\n    fill: LayerFill.none,\n  ),\n  loadParallaxImage(\n    'dust.jpg',\n    repeat: ImageRepeat.repeatX,\n    alignment: Alignment.topRight,\n    fill: LayerFill.height,\n  ),\n];\n\nfinal layers = images.map(\n  (image) => ParallaxLayer(\n    await image,\n    velocityMultiplier: images.indexOf(image) * 2.0,\n  )\n);\n\nfinal parallaxComponent = ParallaxComponent.fromParallax(\n  Parallax(\n    await Future.wait(layers),\n    baseVelocity: Vector2(50, 0),\n  ),\n);"}
{"prompt": "Show me how to implement ParallaxComponent¶: Advanced example: using Flutter Flame", "completion": "final images = [\n  loadParallaxImage(\n    'stars.jpg',\n    repeat: ImageRepeat.repeat,\n    alignment: Alignment.center,\n    fill: LayerFill.width,\n  ),\n  loadParallaxImage(\n    'planets.jpg',\n    repeat: ImageRepeat.repeatY,\n    alignment: Alignment.bottomLeft,\n    fill: LayerFill.none,\n  ),\n  loadParallaxImage(\n    'dust.jpg',\n    repeat: ImageRepeat.repeatX,\n    alignment: Alignment.topRight,\n    fill: LayerFill.height,\n  ),\n];\n\nfinal layers = images.map(\n  (image) => ParallaxLayer(\n    await image,\n    velocityMultiplier: images.indexOf(image) * 2.0,\n  )\n);\n\nfinal parallaxComponent = ParallaxComponent.fromParallax(\n  Parallax(\n    await Future.wait(layers),\n    baseVelocity: Vector2(50, 0),\n  ),\n);"}
{"prompt": "Write Flutter Flame code to ParallaxComponent¶: Advanced example:", "completion": "final images = [\n  loadParallaxImage(\n    'stars.jpg',\n    repeat: ImageRepeat.repeat,\n    alignment: Alignment.center,\n    fill: LayerFill.width,\n  ),\n  loadParallaxImage(\n    'planets.jpg',\n    repeat: ImageRepeat.repeatY,\n    alignment: Alignment.bottomLeft,\n    fill: LayerFill.none,\n  ),\n  loadParallaxImage(\n    'dust.jpg',\n    repeat: ImageRepeat.repeatX,\n    alignment: Alignment.topRight,\n    fill: LayerFill.height,\n  ),\n];\n\nfinal layers = images.map(\n  (image) => ParallaxLayer(\n    await image,\n    velocityMultiplier: images.indexOf(image) * 2.0,\n  )\n);\n\nfinal parallaxComponent = ParallaxComponent.fromParallax(\n  Parallax(\n    await Future.wait(layers),\n    baseVelocity: Vector2(50, 0),\n  ),\n);"}
{"prompt": "Create a Flutter Flame game component that PolygonComponent¶: For example, this would create a square going from (50, 50) to (100, 100), with it’s center in (75, 75):", "completion": "void main() {\n  PolygonComponent([\n    Vector2(100, 100),\n    Vector2(100, 50),\n    Vector2(50, 50),\n    Vector2(50, 100),\n  ]);\n}"}
{"prompt": "Show me how to implement PolygonComponent¶: For example, this would create a square going from (50, 50) to (100, 100), with it’s center in (75, 75): using Flutter Flame", "completion": "void main() {\n  PolygonComponent([\n    Vector2(100, 100),\n    Vector2(100, 50),\n    Vector2(50, 50),\n    Vector2(50, 100),\n  ]);\n}"}
{"prompt": "Write Flutter Flame code to PolygonComponent¶: For example, this would create a square going from (50, 50) to (100, 100), with it’s center in (75, 75):", "completion": "void main() {\n  PolygonComponent([\n    Vector2(100, 100),\n    Vector2(100, 50),\n    Vector2(50, 50),\n    Vector2(50, 100),\n  ]);\n}"}
{"prompt": "Create a Flutter Flame game component that PolygonComponent¶: For example you could create a diamond shapes polygon like this:", "completion": "void main() {\n  PolygonComponent.relative(\n    [\n      Vector2(0.0, -1.0), // Middle of top wall\n      Vector2(1.0, 0.0), // Middle of right wall\n      Vector2(0.0, 1.0), // Middle of bottom wall\n      Vector2(-1.0, 0.0), // Middle of left wall\n    ],\n    size: Vector2.all(100),\n  );\n}"}
{"prompt": "Show me how to implement PolygonComponent¶: For example you could create a diamond shapes polygon like this: using Flutter Flame", "completion": "void main() {\n  PolygonComponent.relative(\n    [\n      Vector2(0.0, -1.0), // Middle of top wall\n      Vector2(1.0, 0.0), // Middle of right wall\n      Vector2(0.0, 1.0), // Middle of bottom wall\n      Vector2(-1.0, 0.0), // Middle of left wall\n    ],\n    size: Vector2.all(100),\n  );\n}"}
{"prompt": "Write Flutter Flame code to PolygonComponent¶: For example you could create a diamond shapes polygon like this:", "completion": "void main() {\n  PolygonComponent.relative(\n    [\n      Vector2(0.0, -1.0), // Middle of top wall\n      Vector2(1.0, 0.0), // Middle of right wall\n      Vector2(0.0, 1.0), // Middle of bottom wall\n      Vector2(-1.0, 0.0), // Middle of left wall\n    ],\n    size: Vector2.all(100),\n  );\n}"}
{"prompt": "Create a Flutter Flame game component that RectangleComponent¶: Something like this for example:", "completion": "void main() {\n  RectangleComponent(\n    position: Vector2(10.0, 15.0),\n    size: Vector2.all(10),\n    angle: pi/2,\n    anchor: Anchor.center,\n  );\n}"}
{"prompt": "Show me how to implement RectangleComponent¶: Something like this for example: using Flutter Flame", "completion": "void main() {\n  RectangleComponent(\n    position: Vector2(10.0, 15.0),\n    size: Vector2.all(10),\n    angle: pi/2,\n    anchor: Anchor.center,\n  );\n}"}
{"prompt": "Write Flutter Flame code to RectangleComponent¶: Something like this for example:", "completion": "void main() {\n  RectangleComponent(\n    position: Vector2(10.0, 15.0),\n    size: Vector2.all(10),\n    angle: pi/2,\n    anchor: Anchor.center,\n  );\n}"}
{"prompt": "Create a Flutter Flame game component that RectangleComponent¶: The following would create a RectangleComponent with its top left corner in (10, 10) and a size of (100, 50).", "completion": "void main() {\n  RectangleComponent.fromRect(\n    Rect.fromLTWH(10, 10, 100, 50),\n  );\n}"}
{"prompt": "Show me how to implement RectangleComponent¶: The following would create a RectangleComponent with its top left corner in (10, 10) and a size of (100, 50). using Flutter Flame", "completion": "void main() {\n  RectangleComponent.fromRect(\n    Rect.fromLTWH(10, 10, 100, 50),\n  );\n}"}
{"prompt": "Write Flutter Flame code to RectangleComponent¶: The following would create a RectangleComponent with its top left corner in (10, 10) and a size of (100, 50).", "completion": "void main() {\n  RectangleComponent.fromRect(\n    Rect.fromLTWH(10, 10, 100, 50),\n  );\n}"}
{"prompt": "Create a Flutter Flame game component that RectangleComponent¶: In the example below a RectangleComponent of size (25.0, 30.0) positioned at (100, 100) would be created.", "completion": "void main() {\n  RectangleComponent.relative(\n    Vector2(0.5, 1.0),\n    position: Vector2.all(100),\n    size: Vector2(50, 30),\n  );\n}"}
{"prompt": "Show me how to implement RectangleComponent¶: In the example below a RectangleComponent of size (25.0, 30.0) positioned at (100, 100) would be created. using Flutter Flame", "completion": "void main() {\n  RectangleComponent.relative(\n    Vector2(0.5, 1.0),\n    position: Vector2.all(100),\n    size: Vector2(50, 30),\n  );\n}"}
{"prompt": "Write Flutter Flame code to RectangleComponent¶: In the example below a RectangleComponent of size (25.0, 30.0) positioned at (100, 100) would be created.", "completion": "void main() {\n  RectangleComponent.relative(\n    Vector2(0.5, 1.0),\n    position: Vector2.all(100),\n    size: Vector2(50, 30),\n  );\n}"}
{"prompt": "Create a Flutter Flame game component that RectangleComponent¶: Since a square is a simplified version of a rectangle, there is also a constructor for creating a square RectangleComponent, the only difference is that the size argument is a double instead of a Vector2.", "completion": "void main() {\n  RectangleComponent.square(\n    position: Vector2.all(100),\n    size: 200,\n  );\n}"}
{"prompt": "Show me how to implement RectangleComponent¶: Since a square is a simplified version of a rectangle, there is also a constructor for creating a square RectangleComponent, the only difference is that the size argument is a double instead of a Vector2. using Flutter Flame", "completion": "void main() {\n  RectangleComponent.square(\n    position: Vector2.all(100),\n    size: 200,\n  );\n}"}
{"prompt": "Write Flutter Flame code to RectangleComponent¶: Since a square is a simplified version of a rectangle, there is also a constructor for creating a square RectangleComponent, the only difference is that the size argument is a double instead of a Vector2.", "completion": "void main() {\n  RectangleComponent.square(\n    position: Vector2.all(100),\n    size: 200,\n  );\n}"}
{"prompt": "Create a Flutter Flame game component that CircleComponent¶: The following would create a CircleComponent with its center in (100, 100) with a radius of 5, and therefore a size of Vector2(10, 10).", "completion": "void main() {\n  CircleComponent(radius: 5, position: Vector2.all(100), anchor: Anchor.center);\n}"}
{"prompt": "Show me how to implement CircleComponent¶: The following would create a CircleComponent with its center in (100, 100) with a radius of 5, and therefore a size of Vector2(10, 10). using Flutter Flame", "completion": "void main() {\n  CircleComponent(radius: 5, position: Vector2.all(100), anchor: Anchor.center);\n}"}
{"prompt": "Write Flutter Flame code to CircleComponent¶: The following would create a CircleComponent with its center in (100, 100) with a radius of 5, and therefore a size of Vector2(10, 10).", "completion": "void main() {\n  CircleComponent(radius: 5, position: Vector2.all(100), anchor: Anchor.center);\n}"}
{"prompt": "Create a Flutter Flame game component that CircleComponent¶: The following example would result in a CircleComponent that defines a circle with a radius of 40 (a diameter of 80).", "completion": "void main() {\n  CircleComponent.relative(0.8, size: Vector2.all(100));\n}"}
{"prompt": "Show me how to implement CircleComponent¶: The following example would result in a CircleComponent that defines a circle with a radius of 40 (a diameter of 80). using Flutter Flame", "completion": "void main() {\n  CircleComponent.relative(0.8, size: Vector2.all(100));\n}"}
{"prompt": "Write Flutter Flame code to CircleComponent¶: The following example would result in a CircleComponent that defines a circle with a radius of 40 (a diameter of 80).", "completion": "void main() {\n  CircleComponent.relative(0.8, size: Vector2.all(100));\n}"}
{"prompt": "Create a Flutter Flame game component that IsometricTileMapComponent¶: A simple example on how to use it:", "completion": "// Creates a tileset, the block ids are automatically assigned sequentially\n// starting at 0, from left to right and then top to bottom.\nfinal tilesetImage = await images.load('tileset.png');\nfinal tileset = SpriteSheet(image: tilesetImage, srcSize: Vector2.all(32));\n// Each element is a block id, -1 means nothing\nfinal matrix = [[0, 1, 0], [1, 0, 0], [1, 1, 1]];\nadd(IsometricTileMapComponent(tileset, matrix));"}
{"prompt": "Show me how to implement IsometricTileMapComponent¶: A simple example on how to use it: using Flutter Flame", "completion": "// Creates a tileset, the block ids are automatically assigned sequentially\n// starting at 0, from left to right and then top to bottom.\nfinal tilesetImage = await images.load('tileset.png');\nfinal tileset = SpriteSheet(image: tilesetImage, srcSize: Vector2.all(32));\n// Each element is a block id, -1 means nothing\nfinal matrix = [[0, 1, 0], [1, 0, 0], [1, 1, 1]];\nadd(IsometricTileMapComponent(tileset, matrix));"}
{"prompt": "Write Flutter Flame code to IsometricTileMapComponent¶: A simple example on how to use it:", "completion": "// Creates a tileset, the block ids are automatically assigned sequentially\n// starting at 0, from left to right and then top to bottom.\nfinal tilesetImage = await images.load('tileset.png');\nfinal tileset = SpriteSheet(image: tilesetImage, srcSize: Vector2.all(32));\n// Each element is a block id, -1 means nothing\nfinal matrix = [[0, 1, 0], [1, 0, 0], [1, 1, 1]];\nadd(IsometricTileMapComponent(tileset, matrix));"}
{"prompt": "Create a Flutter Flame game component that ComponentsNotifier¶: Then to listen to changes on that component the componentsNotifier method from FlameGame can be used:", "completion": "class MyGame extends FlameGame {\n  int lives = 2;\n\n  @override\n  void onLoad() {\n    final playerNotifier = componentsNotifier<Player>()\n        ..addListener(() {\n          final player = playerNotifier.single;\n          if (player == null) {\n            lives--;\n            if (lives == 0) {\n              add(GameOverComponent());\n            } else {\n              add(Player());\n            }\n          }\n        });\n  }\n}"}
{"prompt": "Show me how to implement ComponentsNotifier¶: Then to listen to changes on that component the componentsNotifier method from FlameGame can be used: using Flutter Flame", "completion": "class MyGame extends FlameGame {\n  int lives = 2;\n\n  @override\n  void onLoad() {\n    final playerNotifier = componentsNotifier<Player>()\n        ..addListener(() {\n          final player = playerNotifier.single;\n          if (player == null) {\n            lives--;\n            if (lives == 0) {\n              add(GameOverComponent());\n            } else {\n              add(Player());\n            }\n          }\n        });\n  }\n}"}
{"prompt": "Write Flutter Flame code to ComponentsNotifier¶: Then to listen to changes on that component the componentsNotifier method from FlameGame can be used:", "completion": "class MyGame extends FlameGame {\n  int lives = 2;\n\n  @override\n  void onLoad() {\n    final playerNotifier = componentsNotifier<Player>()\n        ..addListener(() {\n          final player = playerNotifier.single;\n          if (player == null) {\n            lives--;\n            if (lives == 0) {\n              add(GameOverComponent());\n            } else {\n              add(Player());\n            }\n          }\n        });\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that ComponentsNotifier¶: A Notifier component can also manually notify its listeners that something changed. Lets expand the example above to make a hud component to blink when the player has half of their health. In order to do so, we need that the Player component notify a change manually, example:", "completion": "class Player extends SpriteComponent with Notifier {\n  double health = 1;\n\n  void takeHit() {\n    health -= .1;\n    if (health == 0) {\n      removeFromParent();\n    } else if (health <= .5) {\n      notifyListeners();\n    }\n  }\n}"}
{"prompt": "Show me how to implement ComponentsNotifier¶: A Notifier component can also manually notify its listeners that something changed. Lets expand the example above to make a hud component to blink when the player has half of their health. In order to do so, we need that the Player component notify a change manually, example: using Flutter Flame", "completion": "class Player extends SpriteComponent with Notifier {\n  double health = 1;\n\n  void takeHit() {\n    health -= .1;\n    if (health == 0) {\n      removeFromParent();\n    } else if (health <= .5) {\n      notifyListeners();\n    }\n  }\n}"}
{"prompt": "Write Flutter Flame code to ComponentsNotifier¶: A Notifier component can also manually notify its listeners that something changed. Lets expand the example above to make a hud component to blink when the player has half of their health. In order to do so, we need that the Player component notify a change manually, example:", "completion": "class Player extends SpriteComponent with Notifier {\n  double health = 1;\n\n  void takeHit() {\n    health -= .1;\n    if (health == 0) {\n      removeFromParent();\n    } else if (health <= .5) {\n      notifyListeners();\n    }\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that ComponentsNotifier¶: Then our hud component could look like:", "completion": "class Hud extends PositionComponent with HasGameRef {\n\n  @override\n  void onLoad() {\n    final playerNotifier = gameRef.componentsNotifier<Player>()\n        ..addListener(() {\n          final player = playerNotifier.single;\n          if (player != null) {\n            if (player.health <= .5) {\n              add(BlinkEffect());\n            }\n          }\n        });\n  }\n}"}
{"prompt": "Show me how to implement ComponentsNotifier¶: Then our hud component could look like: using Flutter Flame", "completion": "class Hud extends PositionComponent with HasGameRef {\n\n  @override\n  void onLoad() {\n    final playerNotifier = gameRef.componentsNotifier<Player>()\n        ..addListener(() {\n          final player = playerNotifier.single;\n          if (player != null) {\n            if (player.health <= .5) {\n              add(BlinkEffect());\n            }\n          }\n        });\n  }\n}"}
{"prompt": "Write Flutter Flame code to ComponentsNotifier¶: Then our hud component could look like:", "completion": "class Hud extends PositionComponent with HasGameRef {\n\n  @override\n  void onLoad() {\n    final playerNotifier = gameRef.componentsNotifier<Player>()\n        ..addListener(() {\n          final player = playerNotifier.single;\n          if (player != null) {\n            if (player.health <= .5) {\n              add(BlinkEffect());\n            }\n          }\n        });\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Joystick¶: Check out the following example to get a better understanding:", "completion": "class MyGame extends FlameGame {\n\n  @override\n  Future<void> onLoad() async {\n    super.onLoad();\n    final image = await images.load('joystick.png');\n    final sheet = SpriteSheet.fromColumnsAndRows(\n      image: image,\n      columns: 6,\n      rows: 1,\n    );\n    final joystick = JoystickComponent(\n      knob: SpriteComponent(\n        sprite: sheet.getSpriteById(1),\n        size: Vector2.all(100),\n      ),\n      background: SpriteComponent(\n        sprite: sheet.getSpriteById(0),\n        size: Vector2.all(150),\n      ),\n      margin: const EdgeInsets.only(left: 40, bottom: 40),\n    );\n\n    final player = Player(joystick);\n    add(player);\n    add(joystick);\n  }\n}\n\nclass Player extends SpriteComponent with HasGameRef {\n  Player(this.joystick)\n    : super(\n        anchor: Anchor.center,\n        size: Vector2.all(100.0),\n      );\n\n  /// Pixels/s\n  double maxSpeed = 300.0;\n\n  final JoystickComponent joystick;\n\n  @override\n  Future<void> onLoad() async {\n    sprite = await gameRef.loadSprite('layers/player.png');\n    position = gameRef.size / 2;\n  }\n\n  @override\n  void update(double dt) {\n    if (joystick.direction != JoystickDirection.idle) {\n      position.add(joystick.relativeDelta  * maxSpeed * dt);\n      angle = joystick.delta.screenAngle();\n    }\n  }\n}"}
{"prompt": "Show me how to implement Joystick¶: Check out the following example to get a better understanding: using Flutter Flame", "completion": "class MyGame extends FlameGame {\n\n  @override\n  Future<void> onLoad() async {\n    super.onLoad();\n    final image = await images.load('joystick.png');\n    final sheet = SpriteSheet.fromColumnsAndRows(\n      image: image,\n      columns: 6,\n      rows: 1,\n    );\n    final joystick = JoystickComponent(\n      knob: SpriteComponent(\n        sprite: sheet.getSpriteById(1),\n        size: Vector2.all(100),\n      ),\n      background: SpriteComponent(\n        sprite: sheet.getSpriteById(0),\n        size: Vector2.all(150),\n      ),\n      margin: const EdgeInsets.only(left: 40, bottom: 40),\n    );\n\n    final player = Player(joystick);\n    add(player);\n    add(joystick);\n  }\n}\n\nclass Player extends SpriteComponent with HasGameRef {\n  Player(this.joystick)\n    : super(\n        anchor: Anchor.center,\n        size: Vector2.all(100.0),\n      );\n\n  /// Pixels/s\n  double maxSpeed = 300.0;\n\n  final JoystickComponent joystick;\n\n  @override\n  Future<void> onLoad() async {\n    sprite = await gameRef.loadSprite('layers/player.png');\n    position = gameRef.size / 2;\n  }\n\n  @override\n  void update(double dt) {\n    if (joystick.direction != JoystickDirection.idle) {\n      position.add(joystick.relativeDelta  * maxSpeed * dt);\n      angle = joystick.delta.screenAngle();\n    }\n  }\n}"}
{"prompt": "Write Flutter Flame code to Joystick¶: Check out the following example to get a better understanding:", "completion": "class MyGame extends FlameGame {\n\n  @override\n  Future<void> onLoad() async {\n    super.onLoad();\n    final image = await images.load('joystick.png');\n    final sheet = SpriteSheet.fromColumnsAndRows(\n      image: image,\n      columns: 6,\n      rows: 1,\n    );\n    final joystick = JoystickComponent(\n      knob: SpriteComponent(\n        sprite: sheet.getSpriteById(1),\n        size: Vector2.all(100),\n      ),\n      background: SpriteComponent(\n        sprite: sheet.getSpriteById(0),\n        size: Vector2.all(150),\n      ),\n      margin: const EdgeInsets.only(left: 40, bottom: 40),\n    );\n\n    final player = Player(joystick);\n    add(player);\n    add(joystick);\n  }\n}\n\nclass Player extends SpriteComponent with HasGameRef {\n  Player(this.joystick)\n    : super(\n        anchor: Anchor.center,\n        size: Vector2.all(100.0),\n      );\n\n  /// Pixels/s\n  double maxSpeed = 300.0;\n\n  final JoystickComponent joystick;\n\n  @override\n  Future<void> onLoad() async {\n    sprite = await gameRef.loadSprite('layers/player.png');\n    position = gameRef.size / 2;\n  }\n\n  @override\n  void update(double dt) {\n    if (joystick.direction != JoystickDirection.idle) {\n      position.add(joystick.relativeDelta  * maxSpeed * dt);\n      angle = joystick.delta.screenAngle();\n    }\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that BodyComponent¶: :exclamation: In Forge2D you shouldn’t add any bodies as children to other components, since Forge2D doesn’t have a concept of nested bodies. So bodies should live on the top level in the physics world, Forge2DGame.world. So instead of add(Weapon())), world.add(Weapon()) should be used (as below), and the Player should also of course initially be added to the world.", "completion": "class Weapon extends BodyComponent  {\n  @override\n  void onLoad() {\n    ...\n  }\n}\n\nclass Player extends BodyComponent  {\n  @override\n  void onLoad() {\n    world.add(Weapon());\n  }\n}"}
{"prompt": "Show me how to implement BodyComponent¶: :exclamation: In Forge2D you shouldn’t add any bodies as children to other components, since Forge2D doesn’t have a concept of nested bodies. So bodies should live on the top level in the physics world, Forge2DGame.world. So instead of add(Weapon())), world.add(Weapon()) should be used (as below), and the Player should also of course initially be added to the world. using Flutter Flame", "completion": "class Weapon extends BodyComponent  {\n  @override\n  void onLoad() {\n    ...\n  }\n}\n\nclass Player extends BodyComponent  {\n  @override\n  void onLoad() {\n    world.add(Weapon());\n  }\n}"}
{"prompt": "Write Flutter Flame code to BodyComponent¶: :exclamation: In Forge2D you shouldn’t add any bodies as children to other components, since Forge2D doesn’t have a concept of nested bodies. So bodies should live on the top level in the physics world, Forge2DGame.world. So instead of add(Weapon())), world.add(Weapon()) should be used (as below), and the Player should also of course initially be added to the world.", "completion": "class Weapon extends BodyComponent  {\n  @override\n  void onLoad() {\n    ...\n  }\n}\n\nclass Player extends BodyComponent  {\n  @override\n  void onLoad() {\n    world.add(Weapon());\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Contact callbacks¶: There are multiple ways to listen to these events. One common way is to use the ContactCallbacks class as a mixin in the BodyComponent where you are interested in these events.", "completion": "class Ball extends BodyComponent with ContactCallbacks {\n  ...\n  void beginContact(Object other, Contact contact) {\n    if (other is Wall) {\n      // Do something here.\n    }\n  }\n  ...\n}"}
{"prompt": "Show me how to implement Contact callbacks¶: There are multiple ways to listen to these events. One common way is to use the ContactCallbacks class as a mixin in the BodyComponent where you are interested in these events. using Flutter Flame", "completion": "class Ball extends BodyComponent with ContactCallbacks {\n  ...\n  void beginContact(Object other, Contact contact) {\n    if (other is Wall) {\n      // Do something here.\n    }\n  }\n  ...\n}"}
{"prompt": "Write Flutter Flame code to Contact callbacks¶: There are multiple ways to listen to these events. One common way is to use the ContactCallbacks class as a mixin in the BodyComponent where you are interested in these events.", "completion": "class Ball extends BodyComponent with ContactCallbacks {\n  ...\n  void beginContact(Object other, Contact contact) {\n    if (other is Wall) {\n      // Do something here.\n    }\n  }\n  ...\n}"}
{"prompt": "Create a Flutter Flame game component that Contact callbacks¶: A convenient way of setting userData is to assign it when creating the body. For example:", "completion": "class Ball extends BodyComponent with ContactCallbacks {\n  ...\n\n  @override\n  Body createBody() {\n    ...\n    final bodyDef = BodyDef(\n      userData: this,\n    );\n    ...\n  }\n\n}"}
{"prompt": "Show me how to implement Contact callbacks¶: A convenient way of setting userData is to assign it when creating the body. For example: using Flutter Flame", "completion": "class Ball extends BodyComponent with ContactCallbacks {\n  ...\n\n  @override\n  Body createBody() {\n    ...\n    final bodyDef = BodyDef(\n      userData: this,\n    );\n    ...\n  }\n\n}"}
{"prompt": "Write Flutter Flame code to Contact callbacks¶: A convenient way of setting userData is to assign it when creating the body. For example:", "completion": "class Ball extends BodyComponent with ContactCallbacks {\n  ...\n\n  @override\n  Body createBody() {\n    ...\n    final bodyDef = BodyDef(\n      userData: this,\n    );\n    ...\n  }\n\n}"}
{"prompt": "Create a Flutter Flame game component that Pointer Events¶: For example:", "completion": "class MyComponent extends PositionComponent with PointerMoveCallbacks {\n  MyComponent() : super(size: Vector2(80, 60));\n\n  @override\n  void onPointerMove(PointerMoveEvent event) {\n    // Do something in response to the mouse move (e.g. update coordinates)\n  }\n}"}
{"prompt": "Show me how to implement Pointer Events¶: For example: using Flutter Flame", "completion": "class MyComponent extends PositionComponent with PointerMoveCallbacks {\n  MyComponent() : super(size: Vector2(80, 60));\n\n  @override\n  void onPointerMove(PointerMoveEvent event) {\n    // Do something in response to the mouse move (e.g. update coordinates)\n  }\n}"}
{"prompt": "Write Flutter Flame code to Pointer Events¶: For example:", "completion": "class MyComponent extends PositionComponent with PointerMoveCallbacks {\n  MyComponent() : super(size: Vector2(80, 60));\n\n  @override\n  void onPointerMove(PointerMoveEvent event) {\n    // Do something in response to the mouse move (e.g. update coordinates)\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that HoverCallbacks¶: For example:", "completion": "class MyComponent extends PositionComponent with HoverCallbacks {\n\n  MyComponent() : super(size: Vector2(80, 60));\n\n  @override\n  void update(double dt) {\n    // use `isHovered` to know if the component is being hovered\n  }\n\n  @override\n  void onHoverEnter() {\n    // Do something in response to the mouse entering the component\n  }\n\n  @override\n  void onHoverExit() {\n    // Do something in response to the mouse leaving the component\n  }\n}"}
{"prompt": "Show me how to implement HoverCallbacks¶: For example: using Flutter Flame", "completion": "class MyComponent extends PositionComponent with HoverCallbacks {\n\n  MyComponent() : super(size: Vector2(80, 60));\n\n  @override\n  void update(double dt) {\n    // use `isHovered` to know if the component is being hovered\n  }\n\n  @override\n  void onHoverEnter() {\n    // Do something in response to the mouse entering the component\n  }\n\n  @override\n  void onHoverExit() {\n    // Do something in response to the mouse leaving the component\n  }\n}"}
{"prompt": "Write Flutter Flame code to HoverCallbacks¶: For example:", "completion": "class MyComponent extends PositionComponent with HoverCallbacks {\n\n  MyComponent() : super(size: Vector2(80, 60));\n\n  @override\n  void update(double dt) {\n    // use `isHovered` to know if the component is being hovered\n  }\n\n  @override\n  void onHoverEnter() {\n    // Do something in response to the mouse entering the component\n  }\n\n  @override\n  void onHoverExit() {\n    // Do something in response to the mouse leaving the component\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Demo¶: Play with the demo below to see the pointer hover events in action.", "completion": "import 'dart:math';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flutter/rendering.dart';\n\nclass PointerEventsGame extends FlameGame with TapCallbacks {\n@override\nFuture<void> onLoad() async {\nadd(HoverTarget(Vector2(100, 200)));\nadd(HoverTarget(Vector2(300, 300)));\nadd(HoverTarget(Vector2(400, 50)));\n}\n\n@override\nvoid onTapDown(TapDownEvent event) {\nadd(HoverTarget(event.localPosition));\n}\n}\n\nclass HoverTarget extends PositionComponent with HoverCallbacks {\nstatic final Random _random = Random();\n\nHoverTarget(Vector2 position)\n: super(\nposition: position,\nsize: Vector2.all(50),\nanchor: Anchor.center,\n);\n\nfinal _paint = Paint()\n..color = HSLColor.fromAHSL(1, _random.nextDouble() * 360, 1, 0.8)\n.toColor()\n.withValues(alpha: 0.5);\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRect(size.toRect(), _paint);\n}\n\n@override\nvoid onHoverEnter() {\n_paint.color = _paint.color.withValues(alpha: 1);\n}\n\n@override\nvoid onHoverExit() {\n_paint.color = _paint.color.withValues(alpha: 0.5);\n}\n}"}
{"prompt": "Show me how to implement Demo¶: Play with the demo below to see the pointer hover events in action. using Flutter Flame", "completion": "import 'dart:math';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flutter/rendering.dart';\n\nclass PointerEventsGame extends FlameGame with TapCallbacks {\n@override\nFuture<void> onLoad() async {\nadd(HoverTarget(Vector2(100, 200)));\nadd(HoverTarget(Vector2(300, 300)));\nadd(HoverTarget(Vector2(400, 50)));\n}\n\n@override\nvoid onTapDown(TapDownEvent event) {\nadd(HoverTarget(event.localPosition));\n}\n}\n\nclass HoverTarget extends PositionComponent with HoverCallbacks {\nstatic final Random _random = Random();\n\nHoverTarget(Vector2 position)\n: super(\nposition: position,\nsize: Vector2.all(50),\nanchor: Anchor.center,\n);\n\nfinal _paint = Paint()\n..color = HSLColor.fromAHSL(1, _random.nextDouble() * 360, 1, 0.8)\n.toColor()\n.withValues(alpha: 0.5);\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRect(size.toRect(), _paint);\n}\n\n@override\nvoid onHoverEnter() {\n_paint.color = _paint.color.withValues(alpha: 1);\n}\n\n@override\nvoid onHoverExit() {\n_paint.color = _paint.color.withValues(alpha: 0.5);\n}\n}"}
{"prompt": "Write Flutter Flame code to Demo¶: Play with the demo below to see the pointer hover events in action.", "completion": "import 'dart:math';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flutter/rendering.dart';\n\nclass PointerEventsGame extends FlameGame with TapCallbacks {\n@override\nFuture<void> onLoad() async {\nadd(HoverTarget(Vector2(100, 200)));\nadd(HoverTarget(Vector2(300, 300)));\nadd(HoverTarget(Vector2(400, 50)));\n}\n\n@override\nvoid onTapDown(TapDownEvent event) {\nadd(HoverTarget(event.localPosition));\n}\n}\n\nclass HoverTarget extends PositionComponent with HoverCallbacks {\nstatic final Random _random = Random();\n\nHoverTarget(Vector2 position)\n: super(\nposition: position,\nsize: Vector2.all(50),\nanchor: Anchor.center,\n);\n\nfinal _paint = Paint()\n..color = HSLColor.fromAHSL(1, _random.nextDouble() * 360, 1, 0.8)\n.toColor()\n.withValues(alpha: 0.5);\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRect(size.toRect(), _paint);\n}\n\n@override\nvoid onHoverEnter() {\n_paint.color = _paint.color.withValues(alpha: 1);\n}\n\n@override\nvoid onHoverExit() {\n_paint.color = _paint.color.withValues(alpha: 0.5);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that How to use it¶: First, start with adding the animation.riv file to the assets folder. Then load the artboard of the animation to the game using the loadArtboard method. After that, create the StateMachineController from the artboard and add a controller to it. Then you can create a RiveComponent using that artboard.", "completion": "import 'dart:async';\n\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame_rive/flame_rive.dart';\n\nclass RiveExampleGame extends FlameGame with TapDetector {\nlate SMIInput<double>? levelInput;\n\n@override\nFuture<void> onLoad() async {\nfinal skillsArtboard =\nawait loadArtboard(RiveFile.asset('assets/skills.riv'));\n\nfinal controller = StateMachineController.fromArtboard(\nskillsArtboard,\n\"Designer's Test\",\n);\n\nskillsArtboard.addController(controller!);\n\nlevelInput = controller.findInput<double>('Level');\n\nadd(RiveComponent(artboard: skillsArtboard, size: canvasSize));\n}\n\n@override\nvoid onTap() {\nsuper.onTap();\nif (levelInput != null) {\nlevelInput!.value = (levelInput!.value + 1) % 3;\n}\n}\n}"}
{"prompt": "Show me how to implement How to use it¶: First, start with adding the animation.riv file to the assets folder. Then load the artboard of the animation to the game using the loadArtboard method. After that, create the StateMachineController from the artboard and add a controller to it. Then you can create a RiveComponent using that artboard. using Flutter Flame", "completion": "import 'dart:async';\n\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame_rive/flame_rive.dart';\n\nclass RiveExampleGame extends FlameGame with TapDetector {\nlate SMIInput<double>? levelInput;\n\n@override\nFuture<void> onLoad() async {\nfinal skillsArtboard =\nawait loadArtboard(RiveFile.asset('assets/skills.riv'));\n\nfinal controller = StateMachineController.fromArtboard(\nskillsArtboard,\n\"Designer's Test\",\n);\n\nskillsArtboard.addController(controller!);\n\nlevelInput = controller.findInput<double>('Level');\n\nadd(RiveComponent(artboard: skillsArtboard, size: canvasSize));\n}\n\n@override\nvoid onTap() {\nsuper.onTap();\nif (levelInput != null) {\nlevelInput!.value = (levelInput!.value + 1) % 3;\n}\n}\n}"}
{"prompt": "Write Flutter Flame code to How to use it¶: First, start with adding the animation.riv file to the assets folder. Then load the artboard of the animation to the game using the loadArtboard method. After that, create the StateMachineController from the artboard and add a controller to it. Then you can create a RiveComponent using that artboard.", "completion": "import 'dart:async';\n\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame_rive/flame_rive.dart';\n\nclass RiveExampleGame extends FlameGame with TapDetector {\nlate SMIInput<double>? levelInput;\n\n@override\nFuture<void> onLoad() async {\nfinal skillsArtboard =\nawait loadArtboard(RiveFile.asset('assets/skills.riv'));\n\nfinal controller = StateMachineController.fromArtboard(\nskillsArtboard,\n\"Designer's Test\",\n);\n\nskillsArtboard.addController(controller!);\n\nlevelInput = controller.findInput<double>('Level');\n\nadd(RiveComponent(artboard: skillsArtboard, size: canvasSize));\n}\n\n@override\nvoid onTap() {\nsuper.onTap();\nif (levelInput != null) {\nlevelInput!.value = (levelInput!.value + 1) % 3;\n}\n}\n}"}
{"prompt": "Create a Flutter Flame game component that How to use it¶: First, start with adding the animation.riv file to the assets folder. Then load the artboard of the animation to the game using the loadArtboard method. After that, create the StateMachineController from the artboard and add a controller to it. Then you can create a RiveComponent using that artboard.", "completion": "class RiveExampleGame extends FlameGame {\n  @override\n  Future<void> onLoad() async {\n    final skillsArtboard =\n    await loadArtboard(RiveFile.asset('assets/skills.riv'));\n\n    final controller = StateMachineController.fromArtboard(\n      skillsArtboard,\n      \"Designer's Test\",\n    );\n\n    skillsArtboard.addController(controller!);\n\n    add(RiveComponent(artboard: skillsArtboard, size: Vector2.all(550)));\n  }\n}"}
{"prompt": "Show me how to implement How to use it¶: First, start with adding the animation.riv file to the assets folder. Then load the artboard of the animation to the game using the loadArtboard method. After that, create the StateMachineController from the artboard and add a controller to it. Then you can create a RiveComponent using that artboard. using Flutter Flame", "completion": "class RiveExampleGame extends FlameGame {\n  @override\n  Future<void> onLoad() async {\n    final skillsArtboard =\n    await loadArtboard(RiveFile.asset('assets/skills.riv'));\n\n    final controller = StateMachineController.fromArtboard(\n      skillsArtboard,\n      \"Designer's Test\",\n    );\n\n    skillsArtboard.addController(controller!);\n\n    add(RiveComponent(artboard: skillsArtboard, size: Vector2.all(550)));\n  }\n}"}
{"prompt": "Write Flutter Flame code to How to use it¶: First, start with adding the animation.riv file to the assets folder. Then load the artboard of the animation to the game using the loadArtboard method. After that, create the StateMachineController from the artboard and add a controller to it. Then you can create a RiveComponent using that artboard.", "completion": "class RiveExampleGame extends FlameGame {\n  @override\n  Future<void> onLoad() async {\n    final skillsArtboard =\n    await loadArtboard(RiveFile.asset('assets/skills.riv'));\n\n    final controller = StateMachineController.fromArtboard(\n      skillsArtboard,\n      \"Designer's Test\",\n    );\n\n    skillsArtboard.addController(controller!);\n\n    add(RiveComponent(artboard: skillsArtboard, size: Vector2.all(550)));\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Usage¶: Example:", "completion": "class MyGame extends FlameGame {\n  ...\n  @override\n  Future<void> onLoad() async {\n    final asset = Lottie.asset('assets/LottieLogo1.json');\n    final animation = await loadLottie(asset);\n    add(\n      LottieComponent(\n        animation,\n        repeating: true, // Continuously loop the animation.\n        size: Vector2.all(400),\n      ),\n    );\n  }\n  ...\n}"}
{"prompt": "Show me how to implement Usage¶: Example: using Flutter Flame", "completion": "class MyGame extends FlameGame {\n  ...\n  @override\n  Future<void> onLoad() async {\n    final asset = Lottie.asset('assets/LottieLogo1.json');\n    final animation = await loadLottie(asset);\n    add(\n      LottieComponent(\n        animation,\n        repeating: true, // Continuously loop the animation.\n        size: Vector2.all(400),\n      ),\n    );\n  }\n  ...\n}"}
{"prompt": "Write Flutter Flame code to Usage¶: Example:", "completion": "class MyGame extends FlameGame {\n  ...\n  @override\n  Future<void> onLoad() async {\n    final asset = Lottie.asset('assets/LottieLogo1.json');\n    final animation = await loadLottie(asset);\n    add(\n      LottieComponent(\n        animation,\n        repeating: true, // Continuously loop the animation.\n        size: Vector2.all(400),\n      ),\n    );\n  }\n  ...\n}"}
{"prompt": "Create a Flutter Flame game component that Usage¶: Example:", "completion": "class MyGame extends FlameGame with FlameIsolate {\n  ...\n  @override\n  void update(double dt) {\n    if (shouldRecalculate) {\n      isolate(recalculateWorld, worldData).then(updateWorld);\n    }\n    ...\n  }\n  ...\n}"}
{"prompt": "Show me how to implement Usage¶: Example: using Flutter Flame", "completion": "class MyGame extends FlameGame with FlameIsolate {\n  ...\n  @override\n  void update(double dt) {\n    if (shouldRecalculate) {\n      isolate(recalculateWorld, worldData).then(updateWorld);\n    }\n    ...\n  }\n  ...\n}"}
{"prompt": "Write Flutter Flame code to Usage¶: Example:", "completion": "class MyGame extends FlameGame with FlameIsolate {\n  ...\n  @override\n  void update(double dt) {\n    if (shouldRecalculate) {\n      isolate(recalculateWorld, worldData).then(updateWorld);\n    }\n    ...\n  }\n  ...\n}"}
{"prompt": "Create a Flutter Flame game component that Backpressure Strategies¶: You can specify a backpressure strategy by overriding the backpressureStrategy field. This will create the isolate with the specified strategy when the component is mounted.", "completion": "class MyGame extends FlameGame with FlameIsolate {\n  @override\n  BackpressureStrategy get backpressureStrategy => ReplaceBackpressureStrategy();\n  ...\n}"}
{"prompt": "Show me how to implement Backpressure Strategies¶: You can specify a backpressure strategy by overriding the backpressureStrategy field. This will create the isolate with the specified strategy when the component is mounted. using Flutter Flame", "completion": "class MyGame extends FlameGame with FlameIsolate {\n  @override\n  BackpressureStrategy get backpressureStrategy => ReplaceBackpressureStrategy();\n  ...\n}"}
{"prompt": "Write Flutter Flame code to Backpressure Strategies¶: You can specify a backpressure strategy by overriding the backpressureStrategy field. This will create the isolate with the specified strategy when the component is mounted.", "completion": "class MyGame extends FlameGame with FlameIsolate {\n  @override\n  BackpressureStrategy get backpressureStrategy => ReplaceBackpressureStrategy();\n  ...\n}"}
{"prompt": "Create a Flutter Flame game component that : Please click here to go see the documentation for the latest released version.", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/geometry.dart';\nimport 'package:flame/rendering.dart';\nimport 'package:flutter/rendering.dart';\n\nclass RouterGame extends FlameGame {\nlate final RouterComponent router;\n\n@override\nFuture<void> onLoad() async {\nadd(\nrouter = RouterComponent(\nroutes: {\n'home': Route(StartPage.new),\n'level1': WorldRoute(Level1Page.new),\n'level2': WorldRoute(Level2Page.new, maintainState: false),\n'pause': PauseRoute(),\n},\ninitialRoute: 'home',\n),\n);\n}\n}\n\nclass StartPage extends Component with HasGameReference<RouterGame> {\nStartPage() {\naddAll([\n_logo = TextComponent(\ntext: 'Your Game',\ntextRenderer: TextPaint(\nstyle: const TextStyle(\nfontSize: 64,\ncolor: Color(0xFFC8FFF5),\nfontWeight: FontWeight.w800,\n),\n),\nanchor: Anchor.center,\n),\n_button1 = RoundedButton(\ntext: 'Level 1',\naction: () => game.router.pushNamed('level1'),\ncolor: const Color(0xffadde6c),\nborderColor: const Color(0xffedffab),\n),\n_button2 = RoundedButton(\ntext: 'Level 2',\naction: () => game.router.pushNamed('level2'),\ncolor: const Color(0xffdebe6c),\nborderColor: const Color(0xfffff4c7),\n),\n]);\n}\n\nlate final TextComponent _logo;\nlate final RoundedButton _button1;\nlate final RoundedButton _button2;\n\n@override\nvoid onGameResize(Vector2 size) {\nsuper.onGameResize(size);\n_logo.position = Vector2(size.x / 2, size.y / 3);\n_button1.position = Vector2(size.x / 2, _logo.y + 80);\n_button2.position = Vector2(size.x / 2, _logo.y + 140);\n}\n}\n\nclass Background extends Component {\nBackground(this.color);\nfinal Color color;\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawColor(color, BlendMode.srcATop);\n}\n}\n\nclass RoundedButton extends PositionComponent with TapCallbacks {\nRoundedButton({\nrequired this.text,\nrequired this.action,\nrequired Color color,\nrequired Color borderColor,\nsuper.position,\nsuper.anchor = Anchor.center,\n}) : _textDrawable = TextPaint(\nstyle: const TextStyle(\nfontSize: 20,\ncolor: Color(0xFF000000),\nfontWeight: FontWeight.w800,\n),\n).toTextPainter(text) {\nsize = Vector2(150, 40);\n_textOffset = Offset(\n(size.x - _textDrawable.width) / 2,\n(size.y - _textDrawable.height) / 2,\n);\n_rrect = RRect.fromLTRBR(0, 0, size.x, size.y, Radius.circular(size.y / 2));\n_bgPaint = Paint()..color = color;\n_borderPaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 2\n..color = borderColor;\n}\n\nfinal String text;\nfinal void Function() action;\nfinal TextPainter _textDrawable;\nlate final Offset _textOffset;\nlate final RRect _rrect;\nlate final Paint _borderPaint;\nlate final Paint _bgPaint;\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRRect(_rrect, _bgPaint);\ncanvas.drawRRect(_rrect, _borderPaint);\n_textDrawable.paint(canvas, _textOffset);\n}\n\n@override\nvoid onTapDown(TapDownEvent event) {\nscale = Vector2.all(1.05);\n}\n\n@override\nvoid onTapUp(TapUpEvent event) {\nscale = Vector2.all(1.0);\naction();\n}\n\n@override\nvoid onTapCancel(TapCancelEvent event) {\nscale = Vector2.all(1.0);\n}\n}\n\nabstract class SimpleButton extends PositionComponent with TapCallbacks {\nSimpleButton(this._iconPath, {super.position}) : super(size: Vector2.all(40));\n\nfinal Paint _borderPaint = Paint()\n..style = PaintingStyle.stroke\n..color = const Color(0x66ffffff);\nfinal Paint _iconPaint = Paint()\n..style = PaintingStyle.stroke\n..color = const Color(0xffaaaaaa)\n..strokeWidth = 7;\nfinal Path _iconPath;\n\nvoid action();\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRRect(\nRRect.fromRectAndRadius(size.toRect(), const Radius.circular(8)),\n_borderPaint,\n);\ncanvas.drawPath(_iconPath, _iconPaint);\n}\n\n@override\nvoid onTapDown(TapDownEvent event) {\n_iconPaint.color = const Color(0xffffffff);\n}\n\n@override\nvoid onTapUp(TapUpEvent event) {\n_iconPaint.color = const Color(0xffaaaaaa);\naction();\n}\n\n@override\nvoid onTapCancel(TapCancelEvent event) {\n_iconPaint.color = const Color(0xffaaaaaa);\n}\n}\n\nclass BackButton extends SimpleButton with HasGameReference<RouterGame> {\nBackButton()\n: super(\nPath()\n..moveTo(22, 8)\n..lineTo(10, 20)\n..lineTo(22, 32)\n..moveTo(12, 20)\n..lineTo(34, 20),\nposition: Vector2.all(10),\n);\n\n@override\nvoid action() => game.router.pop();\n}\n\nclass PauseButton extends SimpleButton with HasGameReference<RouterGame> {\nPauseButton()\n: super(\nPath()\n..moveTo(14, 10)\n..lineTo(14, 30)\n..moveTo(26, 10)\n..lineTo(26, 30),\nposition: Vector2(60, 10),\n);\n\nbool isPaused = false;\n\n@override\nvoid action() {\nif (isPaused) {\ngame.router.pop();\n} else {\ngame.router.pushNamed('pause');\n}\nisPaused = !isPaused;\n}\n}\n\nclass Level1Page extends DecoratedWorld with HasGameReference {\n@override\nFuture<void> onLoad() async {\naddAll([\nBackground(const Color(0xbb2a074f)),\nPlanet(\nradius: 25,\ncolor: const Color(0xfffff188),\nchildren: [\nOrbit(\nradius: 110,\nrevolutionPeriod: 6,\nplanet: Planet(\nradius: 10,\ncolor: const Color(0xff54d7b1),\nchildren: [\nOrbit(\nradius: 25,\nrevolutionPeriod: 5,\nplanet: Planet(radius: 3, color: const Color(0xFFcccccc)),\n),\n],\n),\n),\n],\n),\n]);\n}\n\nfinal hudComponents = <Component>[];\n\n@override\nvoid onMount() {\nhudComponents.addAll([\nBackButton(),\nPauseButton(),\n]);\ngame.camera.viewport.addAll(hudComponents);\n}\n\n@override\nvoid onRemove() {\ngame.camera.viewport.removeAll(hudComponents);\nsuper.onRemove();\n}\n}\n\nclass Level2Page extends DecoratedWorld with HasGameReference {\n@override\nFuture<void> onLoad() async {\naddAll([\nBackground(const Color(0xff052b44)),\nPlanet(\nradius: 30,\ncolor: const Color(0xFFFFFFff),\nchildren: [\nOrbit(\nradius: 60,\nrevolutionPeriod: 5,\nplanet: Planet(radius: 10, color: const Color(0xffc9ce0d)),\n),\nOrbit(\nradius: 110,\nrevolutionPeriod: 10,\nplanet: Planet(\nradius: 14,\ncolor: const Color(0xfff32727),\nchildren: [\nOrbit(\nradius: 26,\nrevolutionPeriod: 3,\nplanet: Planet(radius: 5, color: const Color(0xffffdb00)),\n),\nOrbit(\nradius: 35,\nrevolutionPeriod: 4,\nplanet: Planet(radius: 3, color: const Color(0xffdc00ff)),\n),\n],\n),\n),\n],\n),\n]);\n}\n\nfinal hudComponents = <Component>[];\n\n@override\nvoid onMount() {\nhudComponents.addAll([\nBackButton(),\nPauseButton(),\n]);\ngame.camera.viewport.addAll(hudComponents);\n}\n\n@override\nvoid onRemove() {\ngame.camera.viewport.removeAll(hudComponents);\nsuper.onRemove();\n}\n}\n\nclass Planet extends PositionComponent {\nPlanet({\nrequired this.radius,\nrequired this.color,\nsuper.position,\nsuper.children,\n}) : _paint = Paint()..color = color;\n\nfinal double radius;\nfinal Color color;\nfinal Paint _paint;\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawCircle(Offset.zero, radius, _paint);\n}\n}\n\nclass Orbit extends PositionComponent {\nOrbit({\nrequired this.radius,\nrequired this.planet,\nrequired this.revolutionPeriod,\ndouble initialAngle = 0,\n})  : _paint = Paint()\n..style = PaintingStyle.stroke\n..color = const Color(0x888888aa),\n_angle = initialAngle {\nadd(planet);\n}\n\nfinal double radius;\nfinal double revolutionPeriod;\nfinal Planet planet;\nfinal Paint _paint;\ndouble _angle;\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawCircle(Offset.zero, radius, _paint);\n}\n\n@override\nvoid update(double dt) {\n_angle += dt / revolutionPeriod * tau;\nplanet.position = Vector2(radius, 0)..rotate(_angle);\n}\n}\n\nclass PauseRoute extends Route {\nPauseRoute() : super(PausePage.new, transparent: true);\n\n@override\nvoid onPush(Route? previousRoute) {\nif (previousRoute is WorldRoute && previousRoute.world is DecoratedWorld) {\n(previousRoute.world! as DecoratedWorld).timeScale = 0;\n(previousRoute.world! as DecoratedWorld).decorator =\nPaintDecorator.grayscale(opacity: 0.5)..addBlur(3.0);\n}\n}\n\n@override\nvoid onPop(Route nextRoute) {\nif (nextRoute is WorldRoute && nextRoute.world is DecoratedWorld) {\n(nextRoute.world! as DecoratedWorld).timeScale = 1;\n(nextRoute.world! as DecoratedWorld).decorator = null;\n}\n}\n}\n\nclass PausePage extends Component\nwith TapCallbacks, HasGameReference<RouterGame> {\n@override\nFuture<void> onLoad() async {\nfinal game = findGame()!;\naddAll([\nTextComponent(\ntext: 'PAUSED',\nposition: game.canvasSize / 2,\nanchor: Anchor.center,\nchildren: [\nScaleEffect.to(\nVector2.all(1.1),\nEffectController(\nduration: 0.3,\nalternate: true,\ninfinite: true,\n),\n),\n],\n),\n]);\n}\n\n@override\nbool containsLocalPoint(Vector2 point) => true;\n\n@override\nvoid onTapUp(TapUpEvent event) => game.router.pop();\n}\n\nclass DecoratedWorld extends World with HasTimeScale {\nPaintDecorator? decorator;\n\n@override\nvoid renderFromCamera(Canvas canvas) {\nif (decorator == null) {\nsuper.renderFromCamera(canvas);\n} else {\ndecorator!.applyChain(super.renderFromCamera, canvas);\n}\n}\n}"}
{"prompt": "Show me how to implement : Please click here to go see the documentation for the latest released version. using Flutter Flame", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/geometry.dart';\nimport 'package:flame/rendering.dart';\nimport 'package:flutter/rendering.dart';\n\nclass RouterGame extends FlameGame {\nlate final RouterComponent router;\n\n@override\nFuture<void> onLoad() async {\nadd(\nrouter = RouterComponent(\nroutes: {\n'home': Route(StartPage.new),\n'level1': WorldRoute(Level1Page.new),\n'level2': WorldRoute(Level2Page.new, maintainState: false),\n'pause': PauseRoute(),\n},\ninitialRoute: 'home',\n),\n);\n}\n}\n\nclass StartPage extends Component with HasGameReference<RouterGame> {\nStartPage() {\naddAll([\n_logo = TextComponent(\ntext: 'Your Game',\ntextRenderer: TextPaint(\nstyle: const TextStyle(\nfontSize: 64,\ncolor: Color(0xFFC8FFF5),\nfontWeight: FontWeight.w800,\n),\n),\nanchor: Anchor.center,\n),\n_button1 = RoundedButton(\ntext: 'Level 1',\naction: () => game.router.pushNamed('level1'),\ncolor: const Color(0xffadde6c),\nborderColor: const Color(0xffedffab),\n),\n_button2 = RoundedButton(\ntext: 'Level 2',\naction: () => game.router.pushNamed('level2'),\ncolor: const Color(0xffdebe6c),\nborderColor: const Color(0xfffff4c7),\n),\n]);\n}\n\nlate final TextComponent _logo;\nlate final RoundedButton _button1;\nlate final RoundedButton _button2;\n\n@override\nvoid onGameResize(Vector2 size) {\nsuper.onGameResize(size);\n_logo.position = Vector2(size.x / 2, size.y / 3);\n_button1.position = Vector2(size.x / 2, _logo.y + 80);\n_button2.position = Vector2(size.x / 2, _logo.y + 140);\n}\n}\n\nclass Background extends Component {\nBackground(this.color);\nfinal Color color;\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawColor(color, BlendMode.srcATop);\n}\n}\n\nclass RoundedButton extends PositionComponent with TapCallbacks {\nRoundedButton({\nrequired this.text,\nrequired this.action,\nrequired Color color,\nrequired Color borderColor,\nsuper.position,\nsuper.anchor = Anchor.center,\n}) : _textDrawable = TextPaint(\nstyle: const TextStyle(\nfontSize: 20,\ncolor: Color(0xFF000000),\nfontWeight: FontWeight.w800,\n),\n).toTextPainter(text) {\nsize = Vector2(150, 40);\n_textOffset = Offset(\n(size.x - _textDrawable.width) / 2,\n(size.y - _textDrawable.height) / 2,\n);\n_rrect = RRect.fromLTRBR(0, 0, size.x, size.y, Radius.circular(size.y / 2));\n_bgPaint = Paint()..color = color;\n_borderPaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 2\n..color = borderColor;\n}\n\nfinal String text;\nfinal void Function() action;\nfinal TextPainter _textDrawable;\nlate final Offset _textOffset;\nlate final RRect _rrect;\nlate final Paint _borderPaint;\nlate final Paint _bgPaint;\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRRect(_rrect, _bgPaint);\ncanvas.drawRRect(_rrect, _borderPaint);\n_textDrawable.paint(canvas, _textOffset);\n}\n\n@override\nvoid onTapDown(TapDownEvent event) {\nscale = Vector2.all(1.05);\n}\n\n@override\nvoid onTapUp(TapUpEvent event) {\nscale = Vector2.all(1.0);\naction();\n}\n\n@override\nvoid onTapCancel(TapCancelEvent event) {\nscale = Vector2.all(1.0);\n}\n}\n\nabstract class SimpleButton extends PositionComponent with TapCallbacks {\nSimpleButton(this._iconPath, {super.position}) : super(size: Vector2.all(40));\n\nfinal Paint _borderPaint = Paint()\n..style = PaintingStyle.stroke\n..color = const Color(0x66ffffff);\nfinal Paint _iconPaint = Paint()\n..style = PaintingStyle.stroke\n..color = const Color(0xffaaaaaa)\n..strokeWidth = 7;\nfinal Path _iconPath;\n\nvoid action();\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRRect(\nRRect.fromRectAndRadius(size.toRect(), const Radius.circular(8)),\n_borderPaint,\n);\ncanvas.drawPath(_iconPath, _iconPaint);\n}\n\n@override\nvoid onTapDown(TapDownEvent event) {\n_iconPaint.color = const Color(0xffffffff);\n}\n\n@override\nvoid onTapUp(TapUpEvent event) {\n_iconPaint.color = const Color(0xffaaaaaa);\naction();\n}\n\n@override\nvoid onTapCancel(TapCancelEvent event) {\n_iconPaint.color = const Color(0xffaaaaaa);\n}\n}\n\nclass BackButton extends SimpleButton with HasGameReference<RouterGame> {\nBackButton()\n: super(\nPath()\n..moveTo(22, 8)\n..lineTo(10, 20)\n..lineTo(22, 32)\n..moveTo(12, 20)\n..lineTo(34, 20),\nposition: Vector2.all(10),\n);\n\n@override\nvoid action() => game.router.pop();\n}\n\nclass PauseButton extends SimpleButton with HasGameReference<RouterGame> {\nPauseButton()\n: super(\nPath()\n..moveTo(14, 10)\n..lineTo(14, 30)\n..moveTo(26, 10)\n..lineTo(26, 30),\nposition: Vector2(60, 10),\n);\n\nbool isPaused = false;\n\n@override\nvoid action() {\nif (isPaused) {\ngame.router.pop();\n} else {\ngame.router.pushNamed('pause');\n}\nisPaused = !isPaused;\n}\n}\n\nclass Level1Page extends DecoratedWorld with HasGameReference {\n@override\nFuture<void> onLoad() async {\naddAll([\nBackground(const Color(0xbb2a074f)),\nPlanet(\nradius: 25,\ncolor: const Color(0xfffff188),\nchildren: [\nOrbit(\nradius: 110,\nrevolutionPeriod: 6,\nplanet: Planet(\nradius: 10,\ncolor: const Color(0xff54d7b1),\nchildren: [\nOrbit(\nradius: 25,\nrevolutionPeriod: 5,\nplanet: Planet(radius: 3, color: const Color(0xFFcccccc)),\n),\n],\n),\n),\n],\n),\n]);\n}\n\nfinal hudComponents = <Component>[];\n\n@override\nvoid onMount() {\nhudComponents.addAll([\nBackButton(),\nPauseButton(),\n]);\ngame.camera.viewport.addAll(hudComponents);\n}\n\n@override\nvoid onRemove() {\ngame.camera.viewport.removeAll(hudComponents);\nsuper.onRemove();\n}\n}\n\nclass Level2Page extends DecoratedWorld with HasGameReference {\n@override\nFuture<void> onLoad() async {\naddAll([\nBackground(const Color(0xff052b44)),\nPlanet(\nradius: 30,\ncolor: const Color(0xFFFFFFff),\nchildren: [\nOrbit(\nradius: 60,\nrevolutionPeriod: 5,\nplanet: Planet(radius: 10, color: const Color(0xffc9ce0d)),\n),\nOrbit(\nradius: 110,\nrevolutionPeriod: 10,\nplanet: Planet(\nradius: 14,\ncolor: const Color(0xfff32727),\nchildren: [\nOrbit(\nradius: 26,\nrevolutionPeriod: 3,\nplanet: Planet(radius: 5, color: const Color(0xffffdb00)),\n),\nOrbit(\nradius: 35,\nrevolutionPeriod: 4,\nplanet: Planet(radius: 3, color: const Color(0xffdc00ff)),\n),\n],\n),\n),\n],\n),\n]);\n}\n\nfinal hudComponents = <Component>[];\n\n@override\nvoid onMount() {\nhudComponents.addAll([\nBackButton(),\nPauseButton(),\n]);\ngame.camera.viewport.addAll(hudComponents);\n}\n\n@override\nvoid onRemove() {\ngame.camera.viewport.removeAll(hudComponents);\nsuper.onRemove();\n}\n}\n\nclass Planet extends PositionComponent {\nPlanet({\nrequired this.radius,\nrequired this.color,\nsuper.position,\nsuper.children,\n}) : _paint = Paint()..color = color;\n\nfinal double radius;\nfinal Color color;\nfinal Paint _paint;\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawCircle(Offset.zero, radius, _paint);\n}\n}\n\nclass Orbit extends PositionComponent {\nOrbit({\nrequired this.radius,\nrequired this.planet,\nrequired this.revolutionPeriod,\ndouble initialAngle = 0,\n})  : _paint = Paint()\n..style = PaintingStyle.stroke\n..color = const Color(0x888888aa),\n_angle = initialAngle {\nadd(planet);\n}\n\nfinal double radius;\nfinal double revolutionPeriod;\nfinal Planet planet;\nfinal Paint _paint;\ndouble _angle;\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawCircle(Offset.zero, radius, _paint);\n}\n\n@override\nvoid update(double dt) {\n_angle += dt / revolutionPeriod * tau;\nplanet.position = Vector2(radius, 0)..rotate(_angle);\n}\n}\n\nclass PauseRoute extends Route {\nPauseRoute() : super(PausePage.new, transparent: true);\n\n@override\nvoid onPush(Route? previousRoute) {\nif (previousRoute is WorldRoute && previousRoute.world is DecoratedWorld) {\n(previousRoute.world! as DecoratedWorld).timeScale = 0;\n(previousRoute.world! as DecoratedWorld).decorator =\nPaintDecorator.grayscale(opacity: 0.5)..addBlur(3.0);\n}\n}\n\n@override\nvoid onPop(Route nextRoute) {\nif (nextRoute is WorldRoute && nextRoute.world is DecoratedWorld) {\n(nextRoute.world! as DecoratedWorld).timeScale = 1;\n(nextRoute.world! as DecoratedWorld).decorator = null;\n}\n}\n}\n\nclass PausePage extends Component\nwith TapCallbacks, HasGameReference<RouterGame> {\n@override\nFuture<void> onLoad() async {\nfinal game = findGame()!;\naddAll([\nTextComponent(\ntext: 'PAUSED',\nposition: game.canvasSize / 2,\nanchor: Anchor.center,\nchildren: [\nScaleEffect.to(\nVector2.all(1.1),\nEffectController(\nduration: 0.3,\nalternate: true,\ninfinite: true,\n),\n),\n],\n),\n]);\n}\n\n@override\nbool containsLocalPoint(Vector2 point) => true;\n\n@override\nvoid onTapUp(TapUpEvent event) => game.router.pop();\n}\n\nclass DecoratedWorld extends World with HasTimeScale {\nPaintDecorator? decorator;\n\n@override\nvoid renderFromCamera(Canvas canvas) {\nif (decorator == null) {\nsuper.renderFromCamera(canvas);\n} else {\ndecorator!.applyChain(super.renderFromCamera, canvas);\n}\n}\n}"}
{"prompt": "Write Flutter Flame code to : Please click here to go see the documentation for the latest released version.", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/geometry.dart';\nimport 'package:flame/rendering.dart';\nimport 'package:flutter/rendering.dart';\n\nclass RouterGame extends FlameGame {\nlate final RouterComponent router;\n\n@override\nFuture<void> onLoad() async {\nadd(\nrouter = RouterComponent(\nroutes: {\n'home': Route(StartPage.new),\n'level1': WorldRoute(Level1Page.new),\n'level2': WorldRoute(Level2Page.new, maintainState: false),\n'pause': PauseRoute(),\n},\ninitialRoute: 'home',\n),\n);\n}\n}\n\nclass StartPage extends Component with HasGameReference<RouterGame> {\nStartPage() {\naddAll([\n_logo = TextComponent(\ntext: 'Your Game',\ntextRenderer: TextPaint(\nstyle: const TextStyle(\nfontSize: 64,\ncolor: Color(0xFFC8FFF5),\nfontWeight: FontWeight.w800,\n),\n),\nanchor: Anchor.center,\n),\n_button1 = RoundedButton(\ntext: 'Level 1',\naction: () => game.router.pushNamed('level1'),\ncolor: const Color(0xffadde6c),\nborderColor: const Color(0xffedffab),\n),\n_button2 = RoundedButton(\ntext: 'Level 2',\naction: () => game.router.pushNamed('level2'),\ncolor: const Color(0xffdebe6c),\nborderColor: const Color(0xfffff4c7),\n),\n]);\n}\n\nlate final TextComponent _logo;\nlate final RoundedButton _button1;\nlate final RoundedButton _button2;\n\n@override\nvoid onGameResize(Vector2 size) {\nsuper.onGameResize(size);\n_logo.position = Vector2(size.x / 2, size.y / 3);\n_button1.position = Vector2(size.x / 2, _logo.y + 80);\n_button2.position = Vector2(size.x / 2, _logo.y + 140);\n}\n}\n\nclass Background extends Component {\nBackground(this.color);\nfinal Color color;\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawColor(color, BlendMode.srcATop);\n}\n}\n\nclass RoundedButton extends PositionComponent with TapCallbacks {\nRoundedButton({\nrequired this.text,\nrequired this.action,\nrequired Color color,\nrequired Color borderColor,\nsuper.position,\nsuper.anchor = Anchor.center,\n}) : _textDrawable = TextPaint(\nstyle: const TextStyle(\nfontSize: 20,\ncolor: Color(0xFF000000),\nfontWeight: FontWeight.w800,\n),\n).toTextPainter(text) {\nsize = Vector2(150, 40);\n_textOffset = Offset(\n(size.x - _textDrawable.width) / 2,\n(size.y - _textDrawable.height) / 2,\n);\n_rrect = RRect.fromLTRBR(0, 0, size.x, size.y, Radius.circular(size.y / 2));\n_bgPaint = Paint()..color = color;\n_borderPaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 2\n..color = borderColor;\n}\n\nfinal String text;\nfinal void Function() action;\nfinal TextPainter _textDrawable;\nlate final Offset _textOffset;\nlate final RRect _rrect;\nlate final Paint _borderPaint;\nlate final Paint _bgPaint;\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRRect(_rrect, _bgPaint);\ncanvas.drawRRect(_rrect, _borderPaint);\n_textDrawable.paint(canvas, _textOffset);\n}\n\n@override\nvoid onTapDown(TapDownEvent event) {\nscale = Vector2.all(1.05);\n}\n\n@override\nvoid onTapUp(TapUpEvent event) {\nscale = Vector2.all(1.0);\naction();\n}\n\n@override\nvoid onTapCancel(TapCancelEvent event) {\nscale = Vector2.all(1.0);\n}\n}\n\nabstract class SimpleButton extends PositionComponent with TapCallbacks {\nSimpleButton(this._iconPath, {super.position}) : super(size: Vector2.all(40));\n\nfinal Paint _borderPaint = Paint()\n..style = PaintingStyle.stroke\n..color = const Color(0x66ffffff);\nfinal Paint _iconPaint = Paint()\n..style = PaintingStyle.stroke\n..color = const Color(0xffaaaaaa)\n..strokeWidth = 7;\nfinal Path _iconPath;\n\nvoid action();\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRRect(\nRRect.fromRectAndRadius(size.toRect(), const Radius.circular(8)),\n_borderPaint,\n);\ncanvas.drawPath(_iconPath, _iconPaint);\n}\n\n@override\nvoid onTapDown(TapDownEvent event) {\n_iconPaint.color = const Color(0xffffffff);\n}\n\n@override\nvoid onTapUp(TapUpEvent event) {\n_iconPaint.color = const Color(0xffaaaaaa);\naction();\n}\n\n@override\nvoid onTapCancel(TapCancelEvent event) {\n_iconPaint.color = const Color(0xffaaaaaa);\n}\n}\n\nclass BackButton extends SimpleButton with HasGameReference<RouterGame> {\nBackButton()\n: super(\nPath()\n..moveTo(22, 8)\n..lineTo(10, 20)\n..lineTo(22, 32)\n..moveTo(12, 20)\n..lineTo(34, 20),\nposition: Vector2.all(10),\n);\n\n@override\nvoid action() => game.router.pop();\n}\n\nclass PauseButton extends SimpleButton with HasGameReference<RouterGame> {\nPauseButton()\n: super(\nPath()\n..moveTo(14, 10)\n..lineTo(14, 30)\n..moveTo(26, 10)\n..lineTo(26, 30),\nposition: Vector2(60, 10),\n);\n\nbool isPaused = false;\n\n@override\nvoid action() {\nif (isPaused) {\ngame.router.pop();\n} else {\ngame.router.pushNamed('pause');\n}\nisPaused = !isPaused;\n}\n}\n\nclass Level1Page extends DecoratedWorld with HasGameReference {\n@override\nFuture<void> onLoad() async {\naddAll([\nBackground(const Color(0xbb2a074f)),\nPlanet(\nradius: 25,\ncolor: const Color(0xfffff188),\nchildren: [\nOrbit(\nradius: 110,\nrevolutionPeriod: 6,\nplanet: Planet(\nradius: 10,\ncolor: const Color(0xff54d7b1),\nchildren: [\nOrbit(\nradius: 25,\nrevolutionPeriod: 5,\nplanet: Planet(radius: 3, color: const Color(0xFFcccccc)),\n),\n],\n),\n),\n],\n),\n]);\n}\n\nfinal hudComponents = <Component>[];\n\n@override\nvoid onMount() {\nhudComponents.addAll([\nBackButton(),\nPauseButton(),\n]);\ngame.camera.viewport.addAll(hudComponents);\n}\n\n@override\nvoid onRemove() {\ngame.camera.viewport.removeAll(hudComponents);\nsuper.onRemove();\n}\n}\n\nclass Level2Page extends DecoratedWorld with HasGameReference {\n@override\nFuture<void> onLoad() async {\naddAll([\nBackground(const Color(0xff052b44)),\nPlanet(\nradius: 30,\ncolor: const Color(0xFFFFFFff),\nchildren: [\nOrbit(\nradius: 60,\nrevolutionPeriod: 5,\nplanet: Planet(radius: 10, color: const Color(0xffc9ce0d)),\n),\nOrbit(\nradius: 110,\nrevolutionPeriod: 10,\nplanet: Planet(\nradius: 14,\ncolor: const Color(0xfff32727),\nchildren: [\nOrbit(\nradius: 26,\nrevolutionPeriod: 3,\nplanet: Planet(radius: 5, color: const Color(0xffffdb00)),\n),\nOrbit(\nradius: 35,\nrevolutionPeriod: 4,\nplanet: Planet(radius: 3, color: const Color(0xffdc00ff)),\n),\n],\n),\n),\n],\n),\n]);\n}\n\nfinal hudComponents = <Component>[];\n\n@override\nvoid onMount() {\nhudComponents.addAll([\nBackButton(),\nPauseButton(),\n]);\ngame.camera.viewport.addAll(hudComponents);\n}\n\n@override\nvoid onRemove() {\ngame.camera.viewport.removeAll(hudComponents);\nsuper.onRemove();\n}\n}\n\nclass Planet extends PositionComponent {\nPlanet({\nrequired this.radius,\nrequired this.color,\nsuper.position,\nsuper.children,\n}) : _paint = Paint()..color = color;\n\nfinal double radius;\nfinal Color color;\nfinal Paint _paint;\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawCircle(Offset.zero, radius, _paint);\n}\n}\n\nclass Orbit extends PositionComponent {\nOrbit({\nrequired this.radius,\nrequired this.planet,\nrequired this.revolutionPeriod,\ndouble initialAngle = 0,\n})  : _paint = Paint()\n..style = PaintingStyle.stroke\n..color = const Color(0x888888aa),\n_angle = initialAngle {\nadd(planet);\n}\n\nfinal double radius;\nfinal double revolutionPeriod;\nfinal Planet planet;\nfinal Paint _paint;\ndouble _angle;\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawCircle(Offset.zero, radius, _paint);\n}\n\n@override\nvoid update(double dt) {\n_angle += dt / revolutionPeriod * tau;\nplanet.position = Vector2(radius, 0)..rotate(_angle);\n}\n}\n\nclass PauseRoute extends Route {\nPauseRoute() : super(PausePage.new, transparent: true);\n\n@override\nvoid onPush(Route? previousRoute) {\nif (previousRoute is WorldRoute && previousRoute.world is DecoratedWorld) {\n(previousRoute.world! as DecoratedWorld).timeScale = 0;\n(previousRoute.world! as DecoratedWorld).decorator =\nPaintDecorator.grayscale(opacity: 0.5)..addBlur(3.0);\n}\n}\n\n@override\nvoid onPop(Route nextRoute) {\nif (nextRoute is WorldRoute && nextRoute.world is DecoratedWorld) {\n(nextRoute.world! as DecoratedWorld).timeScale = 1;\n(nextRoute.world! as DecoratedWorld).decorator = null;\n}\n}\n}\n\nclass PausePage extends Component\nwith TapCallbacks, HasGameReference<RouterGame> {\n@override\nFuture<void> onLoad() async {\nfinal game = findGame()!;\naddAll([\nTextComponent(\ntext: 'PAUSED',\nposition: game.canvasSize / 2,\nanchor: Anchor.center,\nchildren: [\nScaleEffect.to(\nVector2.all(1.1),\nEffectController(\nduration: 0.3,\nalternate: true,\ninfinite: true,\n),\n),\n],\n),\n]);\n}\n\n@override\nbool containsLocalPoint(Vector2 point) => true;\n\n@override\nvoid onTapUp(TapUpEvent event) => game.router.pop();\n}\n\nclass DecoratedWorld extends World with HasTimeScale {\nPaintDecorator? decorator;\n\n@override\nvoid renderFromCamera(Canvas canvas) {\nif (decorator == null) {\nsuper.renderFromCamera(canvas);\n} else {\ndecorator!.applyChain(super.renderFromCamera, canvas);\n}\n}\n}"}
{"prompt": "Create a Flutter Flame game component that RouterComponent¶: Usage example:", "completion": "class MyGame extends FlameGame {\n  late final RouterComponent router;\n\n  @override\n  void onLoad() {\n    add(\n      router = RouterComponent(\n        routes: {\n          'home': Route(HomePage.new),\n          'level-selector': Route(LevelSelectorPage.new),\n          'settings': Route(SettingsPage.new, transparent: true),\n          'pause': PauseRoute(),\n          'confirm-dialog': OverlayRoute.existing(),\n        },\n        initialRoute: 'home',\n      ),\n    );\n  }\n}\n\nclass PauseRoute extends Route { ... }"}
{"prompt": "Show me how to implement RouterComponent¶: Usage example: using Flutter Flame", "completion": "class MyGame extends FlameGame {\n  late final RouterComponent router;\n\n  @override\n  void onLoad() {\n    add(\n      router = RouterComponent(\n        routes: {\n          'home': Route(HomePage.new),\n          'level-selector': Route(LevelSelectorPage.new),\n          'settings': Route(SettingsPage.new, transparent: true),\n          'pause': PauseRoute(),\n          'confirm-dialog': OverlayRoute.existing(),\n        },\n        initialRoute: 'home',\n      ),\n    );\n  }\n}\n\nclass PauseRoute extends Route { ... }"}
{"prompt": "Write Flutter Flame code to RouterComponent¶: Usage example:", "completion": "class MyGame extends FlameGame {\n  late final RouterComponent router;\n\n  @override\n  void onLoad() {\n    add(\n      router = RouterComponent(\n        routes: {\n          'home': Route(HomePage.new),\n          'level-selector': Route(LevelSelectorPage.new),\n          'settings': Route(SettingsPage.new, transparent: true),\n          'pause': PauseRoute(),\n          'confirm-dialog': OverlayRoute.existing(),\n        },\n        initialRoute: 'home',\n      ),\n    );\n  }\n}\n\nclass PauseRoute extends Route { ... }"}
{"prompt": "Create a Flutter Flame game component that WorldRoute¶: If you are not using the built-in CameraComponent you can pass in the camera that you want to use explicitly in the constructor.", "completion": "final router = RouterComponent(\n  routes: {\n    'level1': WorldRoute(MyWorld1.new),\n    'level2': WorldRoute(MyWorld2.new, maintainState: false),\n  },\n);\n\nclass MyWorld1 extends World {\n  @override\n  Future<void> onLoad() async {\n    add(BackgroundComponent());\n    add(PlayerComponent());\n  }\n}\n\nclass MyWorld2 extends World {\n   @override\n   Future<void> onLoad() async {\n      add(BackgroundComponent());\n      add(PlayerComponent());\n      add(EnemyComponent());\n   }\n}"}
{"prompt": "Show me how to implement WorldRoute¶: If you are not using the built-in CameraComponent you can pass in the camera that you want to use explicitly in the constructor. using Flutter Flame", "completion": "final router = RouterComponent(\n  routes: {\n    'level1': WorldRoute(MyWorld1.new),\n    'level2': WorldRoute(MyWorld2.new, maintainState: false),\n  },\n);\n\nclass MyWorld1 extends World {\n  @override\n  Future<void> onLoad() async {\n    add(BackgroundComponent());\n    add(PlayerComponent());\n  }\n}\n\nclass MyWorld2 extends World {\n   @override\n   Future<void> onLoad() async {\n      add(BackgroundComponent());\n      add(PlayerComponent());\n      add(EnemyComponent());\n   }\n}"}
{"prompt": "Write Flutter Flame code to WorldRoute¶: If you are not using the built-in CameraComponent you can pass in the camera that you want to use explicitly in the constructor.", "completion": "final router = RouterComponent(\n  routes: {\n    'level1': WorldRoute(MyWorld1.new),\n    'level2': WorldRoute(MyWorld2.new, maintainState: false),\n  },\n);\n\nclass MyWorld1 extends World {\n  @override\n  Future<void> onLoad() async {\n    add(BackgroundComponent());\n    add(PlayerComponent());\n  }\n}\n\nclass MyWorld2 extends World {\n   @override\n   Future<void> onLoad() async {\n      add(BackgroundComponent());\n      add(PlayerComponent());\n      add(EnemyComponent());\n   }\n}"}
{"prompt": "Create a Flutter Flame game component that OverlayRoute¶: There are two constructors for the OverlayRoute. The first constructor requires a builder function that describes how the overlay’s widget is to be built. The second constructor can be used when the builder function was already specified within the GameWidget:", "completion": "final router = RouterComponent(\n  routes: {\n    'ok-dialog': OverlayRoute(\n      (context, game) {\n        return Center(\n          child: DecoratedContainer(...),\n        );\n      },\n    ),  // OverlayRoute\n    'confirm-dialog': OverlayRoute.existing(),\n  },\n);"}
{"prompt": "Show me how to implement OverlayRoute¶: There are two constructors for the OverlayRoute. The first constructor requires a builder function that describes how the overlay’s widget is to be built. The second constructor can be used when the builder function was already specified within the GameWidget: using Flutter Flame", "completion": "final router = RouterComponent(\n  routes: {\n    'ok-dialog': OverlayRoute(\n      (context, game) {\n        return Center(\n          child: DecoratedContainer(...),\n        );\n      },\n    ),  // OverlayRoute\n    'confirm-dialog': OverlayRoute.existing(),\n  },\n);"}
{"prompt": "Write Flutter Flame code to OverlayRoute¶: There are two constructors for the OverlayRoute. The first constructor requires a builder function that describes how the overlay’s widget is to be built. The second constructor can be used when the builder function was already specified within the GameWidget:", "completion": "final router = RouterComponent(\n  routes: {\n    'ok-dialog': OverlayRoute(\n      (context, game) {\n        return Center(\n          child: DecoratedContainer(...),\n        );\n      },\n    ),  // OverlayRoute\n    'confirm-dialog': OverlayRoute.existing(),\n  },\n);"}
{"prompt": "Create a Flutter Flame game component that ValueRoute¶: The current overlay can be replaced using pushReplacementOverlay. This method executes pushReplacementNamed or pushReplacement based on the status of the overlay being pushed.", "completion": "import 'dart:math';\nimport 'dart:ui';\n\nimport 'package:doc_flame_examples/router.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/geometry.dart';\n\nclass ValueRouteExample extends FlameGame {\nlate final RouterComponent router;\n\n@override\nFuture<void> onLoad() async {\nrouter = RouterComponent(\nroutes: {'home': Route(HomePage.new)},\ninitialRoute: 'home',\n);\nadd(router);\n}\n}\n\nclass HomePage extends Component with HasGameReference<ValueRouteExample> {\n@override\nFuture<void> onLoad() async {\nadd(\nRoundedButton(\ntext: 'Rate me',\naction: () async {\nfinal score = await game.router.pushAndWait(RateRoute());\nfirstChild<TextComponent>()!.text = 'Score: $score';\n},\ncolor: const Color(0xff758f9a),\nborderColor: const Color(0xff60d5ff),\n)..position = game.size / 2,\n);\nadd(\nTextComponent(\ntext: 'Score: –',\nanchor: Anchor.topCenter,\nposition: game.size / 2 + Vector2(0, 30),\nscale: Vector2.all(0.7),\n),\n);\n}\n}\n\nclass RateRoute extends ValueRoute<int>\nwith HasGameReference<ValueRouteExample> {\nRateRoute() : super(value: -1, transparent: true);\n\n@override\nComponent build() {\nfinal size = Vector2(250, 130);\nconst radius = 18.0;\nfinal starGap = (size.x - 5 * 2 * radius) / 6;\nreturn DialogBackground(\nposition: game.size / 2,\nsize: size,\nchildren: [\nRoundedButton(\ntext: 'Ok',\nposition: position = Vector2(size.x / 2, 100),\naction: () {\ncompleteWith(\ndescendants().where((c) => c is Star && c.active).length,\n);\n},\ncolor: const Color(0xFFFFFFFF),\nborderColor: const Color(0xFF000000),\n),\nfor (var i = 0; i < 5; i++)\nStar(\nvalue: i + 1,\nradius: radius,\nposition: Vector2(starGap * (i + 1) + radius * (2 * i + 1), 40),\n),\n],\n);\n}\n}\n\nclass DialogBackground extends RectangleComponent with TapCallbacks {\nDialogBackground({super.position, super.size, super.children})\n: super(\nanchor: Anchor.center,\npaint: Paint()..color = const Color(0xee858585),\n);\n}\n\nclass Star extends PositionComponent with TapCallbacks {\nStar({required this.value, required this.radius, super.position})\n: super(size: Vector2.all(2 * radius), anchor: Anchor.center);\n\nfinal int value;\nfinal double radius;\nfinal Path path = Path();\nfinal Paint borderPaint = Paint()\n..style = PaintingStyle.stroke\n..color = const Color(0xffffe395)\n..strokeWidth = 2;\nfinal Paint fillPaint = Paint()..color = const Color(0xffffe395);\nbool active = false;\n\n@override\nFuture<void> onLoad() async {\npath.moveTo(radius, 0);\nfor (var i = 0; i < 5; i++) {\npath.lineTo(\nradius + 0.6 * radius * sin(tau / 5 * (i + 0.5)),\nradius - 0.6 * radius * cos(tau / 5 * (i + 0.5)),\n);\npath.lineTo(\nradius + radius * sin(tau / 5 * (i + 1)),\nradius - radius * cos(tau / 5 * (i + 1)),\n);\n}\npath.close();\n}\n\n@override\nvoid render(Canvas canvas) {\nif (active) {\ncanvas.drawPath(path, fillPaint);\n}\ncanvas.drawPath(path, borderPaint);\n}\n\n@override\nvoid onTapDown(TapDownEvent event) {\nvar on = true;\nfor (final star in parent!.children.whereType<Star>()) {\nstar.active = on;\nif (star == this) {\non = false;\n}\n}\n}\n}"}
{"prompt": "Show me how to implement ValueRoute¶: The current overlay can be replaced using pushReplacementOverlay. This method executes pushReplacementNamed or pushReplacement based on the status of the overlay being pushed. using Flutter Flame", "completion": "import 'dart:math';\nimport 'dart:ui';\n\nimport 'package:doc_flame_examples/router.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/geometry.dart';\n\nclass ValueRouteExample extends FlameGame {\nlate final RouterComponent router;\n\n@override\nFuture<void> onLoad() async {\nrouter = RouterComponent(\nroutes: {'home': Route(HomePage.new)},\ninitialRoute: 'home',\n);\nadd(router);\n}\n}\n\nclass HomePage extends Component with HasGameReference<ValueRouteExample> {\n@override\nFuture<void> onLoad() async {\nadd(\nRoundedButton(\ntext: 'Rate me',\naction: () async {\nfinal score = await game.router.pushAndWait(RateRoute());\nfirstChild<TextComponent>()!.text = 'Score: $score';\n},\ncolor: const Color(0xff758f9a),\nborderColor: const Color(0xff60d5ff),\n)..position = game.size / 2,\n);\nadd(\nTextComponent(\ntext: 'Score: –',\nanchor: Anchor.topCenter,\nposition: game.size / 2 + Vector2(0, 30),\nscale: Vector2.all(0.7),\n),\n);\n}\n}\n\nclass RateRoute extends ValueRoute<int>\nwith HasGameReference<ValueRouteExample> {\nRateRoute() : super(value: -1, transparent: true);\n\n@override\nComponent build() {\nfinal size = Vector2(250, 130);\nconst radius = 18.0;\nfinal starGap = (size.x - 5 * 2 * radius) / 6;\nreturn DialogBackground(\nposition: game.size / 2,\nsize: size,\nchildren: [\nRoundedButton(\ntext: 'Ok',\nposition: position = Vector2(size.x / 2, 100),\naction: () {\ncompleteWith(\ndescendants().where((c) => c is Star && c.active).length,\n);\n},\ncolor: const Color(0xFFFFFFFF),\nborderColor: const Color(0xFF000000),\n),\nfor (var i = 0; i < 5; i++)\nStar(\nvalue: i + 1,\nradius: radius,\nposition: Vector2(starGap * (i + 1) + radius * (2 * i + 1), 40),\n),\n],\n);\n}\n}\n\nclass DialogBackground extends RectangleComponent with TapCallbacks {\nDialogBackground({super.position, super.size, super.children})\n: super(\nanchor: Anchor.center,\npaint: Paint()..color = const Color(0xee858585),\n);\n}\n\nclass Star extends PositionComponent with TapCallbacks {\nStar({required this.value, required this.radius, super.position})\n: super(size: Vector2.all(2 * radius), anchor: Anchor.center);\n\nfinal int value;\nfinal double radius;\nfinal Path path = Path();\nfinal Paint borderPaint = Paint()\n..style = PaintingStyle.stroke\n..color = const Color(0xffffe395)\n..strokeWidth = 2;\nfinal Paint fillPaint = Paint()..color = const Color(0xffffe395);\nbool active = false;\n\n@override\nFuture<void> onLoad() async {\npath.moveTo(radius, 0);\nfor (var i = 0; i < 5; i++) {\npath.lineTo(\nradius + 0.6 * radius * sin(tau / 5 * (i + 0.5)),\nradius - 0.6 * radius * cos(tau / 5 * (i + 0.5)),\n);\npath.lineTo(\nradius + radius * sin(tau / 5 * (i + 1)),\nradius - radius * cos(tau / 5 * (i + 1)),\n);\n}\npath.close();\n}\n\n@override\nvoid render(Canvas canvas) {\nif (active) {\ncanvas.drawPath(path, fillPaint);\n}\ncanvas.drawPath(path, borderPaint);\n}\n\n@override\nvoid onTapDown(TapDownEvent event) {\nvar on = true;\nfor (final star in parent!.children.whereType<Star>()) {\nstar.active = on;\nif (star == this) {\non = false;\n}\n}\n}\n}"}
{"prompt": "Write Flutter Flame code to ValueRoute¶: The current overlay can be replaced using pushReplacementOverlay. This method executes pushReplacementNamed or pushReplacement based on the status of the overlay being pushed.", "completion": "import 'dart:math';\nimport 'dart:ui';\n\nimport 'package:doc_flame_examples/router.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/geometry.dart';\n\nclass ValueRouteExample extends FlameGame {\nlate final RouterComponent router;\n\n@override\nFuture<void> onLoad() async {\nrouter = RouterComponent(\nroutes: {'home': Route(HomePage.new)},\ninitialRoute: 'home',\n);\nadd(router);\n}\n}\n\nclass HomePage extends Component with HasGameReference<ValueRouteExample> {\n@override\nFuture<void> onLoad() async {\nadd(\nRoundedButton(\ntext: 'Rate me',\naction: () async {\nfinal score = await game.router.pushAndWait(RateRoute());\nfirstChild<TextComponent>()!.text = 'Score: $score';\n},\ncolor: const Color(0xff758f9a),\nborderColor: const Color(0xff60d5ff),\n)..position = game.size / 2,\n);\nadd(\nTextComponent(\ntext: 'Score: –',\nanchor: Anchor.topCenter,\nposition: game.size / 2 + Vector2(0, 30),\nscale: Vector2.all(0.7),\n),\n);\n}\n}\n\nclass RateRoute extends ValueRoute<int>\nwith HasGameReference<ValueRouteExample> {\nRateRoute() : super(value: -1, transparent: true);\n\n@override\nComponent build() {\nfinal size = Vector2(250, 130);\nconst radius = 18.0;\nfinal starGap = (size.x - 5 * 2 * radius) / 6;\nreturn DialogBackground(\nposition: game.size / 2,\nsize: size,\nchildren: [\nRoundedButton(\ntext: 'Ok',\nposition: position = Vector2(size.x / 2, 100),\naction: () {\ncompleteWith(\ndescendants().where((c) => c is Star && c.active).length,\n);\n},\ncolor: const Color(0xFFFFFFFF),\nborderColor: const Color(0xFF000000),\n),\nfor (var i = 0; i < 5; i++)\nStar(\nvalue: i + 1,\nradius: radius,\nposition: Vector2(starGap * (i + 1) + radius * (2 * i + 1), 40),\n),\n],\n);\n}\n}\n\nclass DialogBackground extends RectangleComponent with TapCallbacks {\nDialogBackground({super.position, super.size, super.children})\n: super(\nanchor: Anchor.center,\npaint: Paint()..color = const Color(0xee858585),\n);\n}\n\nclass Star extends PositionComponent with TapCallbacks {\nStar({required this.value, required this.radius, super.position})\n: super(size: Vector2.all(2 * radius), anchor: Anchor.center);\n\nfinal int value;\nfinal double radius;\nfinal Path path = Path();\nfinal Paint borderPaint = Paint()\n..style = PaintingStyle.stroke\n..color = const Color(0xffffe395)\n..strokeWidth = 2;\nfinal Paint fillPaint = Paint()..color = const Color(0xffffe395);\nbool active = false;\n\n@override\nFuture<void> onLoad() async {\npath.moveTo(radius, 0);\nfor (var i = 0; i < 5; i++) {\npath.lineTo(\nradius + 0.6 * radius * sin(tau / 5 * (i + 0.5)),\nradius - 0.6 * radius * cos(tau / 5 * (i + 0.5)),\n);\npath.lineTo(\nradius + radius * sin(tau / 5 * (i + 1)),\nradius - radius * cos(tau / 5 * (i + 1)),\n);\n}\npath.close();\n}\n\n@override\nvoid render(Canvas canvas) {\nif (active) {\ncanvas.drawPath(path, fillPaint);\n}\ncanvas.drawPath(path, borderPaint);\n}\n\n@override\nvoid onTapDown(TapDownEvent event) {\nvar on = true;\nfor (final star in parent!.children.whereType<Star>()) {\nstar.active = on;\nif (star == this) {\non = false;\n}\n}\n}\n}"}
{"prompt": "Create a Flutter Flame game component that ValueRoute¶: Create a route derived from the ValueRoute<T> class, where T is the type of the value that your route will return. Inside that class override the build() method to construct the component that will be displayed. The component should use the completeWith(value) method to pop the route and return the specified value.", "completion": "class YesNoDialog extends ValueRoute<bool> {\n  YesNoDialog(this.text) : super(value: false);\n  final String text;\n\n  @override\n  Component build() {\n    return PositionComponent(\n      children: [\n        RectangleComponent(),\n        TextComponent(text: text),\n        Button(\n          text: 'Yes',\n          action: () => completeWith(true),\n        ),\n        Button(\n          text: 'No',\n          action: () => completeWith(false),\n        ),\n      ],\n    );\n  }\n}"}
{"prompt": "Show me how to implement ValueRoute¶: Create a route derived from the ValueRoute<T> class, where T is the type of the value that your route will return. Inside that class override the build() method to construct the component that will be displayed. The component should use the completeWith(value) method to pop the route and return the specified value. using Flutter Flame", "completion": "class YesNoDialog extends ValueRoute<bool> {\n  YesNoDialog(this.text) : super(value: false);\n  final String text;\n\n  @override\n  Component build() {\n    return PositionComponent(\n      children: [\n        RectangleComponent(),\n        TextComponent(text: text),\n        Button(\n          text: 'Yes',\n          action: () => completeWith(true),\n        ),\n        Button(\n          text: 'No',\n          action: () => completeWith(false),\n        ),\n      ],\n    );\n  }\n}"}
{"prompt": "Write Flutter Flame code to ValueRoute¶: Create a route derived from the ValueRoute<T> class, where T is the type of the value that your route will return. Inside that class override the build() method to construct the component that will be displayed. The component should use the completeWith(value) method to pop the route and return the specified value.", "completion": "class YesNoDialog extends ValueRoute<bool> {\n  YesNoDialog(this.text) : super(value: false);\n  final String text;\n\n  @override\n  Component build() {\n    return PositionComponent(\n      children: [\n        RectangleComponent(),\n        TextComponent(text: text),\n        Button(\n          text: 'Yes',\n          action: () => completeWith(true),\n        ),\n        Button(\n          text: 'No',\n          action: () => completeWith(false),\n        ),\n      ],\n    );\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Adding bullets¶: First, let’s create a Bullet component that will represent the shots in the game.", "completion": "class Bullet extends SpriteAnimationComponent\n    with HasGameReference<SpaceShooterGame> {\n  Bullet({\n    super.position,\n  }) : super(\n          size: Vector2(25, 50),\n          anchor: Anchor.center,\n        );\n\n  @override\n  Future<void> onLoad() async {\n    await super.onLoad();\n\n    animation = await game.loadSpriteAnimation(\n      'bullet.png',\n      SpriteAnimationData.sequenced(\n        amount: 4,\n        stepTime: .2,\n        textureSize: Vector2(8, 16),\n      ),\n    );\n  }\n}"}
{"prompt": "Show me how to implement Adding bullets¶: First, let’s create a Bullet component that will represent the shots in the game. using Flutter Flame", "completion": "class Bullet extends SpriteAnimationComponent\n    with HasGameReference<SpaceShooterGame> {\n  Bullet({\n    super.position,\n  }) : super(\n          size: Vector2(25, 50),\n          anchor: Anchor.center,\n        );\n\n  @override\n  Future<void> onLoad() async {\n    await super.onLoad();\n\n    animation = await game.loadSpriteAnimation(\n      'bullet.png',\n      SpriteAnimationData.sequenced(\n        amount: 4,\n        stepTime: .2,\n        textureSize: Vector2(8, 16),\n      ),\n    );\n  }\n}"}
{"prompt": "Write Flutter Flame code to Adding bullets¶: First, let’s create a Bullet component that will represent the shots in the game.", "completion": "class Bullet extends SpriteAnimationComponent\n    with HasGameReference<SpaceShooterGame> {\n  Bullet({\n    super.position,\n  }) : super(\n          size: Vector2(25, 50),\n          anchor: Anchor.center,\n        );\n\n  @override\n  Future<void> onLoad() async {\n    await super.onLoad();\n\n    animation = await game.loadSpriteAnimation(\n      'bullet.png',\n      SpriteAnimationData.sequenced(\n        amount: 4,\n        stepTime: .2,\n        textureSize: Vector2(8, 16),\n      ),\n    );\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Adding bullets¶: The Bullet behavior is a simple one, it always moves towards the top of the screen and should be removed from the game if it is not visible anymore, so let’s add an update method to it and make it happen:", "completion": "class Bullet extends SpriteAnimationComponent\n    with HasGameReference<SpaceShooterGame> {\n  Bullet({\n    super.position,\n  }) : super(\n          size: Vector2(25, 50),\n          anchor: Anchor.center,\n        );\n\n  @override\n  Future<void> onLoad() async {\n    // Omitted\n  }\n\n  @override\n  void update(double dt) {\n    super.update(dt);\n\n    position.y += dt * -500;\n\n    if (position.y < -height) {\n      removeFromParent();\n    }\n  }\n}"}
{"prompt": "Show me how to implement Adding bullets¶: The Bullet behavior is a simple one, it always moves towards the top of the screen and should be removed from the game if it is not visible anymore, so let’s add an update method to it and make it happen: using Flutter Flame", "completion": "class Bullet extends SpriteAnimationComponent\n    with HasGameReference<SpaceShooterGame> {\n  Bullet({\n    super.position,\n  }) : super(\n          size: Vector2(25, 50),\n          anchor: Anchor.center,\n        );\n\n  @override\n  Future<void> onLoad() async {\n    // Omitted\n  }\n\n  @override\n  void update(double dt) {\n    super.update(dt);\n\n    position.y += dt * -500;\n\n    if (position.y < -height) {\n      removeFromParent();\n    }\n  }\n}"}
{"prompt": "Write Flutter Flame code to Adding bullets¶: The Bullet behavior is a simple one, it always moves towards the top of the screen and should be removed from the game if it is not visible anymore, so let’s add an update method to it and make it happen:", "completion": "class Bullet extends SpriteAnimationComponent\n    with HasGameReference<SpaceShooterGame> {\n  Bullet({\n    super.position,\n  }) : super(\n          size: Vector2(25, 50),\n          anchor: Anchor.center,\n        );\n\n  @override\n  Future<void> onLoad() async {\n    // Omitted\n  }\n\n  @override\n  void update(double dt) {\n    super.update(dt);\n\n    position.y += dt * -500;\n\n    if (position.y < -height) {\n      removeFromParent();\n    }\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Adding bullets¶: Right, we now have a Bullet class ready, so lets start to implement the action of shooting. First thing, let’s create two empty methods in the Player class, startShooting() and stopShooting().", "completion": "class Player extends SpriteAnimationComponent\n    with HasGameReference<SpaceShooterGame> {\n\n  // Rest of implementation omitted\n\n  void startShooting() {\n    // TODO\n  }\n\n  void stopShooting() {\n    // TODO\n  }\n}"}
{"prompt": "Show me how to implement Adding bullets¶: Right, we now have a Bullet class ready, so lets start to implement the action of shooting. First thing, let’s create two empty methods in the Player class, startShooting() and stopShooting(). using Flutter Flame", "completion": "class Player extends SpriteAnimationComponent\n    with HasGameReference<SpaceShooterGame> {\n\n  // Rest of implementation omitted\n\n  void startShooting() {\n    // TODO\n  }\n\n  void stopShooting() {\n    // TODO\n  }\n}"}
{"prompt": "Write Flutter Flame code to Adding bullets¶: Right, we now have a Bullet class ready, so lets start to implement the action of shooting. First thing, let’s create two empty methods in the Player class, startShooting() and stopShooting().", "completion": "class Player extends SpriteAnimationComponent\n    with HasGameReference<SpaceShooterGame> {\n\n  // Rest of implementation omitted\n\n  void startShooting() {\n    // TODO\n  }\n\n  void stopShooting() {\n    // TODO\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Adding bullets¶: And let’s hook into those methods from the game class by using the onPanStart() and onPanEnd() methods from the PanDetector mixin that we already have been using for the ship movement:", "completion": "class SpaceShooterGame extends FlameGame with PanDetector {\n  late Player player;\n\n  // Rest of implementation omitted\n\n  @override\n  void onPanUpdate(DragUpdateInfo info) {\n    player.move(info.delta.global);\n  }\n\n  @override\n  void onPanStart(DragStartInfo info) {\n    player.startShooting();\n  }\n\n  @override\n  void onPanEnd(DragEndInfo info) {\n    player.stopShooting();\n  }\n}"}
{"prompt": "Show me how to implement Adding bullets¶: And let’s hook into those methods from the game class by using the onPanStart() and onPanEnd() methods from the PanDetector mixin that we already have been using for the ship movement: using Flutter Flame", "completion": "class SpaceShooterGame extends FlameGame with PanDetector {\n  late Player player;\n\n  // Rest of implementation omitted\n\n  @override\n  void onPanUpdate(DragUpdateInfo info) {\n    player.move(info.delta.global);\n  }\n\n  @override\n  void onPanStart(DragStartInfo info) {\n    player.startShooting();\n  }\n\n  @override\n  void onPanEnd(DragEndInfo info) {\n    player.stopShooting();\n  }\n}"}
{"prompt": "Write Flutter Flame code to Adding bullets¶: And let’s hook into those methods from the game class by using the onPanStart() and onPanEnd() methods from the PanDetector mixin that we already have been using for the ship movement:", "completion": "class SpaceShooterGame extends FlameGame with PanDetector {\n  late Player player;\n\n  // Rest of implementation omitted\n\n  @override\n  void onPanUpdate(DragUpdateInfo info) {\n    player.move(info.delta.global);\n  }\n\n  @override\n  void onPanStart(DragStartInfo info) {\n    player.startShooting();\n  }\n\n  @override\n  void onPanEnd(DragEndInfo info) {\n    player.stopShooting();\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Adding bullets¶: We could implement the time interval code and the spawning manually, but Flame provides a component out of the box for that, the SpawnComponent, so let’s take advantage of it:", "completion": "class Player extends SpriteAnimationComponent\n    with HasGameReference<SpaceShooterGame> {\n  late final SpawnComponent _bulletSpawner;\n\n  @override\n  Future<void> onLoad() async {\n    // Loading animation omitted\n\n    _bulletSpawner = SpawnComponent(\n      period: .2,\n      selfPositioning: true,\n      factory: (index) {\n        return Bullet(\n          position: position +\n              Vector2(\n,\n                -height / 2,\n              ),\n        );\n\n        return bullet;\n      },\n      autoStart: false,\n    );\n\n    game.add(_bulletSpawner);\n  }\n\n  void move(Vector2 delta) {\n    position.add(delta);\n  }\n\n  void startShooting() {\n    _bulletSpawner.timer.start();\n  }\n\n  void stopShooting() {\n    _bulletSpawner.timer.stop();\n  }\n}"}
{"prompt": "Show me how to implement Adding bullets¶: We could implement the time interval code and the spawning manually, but Flame provides a component out of the box for that, the SpawnComponent, so let’s take advantage of it: using Flutter Flame", "completion": "class Player extends SpriteAnimationComponent\n    with HasGameReference<SpaceShooterGame> {\n  late final SpawnComponent _bulletSpawner;\n\n  @override\n  Future<void> onLoad() async {\n    // Loading animation omitted\n\n    _bulletSpawner = SpawnComponent(\n      period: .2,\n      selfPositioning: true,\n      factory: (index) {\n        return Bullet(\n          position: position +\n              Vector2(\n,\n                -height / 2,\n              ),\n        );\n\n        return bullet;\n      },\n      autoStart: false,\n    );\n\n    game.add(_bulletSpawner);\n  }\n\n  void move(Vector2 delta) {\n    position.add(delta);\n  }\n\n  void startShooting() {\n    _bulletSpawner.timer.start();\n  }\n\n  void stopShooting() {\n    _bulletSpawner.timer.stop();\n  }\n}"}
{"prompt": "Write Flutter Flame code to Adding bullets¶: We could implement the time interval code and the spawning manually, but Flame provides a component out of the box for that, the SpawnComponent, so let’s take advantage of it:", "completion": "class Player extends SpriteAnimationComponent\n    with HasGameReference<SpaceShooterGame> {\n  late final SpawnComponent _bulletSpawner;\n\n  @override\n  Future<void> onLoad() async {\n    // Loading animation omitted\n\n    _bulletSpawner = SpawnComponent(\n      period: .2,\n      selfPositioning: true,\n      factory: (index) {\n        return Bullet(\n          position: position +\n              Vector2(\n,\n                -height / 2,\n              ),\n        );\n\n        return bullet;\n      },\n      autoStart: false,\n    );\n\n    game.add(_bulletSpawner);\n  }\n\n  void move(Vector2 delta) {\n    position.add(delta);\n  }\n\n  void startShooting() {\n    _bulletSpawner.timer.start();\n  }\n\n  void stopShooting() {\n    _bulletSpawner.timer.stop();\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Adding bullets¶: And that closes this step, putting us real close to a real game!", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/input.dart';\nimport 'package:flame/parallax.dart';\nimport 'package:flutter/material.dart';\n\nvoid main() {\nrunApp(GameWidget(game: SpaceShooterGame()));\n}\n\nclass SpaceShooterGame extends FlameGame with PanDetector {\nlate Player player;\n\n@override\nFuture<void> onLoad() async {\nfinal parallax = await loadParallaxComponent(\n[\nParallaxImageData('stars_0.png'),\nParallaxImageData('stars_1.png'),\nParallaxImageData('stars_2.png'),\n],\nbaseVelocity: Vector2(0, -5),\nrepeat: ImageRepeat.repeat,\nvelocityMultiplierDelta: Vector2(0, 5),\n);\nadd(parallax);\n\nplayer = Player();\nadd(player);\n}\n\n@override\nvoid onPanUpdate(DragUpdateInfo info) {\nplayer.move(info.delta.global);\n}\n\n@override\nvoid onPanStart(DragStartInfo info) {\nplayer.startShooting();\n}\n\n@override\nvoid onPanEnd(DragEndInfo info) {\nplayer.stopShooting();\n}\n}\n\nclass Player extends SpriteAnimationComponent\nwith HasGameReference<SpaceShooterGame> {\nPlayer()\n: super(\nsize: Vector2(100, 150),\nanchor: Anchor.center,\n);\n\nlate final SpawnComponent _bulletSpawner;\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nanimation = await game.loadSpriteAnimation(\n'player.png',\nSpriteAnimationData.sequenced(\namount: 4,\nstepTime: 0.2,\ntextureSize: Vector2(32, 48),\n),\n);\n\nposition = game.size / 2;\n\n_bulletSpawner = SpawnComponent(\nperiod: 0.2,\nselfPositioning: true,\nfactory: (index) {\nreturn Bullet(\nposition: position +\nVector2(\n0,\n-height / 2,\n),\n);\n},\nautoStart: false,\n);\n\ngame.add(_bulletSpawner);\n}\n\nvoid move(Vector2 delta) {\nposition.add(delta);\n}\n\nvoid startShooting() {\n_bulletSpawner.timer.start();\n}\n\nvoid stopShooting() {\n_bulletSpawner.timer.stop();\n}\n}\n\nclass Bullet extends SpriteAnimationComponent\nwith HasGameReference<SpaceShooterGame> {\nBullet({\nsuper.position,\n}) : super(\nsize: Vector2(25, 50),\nanchor: Anchor.center,\n);\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nanimation = await game.loadSpriteAnimation(\n'bullet.png',\nSpriteAnimationData.sequenced(\namount: 4,\nstepTime: 0.2,\ntextureSize: Vector2(8, 16),\n),\n);\n}\n\n@override\nvoid update(double dt) {\nsuper.update(dt);\n\nposition.y += dt * -500;\n\nif (position.y < -height) {\nremoveFromParent();\n}\n}\n}"}
{"prompt": "Show me how to implement Adding bullets¶: And that closes this step, putting us real close to a real game! using Flutter Flame", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/input.dart';\nimport 'package:flame/parallax.dart';\nimport 'package:flutter/material.dart';\n\nvoid main() {\nrunApp(GameWidget(game: SpaceShooterGame()));\n}\n\nclass SpaceShooterGame extends FlameGame with PanDetector {\nlate Player player;\n\n@override\nFuture<void> onLoad() async {\nfinal parallax = await loadParallaxComponent(\n[\nParallaxImageData('stars_0.png'),\nParallaxImageData('stars_1.png'),\nParallaxImageData('stars_2.png'),\n],\nbaseVelocity: Vector2(0, -5),\nrepeat: ImageRepeat.repeat,\nvelocityMultiplierDelta: Vector2(0, 5),\n);\nadd(parallax);\n\nplayer = Player();\nadd(player);\n}\n\n@override\nvoid onPanUpdate(DragUpdateInfo info) {\nplayer.move(info.delta.global);\n}\n\n@override\nvoid onPanStart(DragStartInfo info) {\nplayer.startShooting();\n}\n\n@override\nvoid onPanEnd(DragEndInfo info) {\nplayer.stopShooting();\n}\n}\n\nclass Player extends SpriteAnimationComponent\nwith HasGameReference<SpaceShooterGame> {\nPlayer()\n: super(\nsize: Vector2(100, 150),\nanchor: Anchor.center,\n);\n\nlate final SpawnComponent _bulletSpawner;\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nanimation = await game.loadSpriteAnimation(\n'player.png',\nSpriteAnimationData.sequenced(\namount: 4,\nstepTime: 0.2,\ntextureSize: Vector2(32, 48),\n),\n);\n\nposition = game.size / 2;\n\n_bulletSpawner = SpawnComponent(\nperiod: 0.2,\nselfPositioning: true,\nfactory: (index) {\nreturn Bullet(\nposition: position +\nVector2(\n0,\n-height / 2,\n),\n);\n},\nautoStart: false,\n);\n\ngame.add(_bulletSpawner);\n}\n\nvoid move(Vector2 delta) {\nposition.add(delta);\n}\n\nvoid startShooting() {\n_bulletSpawner.timer.start();\n}\n\nvoid stopShooting() {\n_bulletSpawner.timer.stop();\n}\n}\n\nclass Bullet extends SpriteAnimationComponent\nwith HasGameReference<SpaceShooterGame> {\nBullet({\nsuper.position,\n}) : super(\nsize: Vector2(25, 50),\nanchor: Anchor.center,\n);\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nanimation = await game.loadSpriteAnimation(\n'bullet.png',\nSpriteAnimationData.sequenced(\namount: 4,\nstepTime: 0.2,\ntextureSize: Vector2(8, 16),\n),\n);\n}\n\n@override\nvoid update(double dt) {\nsuper.update(dt);\n\nposition.y += dt * -500;\n\nif (position.y < -height) {\nremoveFromParent();\n}\n}\n}"}
{"prompt": "Write Flutter Flame code to Adding bullets¶: And that closes this step, putting us real close to a real game!", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/input.dart';\nimport 'package:flame/parallax.dart';\nimport 'package:flutter/material.dart';\n\nvoid main() {\nrunApp(GameWidget(game: SpaceShooterGame()));\n}\n\nclass SpaceShooterGame extends FlameGame with PanDetector {\nlate Player player;\n\n@override\nFuture<void> onLoad() async {\nfinal parallax = await loadParallaxComponent(\n[\nParallaxImageData('stars_0.png'),\nParallaxImageData('stars_1.png'),\nParallaxImageData('stars_2.png'),\n],\nbaseVelocity: Vector2(0, -5),\nrepeat: ImageRepeat.repeat,\nvelocityMultiplierDelta: Vector2(0, 5),\n);\nadd(parallax);\n\nplayer = Player();\nadd(player);\n}\n\n@override\nvoid onPanUpdate(DragUpdateInfo info) {\nplayer.move(info.delta.global);\n}\n\n@override\nvoid onPanStart(DragStartInfo info) {\nplayer.startShooting();\n}\n\n@override\nvoid onPanEnd(DragEndInfo info) {\nplayer.stopShooting();\n}\n}\n\nclass Player extends SpriteAnimationComponent\nwith HasGameReference<SpaceShooterGame> {\nPlayer()\n: super(\nsize: Vector2(100, 150),\nanchor: Anchor.center,\n);\n\nlate final SpawnComponent _bulletSpawner;\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nanimation = await game.loadSpriteAnimation(\n'player.png',\nSpriteAnimationData.sequenced(\namount: 4,\nstepTime: 0.2,\ntextureSize: Vector2(32, 48),\n),\n);\n\nposition = game.size / 2;\n\n_bulletSpawner = SpawnComponent(\nperiod: 0.2,\nselfPositioning: true,\nfactory: (index) {\nreturn Bullet(\nposition: position +\nVector2(\n0,\n-height / 2,\n),\n);\n},\nautoStart: false,\n);\n\ngame.add(_bulletSpawner);\n}\n\nvoid move(Vector2 delta) {\nposition.add(delta);\n}\n\nvoid startShooting() {\n_bulletSpawner.timer.start();\n}\n\nvoid stopShooting() {\n_bulletSpawner.timer.stop();\n}\n}\n\nclass Bullet extends SpriteAnimationComponent\nwith HasGameReference<SpaceShooterGame> {\nBullet({\nsuper.position,\n}) : super(\nsize: Vector2(25, 50),\nanchor: Anchor.center,\n);\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nanimation = await game.loadSpriteAnimation(\n'bullet.png',\nSpriteAnimationData.sequenced(\namount: 4,\nstepTime: 0.2,\ntextureSize: Vector2(8, 16),\n),\n);\n}\n\n@override\nvoid update(double dt) {\nsuper.update(dt);\n\nposition.y += dt * -500;\n\nif (position.y < -height) {\nremoveFromParent();\n}\n}\n}"}
{"prompt": "Create a Flutter Flame game component that 1. Preparation¶: Having this name in mind, please head over to the tutorial and complete the necessary set up steps. When you come back, you should already have the main.dart file with the following content:", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/widgets.dart';\n\nvoid main() {\n  final game = FlameGame();\n  runApp(GameWidget(game: game));\n}"}
{"prompt": "Show me how to implement 1. Preparation¶: Having this name in mind, please head over to the tutorial and complete the necessary set up steps. When you come back, you should already have the main.dart file with the following content: using Flutter Flame", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/widgets.dart';\n\nvoid main() {\n  final game = FlameGame();\n  runApp(GameWidget(game: game));\n}"}
{"prompt": "Write Flutter Flame code to 1. Preparation¶: Having this name in mind, please head over to the tutorial and complete the necessary set up steps. When you come back, you should already have the main.dart file with the following content:", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/widgets.dart';\n\nvoid main() {\n  final game = FlameGame();\n  runApp(GameWidget(game: game));\n}"}
{"prompt": "Create a Flutter Flame game component that How to use flame_svg¶: To use it just import the Svg class from 'package:flame_svg/flame_svg.dart', and use the following snippet to render it on the canvas:", "completion": "final svgInstance = await Svg.load('android.svg');\n\nfinal position = Vector2(100, 100);\nfinal size = Vector2(300, 300);\n\nsvgInstance.renderPosition(canvas, position, size);"}
{"prompt": "Show me how to implement How to use flame_svg¶: To use it just import the Svg class from 'package:flame_svg/flame_svg.dart', and use the following snippet to render it on the canvas: using Flutter Flame", "completion": "final svgInstance = await Svg.load('android.svg');\n\nfinal position = Vector2(100, 100);\nfinal size = Vector2(300, 300);\n\nsvgInstance.renderPosition(canvas, position, size);"}
{"prompt": "Write Flutter Flame code to How to use flame_svg¶: To use it just import the Svg class from 'package:flame_svg/flame_svg.dart', and use the following snippet to render it on the canvas:", "completion": "final svgInstance = await Svg.load('android.svg');\n\nfinal position = Vector2(100, 100);\nfinal size = Vector2(300, 300);\n\nsvgInstance.renderPosition(canvas, position, size);"}
{"prompt": "Create a Flutter Flame game component that How to use flame_svg¶: or use the SvgComponent and add it to the component tree:", "completion": "class MyGame extends FlameGame {\n  @override\n  Future<void> onLoad() async {\n    final svgInstance = await Svg.load('android.svg');\n    final size = Vector2.all(100);\n    final position = Vector2.all(100);\n    final svgComponent = SvgComponent(\n      size: size,\n      position: position,\n      svg: svgInstance,\n    );\n\n    add(svgComponent);\n  }\n}"}
{"prompt": "Show me how to implement How to use flame_svg¶: or use the SvgComponent and add it to the component tree: using Flutter Flame", "completion": "class MyGame extends FlameGame {\n  @override\n  Future<void> onLoad() async {\n    final svgInstance = await Svg.load('android.svg');\n    final size = Vector2.all(100);\n    final position = Vector2.all(100);\n    final svgComponent = SvgComponent(\n      size: size,\n      position: position,\n      svg: svgInstance,\n    );\n\n    add(svgComponent);\n  }\n}"}
{"prompt": "Write Flutter Flame code to How to use flame_svg¶: or use the SvgComponent and add it to the component tree:", "completion": "class MyGame extends FlameGame {\n  @override\n  Future<void> onLoad() async {\n    final svgInstance = await Svg.load('android.svg');\n    final size = Vector2.all(100);\n    final position = Vector2.all(100);\n    final svgComponent = SvgComponent(\n      size: size,\n      position: position,\n      svg: svgInstance,\n    );\n\n    add(svgComponent);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Segment Manager¶: Now we can create a file called segment_manager.dart which will be placed in a new folder called lib/managers. The segment manager is the heart and soul, if you will, of Ember Quest. This is where you can get as creative as you want. You do not have to follow my design, just remember that whatever you design, the segment must follow the rules outlined above. Add the following code to segment_manager.dart:", "completion": "class Block {\n  // gridPosition position is always segment based X,Y.\n  // 0,0 is the bottom left corner.\n  // 10,10 is the upper right corner.\n  final Vector2 gridPosition;\n  final Type blockType;\n  Block(this.gridPosition, this.blockType);\n}\n\nfinal segments = [\n  segment0,\n];\n\nfinal segment0 = [\n\n];"}
{"prompt": "Show me how to implement Segment Manager¶: Now we can create a file called segment_manager.dart which will be placed in a new folder called lib/managers. The segment manager is the heart and soul, if you will, of Ember Quest. This is where you can get as creative as you want. You do not have to follow my design, just remember that whatever you design, the segment must follow the rules outlined above. Add the following code to segment_manager.dart: using Flutter Flame", "completion": "class Block {\n  // gridPosition position is always segment based X,Y.\n  // 0,0 is the bottom left corner.\n  // 10,10 is the upper right corner.\n  final Vector2 gridPosition;\n  final Type blockType;\n  Block(this.gridPosition, this.blockType);\n}\n\nfinal segments = [\n  segment0,\n];\n\nfinal segment0 = [\n\n];"}
{"prompt": "Write Flutter Flame code to Segment Manager¶: Now we can create a file called segment_manager.dart which will be placed in a new folder called lib/managers. The segment manager is the heart and soul, if you will, of Ember Quest. This is where you can get as creative as you want. You do not have to follow my design, just remember that whatever you design, the segment must follow the rules outlined above. Add the following code to segment_manager.dart:", "completion": "class Block {\n  // gridPosition position is always segment based X,Y.\n  // 0,0 is the bottom left corner.\n  // 10,10 is the upper right corner.\n  final Vector2 gridPosition;\n  final Type blockType;\n  Block(this.gridPosition, this.blockType);\n}\n\nfinal segments = [\n  segment0,\n];\n\nfinal segment0 = [\n\n];"}
{"prompt": "Create a Flutter Flame game component that Segment Manager¶: The full segment would look like this:", "completion": "final segment0 = [\n  Block(Vector2(0, 0), GroundBlock),\n  Block(Vector2(1, 0), GroundBlock),\n  Block(Vector2(2, 0), GroundBlock),\n  Block(Vector2(3, 0), GroundBlock),\n  Block(Vector2(4, 0), GroundBlock),\n  Block(Vector2(5, 0), GroundBlock),\n  Block(Vector2(5, 1), WaterEnemy),\n  Block(Vector2(5, 3), PlatformBlock),\n  Block(Vector2(6, 0), GroundBlock),\n  Block(Vector2(6, 3), PlatformBlock),\n  Block(Vector2(7, 0), GroundBlock),\n  Block(Vector2(7, 3), PlatformBlock),\n  Block(Vector2(8, 0), GroundBlock),\n  Block(Vector2(8, 3), PlatformBlock),\n  Block(Vector2(9, 0), GroundBlock),\n];"}
{"prompt": "Show me how to implement Segment Manager¶: The full segment would look like this: using Flutter Flame", "completion": "final segment0 = [\n  Block(Vector2(0, 0), GroundBlock),\n  Block(Vector2(1, 0), GroundBlock),\n  Block(Vector2(2, 0), GroundBlock),\n  Block(Vector2(3, 0), GroundBlock),\n  Block(Vector2(4, 0), GroundBlock),\n  Block(Vector2(5, 0), GroundBlock),\n  Block(Vector2(5, 1), WaterEnemy),\n  Block(Vector2(5, 3), PlatformBlock),\n  Block(Vector2(6, 0), GroundBlock),\n  Block(Vector2(6, 3), PlatformBlock),\n  Block(Vector2(7, 0), GroundBlock),\n  Block(Vector2(7, 3), PlatformBlock),\n  Block(Vector2(8, 0), GroundBlock),\n  Block(Vector2(8, 3), PlatformBlock),\n  Block(Vector2(9, 0), GroundBlock),\n];"}
{"prompt": "Write Flutter Flame code to Segment Manager¶: The full segment would look like this:", "completion": "final segment0 = [\n  Block(Vector2(0, 0), GroundBlock),\n  Block(Vector2(1, 0), GroundBlock),\n  Block(Vector2(2, 0), GroundBlock),\n  Block(Vector2(3, 0), GroundBlock),\n  Block(Vector2(4, 0), GroundBlock),\n  Block(Vector2(5, 0), GroundBlock),\n  Block(Vector2(5, 1), WaterEnemy),\n  Block(Vector2(5, 3), PlatformBlock),\n  Block(Vector2(6, 0), GroundBlock),\n  Block(Vector2(6, 3), PlatformBlock),\n  Block(Vector2(7, 0), GroundBlock),\n  Block(Vector2(7, 3), PlatformBlock),\n  Block(Vector2(8, 0), GroundBlock),\n  Block(Vector2(8, 3), PlatformBlock),\n  Block(Vector2(9, 0), GroundBlock),\n];"}
{"prompt": "Create a Flutter Flame game component that Segment Manager¶: Proceed to build the remaining segments. The full segment manager should look like this:", "completion": "import 'package:flame/components.dart';\n\nimport '../actors/water_enemy.dart';\nimport '../objects/ground_block.dart';\nimport '../objects/platform_block.dart';\nimport '../objects/star.dart';\n\nclass Block {\n  // gridPosition position is always segment based X,Y.\n  // 0,0 is the bottom left corner.\n  // 10,10 is the upper right corner.\n  final Vector2 gridPosition;\n  final Type blockType;\n  Block(this.gridPosition, this.blockType);\n}\n\nfinal segments = [\n  segment0,\n  segment1,\n  segment2,\n  segment3,\n  segment4,\n];\n\nfinal segment0 = [\n  Block(Vector2(0, 0), GroundBlock),\n  Block(Vector2(1, 0), GroundBlock),\n  Block(Vector2(2, 0), GroundBlock),\n  Block(Vector2(3, 0), GroundBlock),\n  Block(Vector2(4, 0), GroundBlock),\n  Block(Vector2(5, 0), GroundBlock),\n  Block(Vector2(5, 1), WaterEnemy),\n  Block(Vector2(5, 3), PlatformBlock),\n  Block(Vector2(6, 0), GroundBlock),\n  Block(Vector2(6, 3), PlatformBlock),\n  Block(Vector2(7, 0), GroundBlock),\n  Block(Vector2(7, 3), PlatformBlock),\n  Block(Vector2(8, 0), GroundBlock),\n  Block(Vector2(8, 3), PlatformBlock),\n  Block(Vector2(9, 0), GroundBlock),\n];\n\nfinal segment1 = [\n  Block(Vector2(0, 0), GroundBlock),\n  Block(Vector2(1, 0), GroundBlock),\n  Block(Vector2(1, 1), PlatformBlock),\n  Block(Vector2(1, 2), PlatformBlock),\n  Block(Vector2(1, 3), PlatformBlock),\n  Block(Vector2(2, 6), PlatformBlock),\n  Block(Vector2(3, 6), PlatformBlock),\n  Block(Vector2(6, 5), PlatformBlock),\n  Block(Vector2(7, 5), PlatformBlock),\n  Block(Vector2(7, 7), Star),\n  Block(Vector2(8, 0), GroundBlock),\n  Block(Vector2(8, 1), PlatformBlock),\n  Block(Vector2(8, 5), PlatformBlock),\n  Block(Vector2(8, 6), WaterEnemy),\n  Block(Vector2(9, 0), GroundBlock),\n];\n\nfinal segment2 = [\n  Block(Vector2(0, 0), GroundBlock),\n  Block(Vector2(1, 0), GroundBlock),\n  Block(Vector2(2, 0), GroundBlock),\n  Block(Vector2(3, 0), GroundBlock),\n  Block(Vector2(3, 3), PlatformBlock),\n  Block(Vector2(4, 0), GroundBlock),\n  Block(Vector2(4, 3), PlatformBlock),\n  Block(Vector2(5, 0), GroundBlock),\n  Block(Vector2(5, 3), PlatformBlock),\n  Block(Vector2(5, 4), WaterEnemy),\n  Block(Vector2(6, 0), GroundBlock),\n  Block(Vector2(6, 3), PlatformBlock),\n  Block(Vector2(6, 4), PlatformBlock),\n  Block(Vector2(6, 5), PlatformBlock),\n  Block(Vector2(6, 7), Star),\n  Block(Vector2(7, 0), GroundBlock),\n  Block(Vector2(8, 0), GroundBlock),\n  Block(Vector2(9, 0), GroundBlock),\n];\n\nfinal segment3 = [\n  Block(Vector2(0, 0), GroundBlock),\n  Block(Vector2(1, 0), GroundBlock),\n  Block(Vector2(1, 1), WaterEnemy),\n  Block(Vector2(2, 0), GroundBlock),\n  Block(Vector2(2, 1), PlatformBlock),\n  Block(Vector2(2, 2), PlatformBlock),\n  Block(Vector2(4, 4), PlatformBlock),\n  Block(Vector2(6, 6), PlatformBlock),\n  Block(Vector2(7, 0), GroundBlock),\n  Block(Vector2(7, 1), PlatformBlock),\n  Block(Vector2(8, 0), GroundBlock),\n  Block(Vector2(8, 8), Star),\n  Block(Vector2(9, 0), GroundBlock),\n];\n\nfinal segment4 = [\n  Block(Vector2(0, 0), GroundBlock),\n  Block(Vector2(1, 0), GroundBlock),\n  Block(Vector2(2, 0), GroundBlock),\n  Block(Vector2(2, 3), PlatformBlock),\n  Block(Vector2(3, 0), GroundBlock),\n  Block(Vector2(3, 1), WaterEnemy),\n  Block(Vector2(3, 3), PlatformBlock),\n  Block(Vector2(4, 0), GroundBlock),\n  Block(Vector2(5, 0), GroundBlock),\n  Block(Vector2(5, 5), PlatformBlock),\n  Block(Vector2(6, 0), GroundBlock),\n  Block(Vector2(6, 5), PlatformBlock),\n  Block(Vector2(6, 7), Star),\n  Block(Vector2(7, 0), GroundBlock),\n  Block(Vector2(8, 0), GroundBlock),\n  Block(Vector2(8, 3), PlatformBlock),\n  Block(Vector2(9, 0), GroundBlock),\n  Block(Vector2(9, 1), WaterEnemy),\n  Block(Vector2(9, 3), PlatformBlock),\n];"}
{"prompt": "Show me how to implement Segment Manager¶: Proceed to build the remaining segments. The full segment manager should look like this: using Flutter Flame", "completion": "import 'package:flame/components.dart';\n\nimport '../actors/water_enemy.dart';\nimport '../objects/ground_block.dart';\nimport '../objects/platform_block.dart';\nimport '../objects/star.dart';\n\nclass Block {\n  // gridPosition position is always segment based X,Y.\n  // 0,0 is the bottom left corner.\n  // 10,10 is the upper right corner.\n  final Vector2 gridPosition;\n  final Type blockType;\n  Block(this.gridPosition, this.blockType);\n}\n\nfinal segments = [\n  segment0,\n  segment1,\n  segment2,\n  segment3,\n  segment4,\n];\n\nfinal segment0 = [\n  Block(Vector2(0, 0), GroundBlock),\n  Block(Vector2(1, 0), GroundBlock),\n  Block(Vector2(2, 0), GroundBlock),\n  Block(Vector2(3, 0), GroundBlock),\n  Block(Vector2(4, 0), GroundBlock),\n  Block(Vector2(5, 0), GroundBlock),\n  Block(Vector2(5, 1), WaterEnemy),\n  Block(Vector2(5, 3), PlatformBlock),\n  Block(Vector2(6, 0), GroundBlock),\n  Block(Vector2(6, 3), PlatformBlock),\n  Block(Vector2(7, 0), GroundBlock),\n  Block(Vector2(7, 3), PlatformBlock),\n  Block(Vector2(8, 0), GroundBlock),\n  Block(Vector2(8, 3), PlatformBlock),\n  Block(Vector2(9, 0), GroundBlock),\n];\n\nfinal segment1 = [\n  Block(Vector2(0, 0), GroundBlock),\n  Block(Vector2(1, 0), GroundBlock),\n  Block(Vector2(1, 1), PlatformBlock),\n  Block(Vector2(1, 2), PlatformBlock),\n  Block(Vector2(1, 3), PlatformBlock),\n  Block(Vector2(2, 6), PlatformBlock),\n  Block(Vector2(3, 6), PlatformBlock),\n  Block(Vector2(6, 5), PlatformBlock),\n  Block(Vector2(7, 5), PlatformBlock),\n  Block(Vector2(7, 7), Star),\n  Block(Vector2(8, 0), GroundBlock),\n  Block(Vector2(8, 1), PlatformBlock),\n  Block(Vector2(8, 5), PlatformBlock),\n  Block(Vector2(8, 6), WaterEnemy),\n  Block(Vector2(9, 0), GroundBlock),\n];\n\nfinal segment2 = [\n  Block(Vector2(0, 0), GroundBlock),\n  Block(Vector2(1, 0), GroundBlock),\n  Block(Vector2(2, 0), GroundBlock),\n  Block(Vector2(3, 0), GroundBlock),\n  Block(Vector2(3, 3), PlatformBlock),\n  Block(Vector2(4, 0), GroundBlock),\n  Block(Vector2(4, 3), PlatformBlock),\n  Block(Vector2(5, 0), GroundBlock),\n  Block(Vector2(5, 3), PlatformBlock),\n  Block(Vector2(5, 4), WaterEnemy),\n  Block(Vector2(6, 0), GroundBlock),\n  Block(Vector2(6, 3), PlatformBlock),\n  Block(Vector2(6, 4), PlatformBlock),\n  Block(Vector2(6, 5), PlatformBlock),\n  Block(Vector2(6, 7), Star),\n  Block(Vector2(7, 0), GroundBlock),\n  Block(Vector2(8, 0), GroundBlock),\n  Block(Vector2(9, 0), GroundBlock),\n];\n\nfinal segment3 = [\n  Block(Vector2(0, 0), GroundBlock),\n  Block(Vector2(1, 0), GroundBlock),\n  Block(Vector2(1, 1), WaterEnemy),\n  Block(Vector2(2, 0), GroundBlock),\n  Block(Vector2(2, 1), PlatformBlock),\n  Block(Vector2(2, 2), PlatformBlock),\n  Block(Vector2(4, 4), PlatformBlock),\n  Block(Vector2(6, 6), PlatformBlock),\n  Block(Vector2(7, 0), GroundBlock),\n  Block(Vector2(7, 1), PlatformBlock),\n  Block(Vector2(8, 0), GroundBlock),\n  Block(Vector2(8, 8), Star),\n  Block(Vector2(9, 0), GroundBlock),\n];\n\nfinal segment4 = [\n  Block(Vector2(0, 0), GroundBlock),\n  Block(Vector2(1, 0), GroundBlock),\n  Block(Vector2(2, 0), GroundBlock),\n  Block(Vector2(2, 3), PlatformBlock),\n  Block(Vector2(3, 0), GroundBlock),\n  Block(Vector2(3, 1), WaterEnemy),\n  Block(Vector2(3, 3), PlatformBlock),\n  Block(Vector2(4, 0), GroundBlock),\n  Block(Vector2(5, 0), GroundBlock),\n  Block(Vector2(5, 5), PlatformBlock),\n  Block(Vector2(6, 0), GroundBlock),\n  Block(Vector2(6, 5), PlatformBlock),\n  Block(Vector2(6, 7), Star),\n  Block(Vector2(7, 0), GroundBlock),\n  Block(Vector2(8, 0), GroundBlock),\n  Block(Vector2(8, 3), PlatformBlock),\n  Block(Vector2(9, 0), GroundBlock),\n  Block(Vector2(9, 1), WaterEnemy),\n  Block(Vector2(9, 3), PlatformBlock),\n];"}
{"prompt": "Write Flutter Flame code to Segment Manager¶: Proceed to build the remaining segments. The full segment manager should look like this:", "completion": "import 'package:flame/components.dart';\n\nimport '../actors/water_enemy.dart';\nimport '../objects/ground_block.dart';\nimport '../objects/platform_block.dart';\nimport '../objects/star.dart';\n\nclass Block {\n  // gridPosition position is always segment based X,Y.\n  // 0,0 is the bottom left corner.\n  // 10,10 is the upper right corner.\n  final Vector2 gridPosition;\n  final Type blockType;\n  Block(this.gridPosition, this.blockType);\n}\n\nfinal segments = [\n  segment0,\n  segment1,\n  segment2,\n  segment3,\n  segment4,\n];\n\nfinal segment0 = [\n  Block(Vector2(0, 0), GroundBlock),\n  Block(Vector2(1, 0), GroundBlock),\n  Block(Vector2(2, 0), GroundBlock),\n  Block(Vector2(3, 0), GroundBlock),\n  Block(Vector2(4, 0), GroundBlock),\n  Block(Vector2(5, 0), GroundBlock),\n  Block(Vector2(5, 1), WaterEnemy),\n  Block(Vector2(5, 3), PlatformBlock),\n  Block(Vector2(6, 0), GroundBlock),\n  Block(Vector2(6, 3), PlatformBlock),\n  Block(Vector2(7, 0), GroundBlock),\n  Block(Vector2(7, 3), PlatformBlock),\n  Block(Vector2(8, 0), GroundBlock),\n  Block(Vector2(8, 3), PlatformBlock),\n  Block(Vector2(9, 0), GroundBlock),\n];\n\nfinal segment1 = [\n  Block(Vector2(0, 0), GroundBlock),\n  Block(Vector2(1, 0), GroundBlock),\n  Block(Vector2(1, 1), PlatformBlock),\n  Block(Vector2(1, 2), PlatformBlock),\n  Block(Vector2(1, 3), PlatformBlock),\n  Block(Vector2(2, 6), PlatformBlock),\n  Block(Vector2(3, 6), PlatformBlock),\n  Block(Vector2(6, 5), PlatformBlock),\n  Block(Vector2(7, 5), PlatformBlock),\n  Block(Vector2(7, 7), Star),\n  Block(Vector2(8, 0), GroundBlock),\n  Block(Vector2(8, 1), PlatformBlock),\n  Block(Vector2(8, 5), PlatformBlock),\n  Block(Vector2(8, 6), WaterEnemy),\n  Block(Vector2(9, 0), GroundBlock),\n];\n\nfinal segment2 = [\n  Block(Vector2(0, 0), GroundBlock),\n  Block(Vector2(1, 0), GroundBlock),\n  Block(Vector2(2, 0), GroundBlock),\n  Block(Vector2(3, 0), GroundBlock),\n  Block(Vector2(3, 3), PlatformBlock),\n  Block(Vector2(4, 0), GroundBlock),\n  Block(Vector2(4, 3), PlatformBlock),\n  Block(Vector2(5, 0), GroundBlock),\n  Block(Vector2(5, 3), PlatformBlock),\n  Block(Vector2(5, 4), WaterEnemy),\n  Block(Vector2(6, 0), GroundBlock),\n  Block(Vector2(6, 3), PlatformBlock),\n  Block(Vector2(6, 4), PlatformBlock),\n  Block(Vector2(6, 5), PlatformBlock),\n  Block(Vector2(6, 7), Star),\n  Block(Vector2(7, 0), GroundBlock),\n  Block(Vector2(8, 0), GroundBlock),\n  Block(Vector2(9, 0), GroundBlock),\n];\n\nfinal segment3 = [\n  Block(Vector2(0, 0), GroundBlock),\n  Block(Vector2(1, 0), GroundBlock),\n  Block(Vector2(1, 1), WaterEnemy),\n  Block(Vector2(2, 0), GroundBlock),\n  Block(Vector2(2, 1), PlatformBlock),\n  Block(Vector2(2, 2), PlatformBlock),\n  Block(Vector2(4, 4), PlatformBlock),\n  Block(Vector2(6, 6), PlatformBlock),\n  Block(Vector2(7, 0), GroundBlock),\n  Block(Vector2(7, 1), PlatformBlock),\n  Block(Vector2(8, 0), GroundBlock),\n  Block(Vector2(8, 8), Star),\n  Block(Vector2(9, 0), GroundBlock),\n];\n\nfinal segment4 = [\n  Block(Vector2(0, 0), GroundBlock),\n  Block(Vector2(1, 0), GroundBlock),\n  Block(Vector2(2, 0), GroundBlock),\n  Block(Vector2(2, 3), PlatformBlock),\n  Block(Vector2(3, 0), GroundBlock),\n  Block(Vector2(3, 1), WaterEnemy),\n  Block(Vector2(3, 3), PlatformBlock),\n  Block(Vector2(4, 0), GroundBlock),\n  Block(Vector2(5, 0), GroundBlock),\n  Block(Vector2(5, 5), PlatformBlock),\n  Block(Vector2(6, 0), GroundBlock),\n  Block(Vector2(6, 5), PlatformBlock),\n  Block(Vector2(6, 7), Star),\n  Block(Vector2(7, 0), GroundBlock),\n  Block(Vector2(8, 0), GroundBlock),\n  Block(Vector2(8, 3), PlatformBlock),\n  Block(Vector2(9, 0), GroundBlock),\n  Block(Vector2(9, 1), WaterEnemy),\n  Block(Vector2(9, 3), PlatformBlock),\n];"}
{"prompt": "Create a Flutter Flame game component that Loading the Segments into the World¶: Now that our segments are defined, we need to create a way to load these blocks into our world. To do that, we are going to start work in the ember_quest.dart file. We will create a loadSegments method that when given an index for the segments list, will then loop through that segment from our segment_manager and we will add the appropriate blocks later. It should look like this:", "completion": "void loadGameSegments(int segmentIndex, double xPositionOffset) {\n    for (final block in segments[segmentIndex]) {\n      switch (block.blockType) {\n        case GroundBlock:\n        case PlatformBlock:\n        case Star:\n        case WaterEnemy:\n      }\n    }\n  }"}
{"prompt": "Show me how to implement Loading the Segments into the World¶: Now that our segments are defined, we need to create a way to load these blocks into our world. To do that, we are going to start work in the ember_quest.dart file. We will create a loadSegments method that when given an index for the segments list, will then loop through that segment from our segment_manager and we will add the appropriate blocks later. It should look like this: using Flutter Flame", "completion": "void loadGameSegments(int segmentIndex, double xPositionOffset) {\n    for (final block in segments[segmentIndex]) {\n      switch (block.blockType) {\n        case GroundBlock:\n        case PlatformBlock:\n        case Star:\n        case WaterEnemy:\n      }\n    }\n  }"}
{"prompt": "Write Flutter Flame code to Loading the Segments into the World¶: Now that our segments are defined, we need to create a way to load these blocks into our world. To do that, we are going to start work in the ember_quest.dart file. We will create a loadSegments method that when given an index for the segments list, will then loop through that segment from our segment_manager and we will add the appropriate blocks later. It should look like this:", "completion": "void loadGameSegments(int segmentIndex, double xPositionOffset) {\n    for (final block in segments[segmentIndex]) {\n      switch (block.blockType) {\n        case GroundBlock:\n        case PlatformBlock:\n        case Star:\n        case WaterEnemy:\n      }\n    }\n  }"}
{"prompt": "Create a Flutter Flame game component that Loading the Segments into the World¶: You will need to add the following imports if they were not auto-imported:", "completion": "import 'actors/water_enemy.dart';\nimport 'managers/segment_manager.dart';\nimport 'objects/ground_block.dart';\nimport 'objects/platform_block.dart';\nimport 'objects/star.dart';"}
{"prompt": "Show me how to implement Loading the Segments into the World¶: You will need to add the following imports if they were not auto-imported: using Flutter Flame", "completion": "import 'actors/water_enemy.dart';\nimport 'managers/segment_manager.dart';\nimport 'objects/ground_block.dart';\nimport 'objects/platform_block.dart';\nimport 'objects/star.dart';"}
{"prompt": "Write Flutter Flame code to Loading the Segments into the World¶: You will need to add the following imports if they were not auto-imported:", "completion": "import 'actors/water_enemy.dart';\nimport 'managers/segment_manager.dart';\nimport 'objects/ground_block.dart';\nimport 'objects/platform_block.dart';\nimport 'objects/star.dart';"}
{"prompt": "Create a Flutter Flame game component that Loading the Segments into the World¶: Now we can refactor our game a bit and create an initializeGame() method which will call our loadGameSegments method.", "completion": "void initializeGame() {\n    // Assume that size.x < 3200\n    final segmentsToLoad = (size.x / 640).ceil();\n    segmentsToLoad.clamp(0, segments.length);\n\n    for (var i = 0; i <= segmentsToLoad; i++) {\n      loadGameSegments(i, (640 * i).toDouble());\n    }\n\n    _ember = EmberPlayer(\n      position: Vector2(128, canvasSize.y - 70),\n    );\n    world.add(_ember);\n  }"}
{"prompt": "Show me how to implement Loading the Segments into the World¶: Now we can refactor our game a bit and create an initializeGame() method which will call our loadGameSegments method. using Flutter Flame", "completion": "void initializeGame() {\n    // Assume that size.x < 3200\n    final segmentsToLoad = (size.x / 640).ceil();\n    segmentsToLoad.clamp(0, segments.length);\n\n    for (var i = 0; i <= segmentsToLoad; i++) {\n      loadGameSegments(i, (640 * i).toDouble());\n    }\n\n    _ember = EmberPlayer(\n      position: Vector2(128, canvasSize.y - 70),\n    );\n    world.add(_ember);\n  }"}
{"prompt": "Write Flutter Flame code to Loading the Segments into the World¶: Now we can refactor our game a bit and create an initializeGame() method which will call our loadGameSegments method.", "completion": "void initializeGame() {\n    // Assume that size.x < 3200\n    final segmentsToLoad = (size.x / 640).ceil();\n    segmentsToLoad.clamp(0, segments.length);\n\n    for (var i = 0; i <= segmentsToLoad; i++) {\n      loadGameSegments(i, (640 * i).toDouble());\n    }\n\n    _ember = EmberPlayer(\n      position: Vector2(128, canvasSize.y - 70),\n    );\n    world.add(_ember);\n  }"}
{"prompt": "Create a Flutter Flame game component that Loading the Segments into the World¶: Additionally, I have moved the Ember-related code from the onLoad method to our new initializeGame method. This means I can now make the call in onLoad to initializeGame such as:", "completion": "@override\n  Future<void> onLoad() async {\n    await images.loadAll([\n      'block.png',\n      'ember.png',\n      'ground.png',\n      'heart_half.png',\n      'heart.png',\n      'star.png',\n      'water_enemy.png',\n    ]);\n    \n    camera.viewfinder.anchor = Anchor.topLeft;\n    initializeGame();\n  }"}
{"prompt": "Show me how to implement Loading the Segments into the World¶: Additionally, I have moved the Ember-related code from the onLoad method to our new initializeGame method. This means I can now make the call in onLoad to initializeGame such as: using Flutter Flame", "completion": "@override\n  Future<void> onLoad() async {\n    await images.loadAll([\n      'block.png',\n      'ember.png',\n      'ground.png',\n      'heart_half.png',\n      'heart.png',\n      'star.png',\n      'water_enemy.png',\n    ]);\n    \n    camera.viewfinder.anchor = Anchor.topLeft;\n    initializeGame();\n  }"}
{"prompt": "Write Flutter Flame code to Loading the Segments into the World¶: Additionally, I have moved the Ember-related code from the onLoad method to our new initializeGame method. This means I can now make the call in onLoad to initializeGame such as:", "completion": "@override\n  Future<void> onLoad() async {\n    await images.loadAll([\n      'block.png',\n      'ember.png',\n      'ground.png',\n      'heart_half.png',\n      'heart.png',\n      'star.png',\n      'water_enemy.png',\n    ]);\n    \n    camera.viewfinder.anchor = Anchor.topLeft;\n    initializeGame();\n  }"}
{"prompt": "Create a Flutter Flame game component that The Platform Block¶: Open the lib/objects/platform_block.dart file and add the following code:", "completion": "import 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\n\nimport '../ember_quest.dart';\n\nclass PlatformBlock extends SpriteComponent\n    with HasGameReference<EmberQuestGame> {\n  final Vector2 gridPosition;\n  double xOffset;\n\n  PlatformBlock({\n    required this.gridPosition,\n    required this.xOffset,\n  }) : super(size: Vector2.all(64), anchor: Anchor.bottomLeft);\n\n  @override\n  void onLoad() {\n  }\n\n  @override\n  void update(double dt) {\n    super.update(dt);\n  }\n}"}
{"prompt": "Show me how to implement The Platform Block¶: Open the lib/objects/platform_block.dart file and add the following code: using Flutter Flame", "completion": "import 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\n\nimport '../ember_quest.dart';\n\nclass PlatformBlock extends SpriteComponent\n    with HasGameReference<EmberQuestGame> {\n  final Vector2 gridPosition;\n  double xOffset;\n\n  PlatformBlock({\n    required this.gridPosition,\n    required this.xOffset,\n  }) : super(size: Vector2.all(64), anchor: Anchor.bottomLeft);\n\n  @override\n  void onLoad() {\n  }\n\n  @override\n  void update(double dt) {\n    super.update(dt);\n  }\n}"}
{"prompt": "Write Flutter Flame code to The Platform Block¶: Open the lib/objects/platform_block.dart file and add the following code:", "completion": "import 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\n\nimport '../ember_quest.dart';\n\nclass PlatformBlock extends SpriteComponent\n    with HasGameReference<EmberQuestGame> {\n  final Vector2 gridPosition;\n  double xOffset;\n\n  PlatformBlock({\n    required this.gridPosition,\n    required this.xOffset,\n  }) : super(size: Vector2.all(64), anchor: Anchor.bottomLeft);\n\n  @override\n  void onLoad() {\n  }\n\n  @override\n  void update(double dt) {\n    super.update(dt);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that The Platform Block¶: Now we just need to finish the onLoad method. So make your onLoad method look like this:", "completion": "@override\n  void onLoad() {\n    final platformImage = game.images.fromCache('block.png');\n    sprite = Sprite(platformImage);\n    position = Vector2((gridPosition.x * size.x) + xOffset,\n        game.size.y - (gridPosition.y * size.y),\n    );\n    add(RectangleHitbox(collisionType: CollisionType.passive));\n  }"}
{"prompt": "Show me how to implement The Platform Block¶: Now we just need to finish the onLoad method. So make your onLoad method look like this: using Flutter Flame", "completion": "@override\n  void onLoad() {\n    final platformImage = game.images.fromCache('block.png');\n    sprite = Sprite(platformImage);\n    position = Vector2((gridPosition.x * size.x) + xOffset,\n        game.size.y - (gridPosition.y * size.y),\n    );\n    add(RectangleHitbox(collisionType: CollisionType.passive));\n  }"}
{"prompt": "Write Flutter Flame code to The Platform Block¶: Now we just need to finish the onLoad method. So make your onLoad method look like this:", "completion": "@override\n  void onLoad() {\n    final platformImage = game.images.fromCache('block.png');\n    sprite = Sprite(platformImage);\n    position = Vector2((gridPosition.x * size.x) + xOffset,\n        game.size.y - (gridPosition.y * size.y),\n    );\n    add(RectangleHitbox(collisionType: CollisionType.passive));\n  }"}
{"prompt": "Create a Flutter Flame game component that The Platform Block¶: While this does run, the black just makes it look like Ember is in a dungeon. Let’s change that background real quick so there is a nice blue sky. Just add the following code to lib/ember_quest.dart:", "completion": "import 'package:flutter/material.dart';\n\n@override\nColor backgroundColor() {\n  return const Color.fromARGB(255, 173, 223, 247);\n}"}
{"prompt": "Show me how to implement The Platform Block¶: While this does run, the black just makes it look like Ember is in a dungeon. Let’s change that background real quick so there is a nice blue sky. Just add the following code to lib/ember_quest.dart: using Flutter Flame", "completion": "import 'package:flutter/material.dart';\n\n@override\nColor backgroundColor() {\n  return const Color.fromARGB(255, 173, 223, 247);\n}"}
{"prompt": "Write Flutter Flame code to The Platform Block¶: While this does run, the black just makes it look like Ember is in a dungeon. Let’s change that background real quick so there is a nice blue sky. Just add the following code to lib/ember_quest.dart:", "completion": "import 'package:flutter/material.dart';\n\n@override\nColor backgroundColor() {\n  return const Color.fromARGB(255, 173, 223, 247);\n}"}
{"prompt": "Create a Flutter Flame game component that Tap Events¶: In addition, the component must implement the containsLocalPoint() method (already implemented in PositionComponent, so most of the time you don’t need to do anything here) – this method allows Flame to know whether the event occurred within the component or not.", "completion": "class MyComponent extends PositionComponent with TapCallbacks {\n  MyComponent() : super(size: Vector2(80, 60));\n\n  @override\n  void onTapUp(TapUpEvent event) {\n    // Do something in response to a tap event\n  }\n}"}
{"prompt": "Show me how to implement Tap Events¶: In addition, the component must implement the containsLocalPoint() method (already implemented in PositionComponent, so most of the time you don’t need to do anything here) – this method allows Flame to know whether the event occurred within the component or not. using Flutter Flame", "completion": "class MyComponent extends PositionComponent with TapCallbacks {\n  MyComponent() : super(size: Vector2(80, 60));\n\n  @override\n  void onTapUp(TapUpEvent event) {\n    // Do something in response to a tap event\n  }\n}"}
{"prompt": "Write Flutter Flame code to Tap Events¶: In addition, the component must implement the containsLocalPoint() method (already implemented in PositionComponent, so most of the time you don’t need to do anything here) – this method allows Flame to know whether the event occurred within the component or not.", "completion": "class MyComponent extends PositionComponent with TapCallbacks {\n  MyComponent() : super(size: Vector2(80, 60));\n\n  @override\n  void onTapUp(TapUpEvent event) {\n    // Do something in response to a tap event\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Demo¶: The blue-ish rectangle in the middle is the component that has the TapCallbacks mixin. Tapping this component would create circles at the points of touch. Specifically, onTapDown event starts making the circle. The thickness of the circle will be proportional to the duration of the tap: after onTapUp the circle’s stroke width will no longer grow. There will be a thin white stripe at the moment the onLongTapDown fires. Lastly, the circle will implode and disappear if you cause the onTapCancel event by moving the finger.", "completion": "import 'dart:math';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flutter/rendering.dart';\n\nclass TapEventsGame extends FlameGame {\n@override\nFuture<void> onLoad() async {\nadd(TapTarget());\n}\n}\n\n/// This component is the tappable blue-ish rectangle in the center of the game.\n/// It uses the [TapCallbacks] mixin to receive tap events.\nclass TapTarget extends PositionComponent with TapCallbacks {\nTapTarget() : super(anchor: Anchor.center);\n\nfinal _paint = Paint()..color = const Color(0x448BA8FF);\n\n/// We will store all current circles into this map, keyed by the `pointerId`\n/// of the event that created the circle.\nfinal Map<int, ExpandingCircle> _circles = {};\n\n@override\nvoid onGameResize(Vector2 size) {\nsuper.onGameResize(size);\nthis.size = size - Vector2(100, 75);\nif (this.size.x < 100 || this.size.y < 100) {\nthis.size = size * 0.9;\n}\nposition = size / 2;\n}\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRect(size.toRect(), _paint);\n}\n\n@override\nvoid onTapDown(TapDownEvent event) {\nfinal circle = ExpandingCircle(event.localPosition);\n_circles[event.pointerId] = circle;\nadd(circle);\n}\n\n@override\nvoid onLongTapDown(TapDownEvent event) {\n_circles[event.pointerId]!.accent();\n}\n\n@override\nvoid onTapUp(TapUpEvent event) {\n_circles.remove(event.pointerId)!.release();\n}\n\n@override\nvoid onTapCancel(TapCancelEvent event) {\n_circles.remove(event.pointerId)!.cancel();\n}\n}\n\nclass ExpandingCircle extends Component {\nExpandingCircle(this._center)\n: _baseColor =\nHSLColor.fromAHSL(1, random.nextDouble() * 360, 1, 0.8).toColor();\n\nfinal Color _baseColor;\nfinal Vector2 _center;\ndouble _outerRadius = 0;\ndouble _innerRadius = 0;\nbool _released = false;\nbool _cancelled = false;\nlate final _paint = Paint()\n..style = PaintingStyle.stroke\n..color = _baseColor;\n\n/// \"Accent\" is thin white circle generated by `onLongTapDown`. We use\n/// negative radius to indicate that the circle should not be drawn yet.\ndouble _accentRadius = -1e10;\nlate final _accentPaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 0\n..color = const Color(0xFFFFFFFF);\n\n/// At this radius the circle will disappear.\nstatic const maxRadius = 175;\nstatic final random = Random();\n\ndouble get radius => (_innerRadius + _outerRadius) / 2;\n\nvoid release() => _released = true;\nvoid cancel() => _cancelled = true;\nvoid accent() => _accentRadius = 0;\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawCircle(_center.toOffset(), radius, _paint);\nif (_accentRadius >= 0) {\ncanvas.drawCircle(_center.toOffset(), _accentRadius, _accentPaint);\n}\n}\n\n@override\nvoid update(double dt) {\nif (_cancelled) {\n_innerRadius += dt * 100; // implosion\n} else {\n_outerRadius += dt * 20;\n_innerRadius += dt * (_released ? 20 : 6);\n_accentRadius += dt * 20;\n}\nif (radius >= maxRadius || _innerRadius > _outerRadius) {\nremoveFromParent();\n} else {\nfinal opacity = 1 - radius / maxRadius;\n_paint.color = _baseColor.withValues(alpha: opacity);\n_paint.strokeWidth = _outerRadius - _innerRadius;\n}\n}\n}"}
{"prompt": "Show me how to implement Demo¶: The blue-ish rectangle in the middle is the component that has the TapCallbacks mixin. Tapping this component would create circles at the points of touch. Specifically, onTapDown event starts making the circle. The thickness of the circle will be proportional to the duration of the tap: after onTapUp the circle’s stroke width will no longer grow. There will be a thin white stripe at the moment the onLongTapDown fires. Lastly, the circle will implode and disappear if you cause the onTapCancel event by moving the finger. using Flutter Flame", "completion": "import 'dart:math';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flutter/rendering.dart';\n\nclass TapEventsGame extends FlameGame {\n@override\nFuture<void> onLoad() async {\nadd(TapTarget());\n}\n}\n\n/// This component is the tappable blue-ish rectangle in the center of the game.\n/// It uses the [TapCallbacks] mixin to receive tap events.\nclass TapTarget extends PositionComponent with TapCallbacks {\nTapTarget() : super(anchor: Anchor.center);\n\nfinal _paint = Paint()..color = const Color(0x448BA8FF);\n\n/// We will store all current circles into this map, keyed by the `pointerId`\n/// of the event that created the circle.\nfinal Map<int, ExpandingCircle> _circles = {};\n\n@override\nvoid onGameResize(Vector2 size) {\nsuper.onGameResize(size);\nthis.size = size - Vector2(100, 75);\nif (this.size.x < 100 || this.size.y < 100) {\nthis.size = size * 0.9;\n}\nposition = size / 2;\n}\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRect(size.toRect(), _paint);\n}\n\n@override\nvoid onTapDown(TapDownEvent event) {\nfinal circle = ExpandingCircle(event.localPosition);\n_circles[event.pointerId] = circle;\nadd(circle);\n}\n\n@override\nvoid onLongTapDown(TapDownEvent event) {\n_circles[event.pointerId]!.accent();\n}\n\n@override\nvoid onTapUp(TapUpEvent event) {\n_circles.remove(event.pointerId)!.release();\n}\n\n@override\nvoid onTapCancel(TapCancelEvent event) {\n_circles.remove(event.pointerId)!.cancel();\n}\n}\n\nclass ExpandingCircle extends Component {\nExpandingCircle(this._center)\n: _baseColor =\nHSLColor.fromAHSL(1, random.nextDouble() * 360, 1, 0.8).toColor();\n\nfinal Color _baseColor;\nfinal Vector2 _center;\ndouble _outerRadius = 0;\ndouble _innerRadius = 0;\nbool _released = false;\nbool _cancelled = false;\nlate final _paint = Paint()\n..style = PaintingStyle.stroke\n..color = _baseColor;\n\n/// \"Accent\" is thin white circle generated by `onLongTapDown`. We use\n/// negative radius to indicate that the circle should not be drawn yet.\ndouble _accentRadius = -1e10;\nlate final _accentPaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 0\n..color = const Color(0xFFFFFFFF);\n\n/// At this radius the circle will disappear.\nstatic const maxRadius = 175;\nstatic final random = Random();\n\ndouble get radius => (_innerRadius + _outerRadius) / 2;\n\nvoid release() => _released = true;\nvoid cancel() => _cancelled = true;\nvoid accent() => _accentRadius = 0;\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawCircle(_center.toOffset(), radius, _paint);\nif (_accentRadius >= 0) {\ncanvas.drawCircle(_center.toOffset(), _accentRadius, _accentPaint);\n}\n}\n\n@override\nvoid update(double dt) {\nif (_cancelled) {\n_innerRadius += dt * 100; // implosion\n} else {\n_outerRadius += dt * 20;\n_innerRadius += dt * (_released ? 20 : 6);\n_accentRadius += dt * 20;\n}\nif (radius >= maxRadius || _innerRadius > _outerRadius) {\nremoveFromParent();\n} else {\nfinal opacity = 1 - radius / maxRadius;\n_paint.color = _baseColor.withValues(alpha: opacity);\n_paint.strokeWidth = _outerRadius - _innerRadius;\n}\n}\n}"}
{"prompt": "Write Flutter Flame code to Demo¶: The blue-ish rectangle in the middle is the component that has the TapCallbacks mixin. Tapping this component would create circles at the points of touch. Specifically, onTapDown event starts making the circle. The thickness of the circle will be proportional to the duration of the tap: after onTapUp the circle’s stroke width will no longer grow. There will be a thin white stripe at the moment the onLongTapDown fires. Lastly, the circle will implode and disappear if you cause the onTapCancel event by moving the finger.", "completion": "import 'dart:math';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flutter/rendering.dart';\n\nclass TapEventsGame extends FlameGame {\n@override\nFuture<void> onLoad() async {\nadd(TapTarget());\n}\n}\n\n/// This component is the tappable blue-ish rectangle in the center of the game.\n/// It uses the [TapCallbacks] mixin to receive tap events.\nclass TapTarget extends PositionComponent with TapCallbacks {\nTapTarget() : super(anchor: Anchor.center);\n\nfinal _paint = Paint()..color = const Color(0x448BA8FF);\n\n/// We will store all current circles into this map, keyed by the `pointerId`\n/// of the event that created the circle.\nfinal Map<int, ExpandingCircle> _circles = {};\n\n@override\nvoid onGameResize(Vector2 size) {\nsuper.onGameResize(size);\nthis.size = size - Vector2(100, 75);\nif (this.size.x < 100 || this.size.y < 100) {\nthis.size = size * 0.9;\n}\nposition = size / 2;\n}\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRect(size.toRect(), _paint);\n}\n\n@override\nvoid onTapDown(TapDownEvent event) {\nfinal circle = ExpandingCircle(event.localPosition);\n_circles[event.pointerId] = circle;\nadd(circle);\n}\n\n@override\nvoid onLongTapDown(TapDownEvent event) {\n_circles[event.pointerId]!.accent();\n}\n\n@override\nvoid onTapUp(TapUpEvent event) {\n_circles.remove(event.pointerId)!.release();\n}\n\n@override\nvoid onTapCancel(TapCancelEvent event) {\n_circles.remove(event.pointerId)!.cancel();\n}\n}\n\nclass ExpandingCircle extends Component {\nExpandingCircle(this._center)\n: _baseColor =\nHSLColor.fromAHSL(1, random.nextDouble() * 360, 1, 0.8).toColor();\n\nfinal Color _baseColor;\nfinal Vector2 _center;\ndouble _outerRadius = 0;\ndouble _innerRadius = 0;\nbool _released = false;\nbool _cancelled = false;\nlate final _paint = Paint()\n..style = PaintingStyle.stroke\n..color = _baseColor;\n\n/// \"Accent\" is thin white circle generated by `onLongTapDown`. We use\n/// negative radius to indicate that the circle should not be drawn yet.\ndouble _accentRadius = -1e10;\nlate final _accentPaint = Paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 0\n..color = const Color(0xFFFFFFFF);\n\n/// At this radius the circle will disappear.\nstatic const maxRadius = 175;\nstatic final random = Random();\n\ndouble get radius => (_innerRadius + _outerRadius) / 2;\n\nvoid release() => _released = true;\nvoid cancel() => _cancelled = true;\nvoid accent() => _accentRadius = 0;\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawCircle(_center.toOffset(), radius, _paint);\nif (_accentRadius >= 0) {\ncanvas.drawCircle(_center.toOffset(), _accentRadius, _accentPaint);\n}\n}\n\n@override\nvoid update(double dt) {\nif (_cancelled) {\n_innerRadius += dt * 100; // implosion\n} else {\n_outerRadius += dt * 20;\n_innerRadius += dt * (_released ? 20 : 6);\n_accentRadius += dt * 20;\n}\nif (radius >= maxRadius || _innerRadius > _outerRadius) {\nremoveFromParent();\n} else {\nfinal opacity = 1 - radius / maxRadius;\n_paint.color = _baseColor.withValues(alpha: opacity);\n_paint.strokeWidth = _outerRadius - _innerRadius;\n}\n}\n}"}
{"prompt": "Create a Flutter Flame game component that TapCallbacks¶: If your component is a part of a larger hierarchy, then it will only receive tap events if its parent has implemented the containsLocalPoint correctly.", "completion": "class MyComponent extends Component with TapCallbacks {\n  final _rect = const Rect.fromLTWH(0, 0, 100, 100);\n  final _paint = Paint();\n  bool _isPressed = false;\n\n  @override\n  bool containsLocalPoint(Vector2 point) => _rect.contains(point.toOffset());\n\n  @override\n  void onTapDown(TapDownEvent event) => _isPressed = true;\n\n  @override\n  void onTapUp(TapUpEvent event) => _isPressed = false;\n\n  @override\n  void onTapCancel(TapCancelEvent event) => _isPressed = false;\n\n  @override\n  void render(Canvas canvas) {\n    _paint.color = _isPressed? Colors.red : Colors.white;\n    canvas.drawRect(_rect, _paint);\n  }\n}"}
{"prompt": "Show me how to implement TapCallbacks¶: If your component is a part of a larger hierarchy, then it will only receive tap events if its parent has implemented the containsLocalPoint correctly. using Flutter Flame", "completion": "class MyComponent extends Component with TapCallbacks {\n  final _rect = const Rect.fromLTWH(0, 0, 100, 100);\n  final _paint = Paint();\n  bool _isPressed = false;\n\n  @override\n  bool containsLocalPoint(Vector2 point) => _rect.contains(point.toOffset());\n\n  @override\n  void onTapDown(TapDownEvent event) => _isPressed = true;\n\n  @override\n  void onTapUp(TapUpEvent event) => _isPressed = false;\n\n  @override\n  void onTapCancel(TapCancelEvent event) => _isPressed = false;\n\n  @override\n  void render(Canvas canvas) {\n    _paint.color = _isPressed? Colors.red : Colors.white;\n    canvas.drawRect(_rect, _paint);\n  }\n}"}
{"prompt": "Write Flutter Flame code to TapCallbacks¶: If your component is a part of a larger hierarchy, then it will only receive tap events if its parent has implemented the containsLocalPoint correctly.", "completion": "class MyComponent extends Component with TapCallbacks {\n  final _rect = const Rect.fromLTWH(0, 0, 100, 100);\n  final _paint = Paint();\n  bool _isPressed = false;\n\n  @override\n  bool containsLocalPoint(Vector2 point) => _rect.contains(point.toOffset());\n\n  @override\n  void onTapDown(TapDownEvent event) => _isPressed = true;\n\n  @override\n  void onTapUp(TapUpEvent event) => _isPressed = false;\n\n  @override\n  void onTapCancel(TapCancelEvent event) => _isPressed = false;\n\n  @override\n  void render(Canvas canvas) {\n    _paint.color = _isPressed? Colors.red : Colors.white;\n    canvas.drawRect(_rect, _paint);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that DoubleTapCallbacks¶: Flame also offers a mixin named DoubleTapCallbacks to receive a double-tap event from the component. To start receiving double tap events in a component, add the DoubleTapCallbacks mixin to your PositionComponent.", "completion": "class MyComponent extends PositionComponent with DoubleTapCallbacks {\n  @override\n  void onDoubleTapUp(DoubleTapEvent event) {\n    /// Do something\n  }\n\n  @override\n  void onDoubleTapCancel(DoubleTapCancelEvent event) {\n    /// Do something\n  }\n\n  @override\n  void onDoubleTapDown(DoubleTapDownEvent event) {\n    /// Do something\n  }"}
{"prompt": "Show me how to implement DoubleTapCallbacks¶: Flame also offers a mixin named DoubleTapCallbacks to receive a double-tap event from the component. To start receiving double tap events in a component, add the DoubleTapCallbacks mixin to your PositionComponent. using Flutter Flame", "completion": "class MyComponent extends PositionComponent with DoubleTapCallbacks {\n  @override\n  void onDoubleTapUp(DoubleTapEvent event) {\n    /// Do something\n  }\n\n  @override\n  void onDoubleTapCancel(DoubleTapCancelEvent event) {\n    /// Do something\n  }\n\n  @override\n  void onDoubleTapDown(DoubleTapDownEvent event) {\n    /// Do something\n  }"}
{"prompt": "Write Flutter Flame code to DoubleTapCallbacks¶: Flame also offers a mixin named DoubleTapCallbacks to receive a double-tap event from the component. To start receiving double tap events in a component, add the DoubleTapCallbacks mixin to your PositionComponent.", "completion": "class MyComponent extends PositionComponent with DoubleTapCallbacks {\n  @override\n  void onDoubleTapUp(DoubleTapEvent event) {\n    /// Do something\n  }\n\n  @override\n  void onDoubleTapCancel(DoubleTapCancelEvent event) {\n    /// Do something\n  }\n\n  @override\n  void onDoubleTapDown(DoubleTapDownEvent event) {\n    /// Do something\n  }"}
{"prompt": "Create a Flutter Flame game component that 5. Clean up the project files¶: First, open the file pubspec.yaml and replace it with the following code (adjusting the name and description to match your project):", "completion": "name: syzygy\ndescription: Syzygy Flame game\nversion: 0.0.0\npublish_to: none\n\nenvironment:\n  sdk: ^3.0.0\n  flutter: ^3.13.0\n\ndependencies:\n  flutter:\n    sdk: flutter\n  flame: ^1.23.0"}
{"prompt": "Show me how to implement 5. Clean up the project files¶: First, open the file pubspec.yaml and replace it with the following code (adjusting the name and description to match your project): using Flutter Flame", "completion": "name: syzygy\ndescription: Syzygy Flame game\nversion: 0.0.0\npublish_to: none\n\nenvironment:\n  sdk: ^3.0.0\n  flutter: ^3.13.0\n\ndependencies:\n  flutter:\n    sdk: flutter\n  flame: ^1.23.0"}
{"prompt": "Write Flutter Flame code to 5. Clean up the project files¶: First, open the file pubspec.yaml and replace it with the following code (adjusting the name and description to match your project):", "completion": "name: syzygy\ndescription: Syzygy Flame game\nversion: 0.0.0\npublish_to: none\n\nenvironment:\n  sdk: ^3.0.0\n  flutter: ^3.13.0\n\ndependencies:\n  flutter:\n    sdk: flutter\n  flame: ^1.23.0"}
{"prompt": "Create a Flutter Flame game component that 5. Clean up the project files¶: Now, open the file lib/main.dart and replace its content with the following:", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/widgets.dart';\n\nvoid main() {\n  final game = FlameGame();\n  runApp(GameWidget(game: game));\n}"}
{"prompt": "Show me how to implement 5. Clean up the project files¶: Now, open the file lib/main.dart and replace its content with the following: using Flutter Flame", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/widgets.dart';\n\nvoid main() {\n  final game = FlameGame();\n  runApp(GameWidget(game: game));\n}"}
{"prompt": "Write Flutter Flame code to 5. Clean up the project files¶: Now, open the file lib/main.dart and replace its content with the following:", "completion": "import 'package:flame/game.dart';\nimport 'package:flutter/widgets.dart';\n\nvoid main() {\n  final game = FlameGame();\n  runApp(GameWidget(game: game));\n}"}
{"prompt": "Create a Flutter Flame game component that Star¶: The star is pretty simple. It is just like the Platform block except we are going to add an effect to make it pulse in size. For the effect to look correct, we need to change the object’s Anchor to center. This means we will need to adjust the position by half of the image size. For brevity, I am going to add the whole class and explain the additional changes after.", "completion": "import 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\n\nclass Star extends SpriteComponent\n    with HasGameReference<EmberQuestGame> {\n  final Vector2 gridPosition;\n  double xOffset;\n\n  final Vector2 velocity = Vector2.zero();\n\n  Star({\n    required this.gridPosition,\n    required this.xOffset,\n  }) : super(size: Vector2.all(64), anchor: Anchor.center);\n\n  @override\n  void onLoad() {\n    final starImage = game.images.fromCache('star.png');\n    sprite = Sprite(starImage);\n    position = Vector2(\n      (gridPosition.x * size.x) + xOffset + (size.x / 2),\n      game.size.y - (gridPosition.y * size.y) - (size.y / 2),\n    );\n    add(RectangleHitbox(collisionType: CollisionType.passive));\n    add(\n      SizeEffect.by(\n        Vector2(-24, -24),\n        EffectController(\n          duration: .75,\n          reverseDuration: .5,\n          infinite: true,\n          curve: Curves.easeOut,\n        ),\n      ),\n    );\n  }\n\n  @override\n  void update(double dt) {\n    velocity.x = game.objectSpeed;\n    position += velocity * dt;\n    if (position.x < -size.x) removeFromParent();\n    super.update(dt);\n  }\n}"}
{"prompt": "Show me how to implement Star¶: The star is pretty simple. It is just like the Platform block except we are going to add an effect to make it pulse in size. For the effect to look correct, we need to change the object’s Anchor to center. This means we will need to adjust the position by half of the image size. For brevity, I am going to add the whole class and explain the additional changes after. using Flutter Flame", "completion": "import 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\n\nclass Star extends SpriteComponent\n    with HasGameReference<EmberQuestGame> {\n  final Vector2 gridPosition;\n  double xOffset;\n\n  final Vector2 velocity = Vector2.zero();\n\n  Star({\n    required this.gridPosition,\n    required this.xOffset,\n  }) : super(size: Vector2.all(64), anchor: Anchor.center);\n\n  @override\n  void onLoad() {\n    final starImage = game.images.fromCache('star.png');\n    sprite = Sprite(starImage);\n    position = Vector2(\n      (gridPosition.x * size.x) + xOffset + (size.x / 2),\n      game.size.y - (gridPosition.y * size.y) - (size.y / 2),\n    );\n    add(RectangleHitbox(collisionType: CollisionType.passive));\n    add(\n      SizeEffect.by(\n        Vector2(-24, -24),\n        EffectController(\n          duration: .75,\n          reverseDuration: .5,\n          infinite: true,\n          curve: Curves.easeOut,\n        ),\n      ),\n    );\n  }\n\n  @override\n  void update(double dt) {\n    velocity.x = game.objectSpeed;\n    position += velocity * dt;\n    if (position.x < -size.x) removeFromParent();\n    super.update(dt);\n  }\n}"}
{"prompt": "Write Flutter Flame code to Star¶: The star is pretty simple. It is just like the Platform block except we are going to add an effect to make it pulse in size. For the effect to look correct, we need to change the object’s Anchor to center. This means we will need to adjust the position by half of the image size. For brevity, I am going to add the whole class and explain the additional changes after.", "completion": "import 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\n\nclass Star extends SpriteComponent\n    with HasGameReference<EmberQuestGame> {\n  final Vector2 gridPosition;\n  double xOffset;\n\n  final Vector2 velocity = Vector2.zero();\n\n  Star({\n    required this.gridPosition,\n    required this.xOffset,\n  }) : super(size: Vector2.all(64), anchor: Anchor.center);\n\n  @override\n  void onLoad() {\n    final starImage = game.images.fromCache('star.png');\n    sprite = Sprite(starImage);\n    position = Vector2(\n      (gridPosition.x * size.x) + xOffset + (size.x / 2),\n      game.size.y - (gridPosition.y * size.y) - (size.y / 2),\n    );\n    add(RectangleHitbox(collisionType: CollisionType.passive));\n    add(\n      SizeEffect.by(\n        Vector2(-24, -24),\n        EffectController(\n          duration: .75,\n          reverseDuration: .5,\n          infinite: true,\n          curve: Curves.easeOut,\n        ),\n      ),\n    );\n  }\n\n  @override\n  void update(double dt) {\n    velocity.x = game.objectSpeed;\n    position += velocity * dt;\n    if (position.x < -size.x) removeFromParent();\n    super.update(dt);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Star¶: So the only change between the Star and the Platform beyond the anchor is simply the following:", "completion": "add(\n  SizeEffect.by(\n    Vector2(-24, -24),\n    EffectController(\n      duration: .75,\n      reverseDuration: .5,\n      infinite: true,\n      curve: Curves.easeOut,\n    ),\n  ),\n);"}
{"prompt": "Show me how to implement Star¶: So the only change between the Star and the Platform beyond the anchor is simply the following: using Flutter Flame", "completion": "add(\n  SizeEffect.by(\n    Vector2(-24, -24),\n    EffectController(\n      duration: .75,\n      reverseDuration: .5,\n      infinite: true,\n      curve: Curves.easeOut,\n    ),\n  ),\n);"}
{"prompt": "Write Flutter Flame code to Star¶: So the only change between the Star and the Platform beyond the anchor is simply the following:", "completion": "add(\n  SizeEffect.by(\n    Vector2(-24, -24),\n    EffectController(\n      duration: .75,\n      reverseDuration: .5,\n      infinite: true,\n      curve: Curves.easeOut,\n    ),\n  ),\n);"}
{"prompt": "Create a Flutter Flame game component that Water Enemy¶: Now that we understand adding effects to our objects, let’s do the same for the water drop enemy. Open lib/actors/water_enemy.dart and add the following code:", "completion": "import 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\n\nimport '../ember_quest.dart';\n\nclass WaterEnemy extends SpriteAnimationComponent\n    with HasGameReference<EmberQuestGame> {\n  final Vector2 gridPosition;\n  double xOffset;\n\n  final Vector2 velocity = Vector2.zero();\n\n  WaterEnemy({\n    required this.gridPosition,\n    required this.xOffset,\n  }) : super(size: Vector2.all(64), anchor: Anchor.bottomLeft);\n\n  @override\n  void onLoad() {\n    animation = SpriteAnimation.fromFrameData(\n      game.images.fromCache('water_enemy.png'),\n      SpriteAnimationData.sequenced(\n        amount: 2,\n        textureSize: Vector2.all(16),\n        stepTime: 0.70,\n      ),\n    );\n    position = Vector2(\n      (gridPosition.x * size.x) + xOffset,\n      game.size.y - (gridPosition.y * size.y),\n    );\n    add(RectangleHitbox(collisionType: CollisionType.passive));\n    add(\n      MoveEffect.by(\n        Vector2(-2 * size.x, 0),\n        EffectController(\n          duration: 3,\n          alternate: true,\n          infinite: true,\n        ),\n      ),\n    );\n  }\n\n  @override\n  void update(double dt) {\n    velocity.x = game.objectSpeed;\n    position += velocity * dt;\n    if (position.x < -size.x) removeFromParent();\n    super.update(dt);\n  }\n}"}
{"prompt": "Show me how to implement Water Enemy¶: Now that we understand adding effects to our objects, let’s do the same for the water drop enemy. Open lib/actors/water_enemy.dart and add the following code: using Flutter Flame", "completion": "import 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\n\nimport '../ember_quest.dart';\n\nclass WaterEnemy extends SpriteAnimationComponent\n    with HasGameReference<EmberQuestGame> {\n  final Vector2 gridPosition;\n  double xOffset;\n\n  final Vector2 velocity = Vector2.zero();\n\n  WaterEnemy({\n    required this.gridPosition,\n    required this.xOffset,\n  }) : super(size: Vector2.all(64), anchor: Anchor.bottomLeft);\n\n  @override\n  void onLoad() {\n    animation = SpriteAnimation.fromFrameData(\n      game.images.fromCache('water_enemy.png'),\n      SpriteAnimationData.sequenced(\n        amount: 2,\n        textureSize: Vector2.all(16),\n        stepTime: 0.70,\n      ),\n    );\n    position = Vector2(\n      (gridPosition.x * size.x) + xOffset,\n      game.size.y - (gridPosition.y * size.y),\n    );\n    add(RectangleHitbox(collisionType: CollisionType.passive));\n    add(\n      MoveEffect.by(\n        Vector2(-2 * size.x, 0),\n        EffectController(\n          duration: 3,\n          alternate: true,\n          infinite: true,\n        ),\n      ),\n    );\n  }\n\n  @override\n  void update(double dt) {\n    velocity.x = game.objectSpeed;\n    position += velocity * dt;\n    if (position.x < -size.x) removeFromParent();\n    super.update(dt);\n  }\n}"}
{"prompt": "Write Flutter Flame code to Water Enemy¶: Now that we understand adding effects to our objects, let’s do the same for the water drop enemy. Open lib/actors/water_enemy.dart and add the following code:", "completion": "import 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\n\nimport '../ember_quest.dart';\n\nclass WaterEnemy extends SpriteAnimationComponent\n    with HasGameReference<EmberQuestGame> {\n  final Vector2 gridPosition;\n  double xOffset;\n\n  final Vector2 velocity = Vector2.zero();\n\n  WaterEnemy({\n    required this.gridPosition,\n    required this.xOffset,\n  }) : super(size: Vector2.all(64), anchor: Anchor.bottomLeft);\n\n  @override\n  void onLoad() {\n    animation = SpriteAnimation.fromFrameData(\n      game.images.fromCache('water_enemy.png'),\n      SpriteAnimationData.sequenced(\n        amount: 2,\n        textureSize: Vector2.all(16),\n        stepTime: 0.70,\n      ),\n    );\n    position = Vector2(\n      (gridPosition.x * size.x) + xOffset,\n      game.size.y - (gridPosition.y * size.y),\n    );\n    add(RectangleHitbox(collisionType: CollisionType.passive));\n    add(\n      MoveEffect.by(\n        Vector2(-2 * size.x, 0),\n        EffectController(\n          duration: 3,\n          alternate: true,\n          infinite: true,\n        ),\n      ),\n    );\n  }\n\n  @override\n  void update(double dt) {\n    velocity.x = game.objectSpeed;\n    position += velocity * dt;\n    if (position.x < -size.x) removeFromParent();\n    super.update(dt);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Ground Blocks¶: So let’s start with the basic class which is nothing more than a copy of the Platform Block.", "completion": "import 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\n\nclass GroundBlock extends SpriteComponent with HasGameReference<EmberQuestGame> {\n  final Vector2 gridPosition;\n  double xOffset;\n\n  final Vector2 velocity = Vector2.zero();\n\n  GroundBlock({\n    required this.gridPosition,\n    required this.xOffset,\n  }) : super(size: Vector2.all(64), anchor: Anchor.bottomLeft);\n\n  @override\n  void onLoad() {\n    final groundImage = game.images.fromCache('ground.png');\n    sprite = Sprite(groundImage);\n    position = Vector2(\n      gridPosition.x * size.x + xOffset,\n      game.size.y - gridPosition.y * size.y,\n    );\n    add(RectangleHitbox(collisionType: CollisionType.passive));\n  }\n\n  @override\n  void update(double dt) {\n    velocity.x = game.objectSpeed;\n    position += velocity * dt;\n    super.update(dt);\n  }\n}"}
{"prompt": "Show me how to implement Ground Blocks¶: So let’s start with the basic class which is nothing more than a copy of the Platform Block. using Flutter Flame", "completion": "import 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\n\nclass GroundBlock extends SpriteComponent with HasGameReference<EmberQuestGame> {\n  final Vector2 gridPosition;\n  double xOffset;\n\n  final Vector2 velocity = Vector2.zero();\n\n  GroundBlock({\n    required this.gridPosition,\n    required this.xOffset,\n  }) : super(size: Vector2.all(64), anchor: Anchor.bottomLeft);\n\n  @override\n  void onLoad() {\n    final groundImage = game.images.fromCache('ground.png');\n    sprite = Sprite(groundImage);\n    position = Vector2(\n      gridPosition.x * size.x + xOffset,\n      game.size.y - gridPosition.y * size.y,\n    );\n    add(RectangleHitbox(collisionType: CollisionType.passive));\n  }\n\n  @override\n  void update(double dt) {\n    velocity.x = game.objectSpeed;\n    position += velocity * dt;\n    super.update(dt);\n  }\n}"}
{"prompt": "Write Flutter Flame code to Ground Blocks¶: So let’s start with the basic class which is nothing more than a copy of the Platform Block.", "completion": "import 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\n\nclass GroundBlock extends SpriteComponent with HasGameReference<EmberQuestGame> {\n  final Vector2 gridPosition;\n  double xOffset;\n\n  final Vector2 velocity = Vector2.zero();\n\n  GroundBlock({\n    required this.gridPosition,\n    required this.xOffset,\n  }) : super(size: Vector2.all(64), anchor: Anchor.bottomLeft);\n\n  @override\n  void onLoad() {\n    final groundImage = game.images.fromCache('ground.png');\n    sprite = Sprite(groundImage);\n    position = Vector2(\n      gridPosition.x * size.x + xOffset,\n      game.size.y - gridPosition.y * size.y,\n    );\n    add(RectangleHitbox(collisionType: CollisionType.passive));\n  }\n\n  @override\n  void update(double dt) {\n    velocity.x = game.objectSpeed;\n    position += velocity * dt;\n    super.update(dt);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Loading the Next Random Segment¶: Back in our Ground Block, we can now add the following to our ‘update’ method before the other block we just added:", "completion": "if (position.x < -size.x) {\n  removeFromParent();\n  if (gridPosition.x == 0) {\n    game.loadGameSegments(\n      Random().nextInt(segments.length),\n      game.lastBlockXPosition,\n    );\n  }\n}"}
{"prompt": "Show me how to implement Loading the Next Random Segment¶: Back in our Ground Block, we can now add the following to our ‘update’ method before the other block we just added: using Flutter Flame", "completion": "if (position.x < -size.x) {\n  removeFromParent();\n  if (gridPosition.x == 0) {\n    game.loadGameSegments(\n      Random().nextInt(segments.length),\n      game.lastBlockXPosition,\n    );\n  }\n}"}
{"prompt": "Write Flutter Flame code to Loading the Next Random Segment¶: Back in our Ground Block, we can now add the following to our ‘update’ method before the other block we just added:", "completion": "if (position.x < -size.x) {\n  removeFromParent();\n  if (gridPosition.x == 0) {\n    game.loadGameSegments(\n      Random().nextInt(segments.length),\n      game.lastBlockXPosition,\n    );\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Loading the Next Random Segment¶: This simply extends the code that we have in our other objects, where once the block is off the screen and if the block is the first block of the segment, we will call the loadGameSegments method in our game class, get a random number between 0 and the number of segments and pass in the offset. If Random() or segments.length does not auto-import, you will need:", "completion": "import 'dart:math';\n\nimport '../managers/segment_manager.dart';"}
{"prompt": "Show me how to implement Loading the Next Random Segment¶: This simply extends the code that we have in our other objects, where once the block is off the screen and if the block is the first block of the segment, we will call the loadGameSegments method in our game class, get a random number between 0 and the number of segments and pass in the offset. If Random() or segments.length does not auto-import, you will need: using Flutter Flame", "completion": "import 'dart:math';\n\nimport '../managers/segment_manager.dart';"}
{"prompt": "Write Flutter Flame code to Loading the Next Random Segment¶: This simply extends the code that we have in our other objects, where once the block is off the screen and if the block is the first block of the segment, we will call the loadGameSegments method in our game class, get a random number between 0 and the number of segments and pass in the offset. If Random() or segments.length does not auto-import, you will need:", "completion": "import 'dart:math';\n\nimport '../managers/segment_manager.dart';"}
{"prompt": "Create a Flutter Flame game component that Loading the Next Random Segment¶: So our full Ground Block class should look like this:", "completion": "import 'dart:math';\n\nimport 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\nimport '../managers/segment_manager.dart';\n\nclass GroundBlock extends SpriteComponent with HasGameReference<EmberQuestGame> {\n  final Vector2 gridPosition;\n  double xOffset;\n  \n  final UniqueKey _blockKey = UniqueKey();\n  final Vector2 velocity = Vector2.zero();\n\n  GroundBlock({\n    required this.gridPosition,\n    required this.xOffset,\n  }) : super(size: Vector2.all(64), anchor: Anchor.bottomLeft);\n\n  @override\n  void onLoad() {\n    final groundImage = game.images.fromCache('ground.png');\n    sprite = Sprite(groundImage);\n    position = Vector2(\n      gridPosition.x * size.x + xOffset,\n      game.size.y - gridPosition.y * size.y,\n    );\n    add(RectangleHitbox(collisionType: CollisionType.passive));\n    if (gridPosition.x == 9 && position.x > game.lastBlockXPosition) {\n      game.lastBlockKey = _blockKey;\n      game.lastBlockXPosition = position.x + size.x;\n    }\n  }\n\n  @override\n  void update(double dt) {\n    velocity.x = game.objectSpeed;\n    position += velocity * dt;\n\n    if (position.x < -size.x) {\n      removeFromParent();\n      if (gridPosition.x == 0) {\n        game.loadGameSegments(\n          Random().nextInt(segments.length),\n          game.lastBlockXPosition,\n        );\n      }\n    }\n    if (gridPosition.x == 9) {\n      if (game.lastBlockKey == _blockKey) {\n        game.lastBlockXPosition = position.x + size.x - 10;\n      }\n    }\n\n    super.update(dt);\n  }\n}"}
{"prompt": "Show me how to implement Loading the Next Random Segment¶: So our full Ground Block class should look like this: using Flutter Flame", "completion": "import 'dart:math';\n\nimport 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\nimport '../managers/segment_manager.dart';\n\nclass GroundBlock extends SpriteComponent with HasGameReference<EmberQuestGame> {\n  final Vector2 gridPosition;\n  double xOffset;\n  \n  final UniqueKey _blockKey = UniqueKey();\n  final Vector2 velocity = Vector2.zero();\n\n  GroundBlock({\n    required this.gridPosition,\n    required this.xOffset,\n  }) : super(size: Vector2.all(64), anchor: Anchor.bottomLeft);\n\n  @override\n  void onLoad() {\n    final groundImage = game.images.fromCache('ground.png');\n    sprite = Sprite(groundImage);\n    position = Vector2(\n      gridPosition.x * size.x + xOffset,\n      game.size.y - gridPosition.y * size.y,\n    );\n    add(RectangleHitbox(collisionType: CollisionType.passive));\n    if (gridPosition.x == 9 && position.x > game.lastBlockXPosition) {\n      game.lastBlockKey = _blockKey;\n      game.lastBlockXPosition = position.x + size.x;\n    }\n  }\n\n  @override\n  void update(double dt) {\n    velocity.x = game.objectSpeed;\n    position += velocity * dt;\n\n    if (position.x < -size.x) {\n      removeFromParent();\n      if (gridPosition.x == 0) {\n        game.loadGameSegments(\n          Random().nextInt(segments.length),\n          game.lastBlockXPosition,\n        );\n      }\n    }\n    if (gridPosition.x == 9) {\n      if (game.lastBlockKey == _blockKey) {\n        game.lastBlockXPosition = position.x + size.x - 10;\n      }\n    }\n\n    super.update(dt);\n  }\n}"}
{"prompt": "Write Flutter Flame code to Loading the Next Random Segment¶: So our full Ground Block class should look like this:", "completion": "import 'dart:math';\n\nimport 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flutter/material.dart';\n\nimport '../ember_quest.dart';\nimport '../managers/segment_manager.dart';\n\nclass GroundBlock extends SpriteComponent with HasGameReference<EmberQuestGame> {\n  final Vector2 gridPosition;\n  double xOffset;\n  \n  final UniqueKey _blockKey = UniqueKey();\n  final Vector2 velocity = Vector2.zero();\n\n  GroundBlock({\n    required this.gridPosition,\n    required this.xOffset,\n  }) : super(size: Vector2.all(64), anchor: Anchor.bottomLeft);\n\n  @override\n  void onLoad() {\n    final groundImage = game.images.fromCache('ground.png');\n    sprite = Sprite(groundImage);\n    position = Vector2(\n      gridPosition.x * size.x + xOffset,\n      game.size.y - gridPosition.y * size.y,\n    );\n    add(RectangleHitbox(collisionType: CollisionType.passive));\n    if (gridPosition.x == 9 && position.x > game.lastBlockXPosition) {\n      game.lastBlockKey = _blockKey;\n      game.lastBlockXPosition = position.x + size.x;\n    }\n  }\n\n  @override\n  void update(double dt) {\n    velocity.x = game.objectSpeed;\n    position += velocity * dt;\n\n    if (position.x < -size.x) {\n      removeFromParent();\n      if (gridPosition.x == 0) {\n        game.loadGameSegments(\n          Random().nextInt(segments.length),\n          game.lastBlockXPosition,\n        );\n      }\n    }\n    if (gridPosition.x == 9) {\n      if (game.lastBlockKey == _blockKey) {\n        game.lastBlockXPosition = position.x + size.x - 10;\n      }\n    }\n\n    super.update(dt);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Usage¶: Then you have the following methods at your disposal:", "completion": "import 'package:flame_fire_atlas/flame_fire_atlas.dart';\n\n// Load the atlas from your assets\n// file at assets/atlas.fa\nfinal atlas = await FireAtlas.loadAsset('atlas.fa');\n\n//or when inside a game instance, the loadFireAtlas can be used:\n// file at assets/atlas.fa\nfinal atlas = await loadFireAtlas('atlas.fa');\n\n// Get a Sprite with the given key.\nFireAtlas.getSprite('sprite_name')\n\n// Get a SpriteAnimation with the given key.\nFireAtlas.getAnimation('animation_name')"}
{"prompt": "Show me how to implement Usage¶: Then you have the following methods at your disposal: using Flutter Flame", "completion": "import 'package:flame_fire_atlas/flame_fire_atlas.dart';\n\n// Load the atlas from your assets\n// file at assets/atlas.fa\nfinal atlas = await FireAtlas.loadAsset('atlas.fa');\n\n//or when inside a game instance, the loadFireAtlas can be used:\n// file at assets/atlas.fa\nfinal atlas = await loadFireAtlas('atlas.fa');\n\n// Get a Sprite with the given key.\nFireAtlas.getSprite('sprite_name')\n\n// Get a SpriteAnimation with the given key.\nFireAtlas.getAnimation('animation_name')"}
{"prompt": "Write Flutter Flame code to Usage¶: Then you have the following methods at your disposal:", "completion": "import 'package:flame_fire_atlas/flame_fire_atlas.dart';\n\n// Load the atlas from your assets\n// file at assets/atlas.fa\nfinal atlas = await FireAtlas.loadAsset('atlas.fa');\n\n//or when inside a game instance, the loadFireAtlas can be used:\n// file at assets/atlas.fa\nfinal atlas = await loadFireAtlas('atlas.fa');\n\n// Get a Sprite with the given key.\nFireAtlas.getSprite('sprite_name')\n\n// Get a SpriteAnimation with the given key.\nFireAtlas.getAnimation('animation_name')"}
{"prompt": "Create a Flutter Flame game component that Usage¶: To use FireAtlas in your game, load the fire atlas file in an onLoad method, either in your game or a component. Then you can use getSprite and getAnimation to retrieve the mapped assets.", "completion": "class ExampleGame extends FlameGame {\n\n  late FireAtlas _atlas;\n\n  @override\n  Future<void> onLoad() async {\n    _atlas = await loadFireAtlas('atlas.fa');\n\n    add(\n      SpriteComponent(\n        size: Vector2(50, 50),\n        position: Vector2(0, 50),\n        sprite: _atlas.getSprite('sprite_name'),\n      ),\n    );\n\n    add(\n      SpriteAnimationComponent(\n        size: Vector2(150, 100),\n        position: Vector2(150, 100),\n        animation: _atlas.getAnimation('animation_name'),\n      ),\n    );\n  }\n\n}"}
{"prompt": "Show me how to implement Usage¶: To use FireAtlas in your game, load the fire atlas file in an onLoad method, either in your game or a component. Then you can use getSprite and getAnimation to retrieve the mapped assets. using Flutter Flame", "completion": "class ExampleGame extends FlameGame {\n\n  late FireAtlas _atlas;\n\n  @override\n  Future<void> onLoad() async {\n    _atlas = await loadFireAtlas('atlas.fa');\n\n    add(\n      SpriteComponent(\n        size: Vector2(50, 50),\n        position: Vector2(0, 50),\n        sprite: _atlas.getSprite('sprite_name'),\n      ),\n    );\n\n    add(\n      SpriteAnimationComponent(\n        size: Vector2(150, 100),\n        position: Vector2(150, 100),\n        animation: _atlas.getAnimation('animation_name'),\n      ),\n    );\n  }\n\n}"}
{"prompt": "Write Flutter Flame code to Usage¶: To use FireAtlas in your game, load the fire atlas file in an onLoad method, either in your game or a component. Then you can use getSprite and getAnimation to retrieve the mapped assets.", "completion": "class ExampleGame extends FlameGame {\n\n  late FireAtlas _atlas;\n\n  @override\n  Future<void> onLoad() async {\n    _atlas = await loadFireAtlas('atlas.fa');\n\n    add(\n      SpriteComponent(\n        size: Vector2(50, 50),\n        position: Vector2(0, 50),\n        sprite: _atlas.getSprite('sprite_name'),\n      ),\n    );\n\n    add(\n      SpriteAnimationComponent(\n        size: Vector2(150, 100),\n        position: Vector2(150, 100),\n        animation: _atlas.getAnimation('animation_name'),\n      ),\n    );\n  }\n\n}"}
{"prompt": "Create a Flutter Flame game component that Game Widget¶: The GameWidget is sufficiently feature-rich to run as the root of your Flutter application. Thus, the simplest way to use GameWidget is like this:", "completion": "void main() {\n  runApp(\n    GameWidget(game: MyGame()),\n  );\n}"}
{"prompt": "Show me how to implement Game Widget¶: The GameWidget is sufficiently feature-rich to run as the root of your Flutter application. Thus, the simplest way to use GameWidget is like this: using Flutter Flame", "completion": "void main() {\n  runApp(\n    GameWidget(game: MyGame()),\n  );\n}"}
{"prompt": "Write Flutter Flame code to Game Widget¶: The GameWidget is sufficiently feature-rich to run as the root of your Flutter application. Thus, the simplest way to use GameWidget is like this:", "completion": "void main() {\n  runApp(\n    GameWidget(game: MyGame()),\n  );\n}"}
{"prompt": "Create a Flutter Flame game component that Constructors¶: This constructor can be useful when you want to put GameWidget into another widget, but would like to avoid the need to store the game’s instance yourself. For example:", "completion": "class MyWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      padding: EdgeInsets.all(20),\n      child: GameWidget.controlled(\n        gameFactory: MyGame.new,\n      ),\n    );\n  }\n}"}
{"prompt": "Show me how to implement Constructors¶: This constructor can be useful when you want to put GameWidget into another widget, but would like to avoid the need to store the game’s instance yourself. For example: using Flutter Flame", "completion": "class MyWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      padding: EdgeInsets.all(20),\n      child: GameWidget.controlled(\n        gameFactory: MyGame.new,\n      ),\n    );\n  }\n}"}
{"prompt": "Write Flutter Flame code to Constructors¶: This constructor can be useful when you want to put GameWidget into another widget, but would like to avoid the need to store the game’s instance yourself. For example:", "completion": "class MyWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      padding: EdgeInsets.all(20),\n      child: GameWidget.controlled(\n        gameFactory: MyGame.new,\n      ),\n    );\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Properties¶: A collection of widgets that can be displayed over the game’s surface. These widgets can be turned on-and-off dynamically from within the game via the Game.overlays property.", "completion": "void main() {\n  runApp(\n    GameWidget(\n      game: MyGame(),\n      overlayBuilderMap: {\n        'PauseMenu': (context, game) {\n          return Container(\n            color: const Color(0xFF000000),\n            child: Text('A pause menu'),\n          );\n        },\n      },\n    ),\n  );\n}"}
{"prompt": "Show me how to implement Properties¶: A collection of widgets that can be displayed over the game’s surface. These widgets can be turned on-and-off dynamically from within the game via the Game.overlays property. using Flutter Flame", "completion": "void main() {\n  runApp(\n    GameWidget(\n      game: MyGame(),\n      overlayBuilderMap: {\n        'PauseMenu': (context, game) {\n          return Container(\n            color: const Color(0xFF000000),\n            child: Text('A pause menu'),\n          );\n        },\n      },\n    ),\n  );\n}"}
{"prompt": "Write Flutter Flame code to Properties¶: A collection of widgets that can be displayed over the game’s surface. These widgets can be turned on-and-off dynamically from within the game via the Game.overlays property.", "completion": "void main() {\n  runApp(\n    GameWidget(\n      game: MyGame(),\n      overlayBuilderMap: {\n        'PauseMenu': (context, game) {\n          return Container(\n            color: const Color(0xFF000000),\n            child: Text('A pause menu'),\n          );\n        },\n      },\n    ),\n  );\n}"}
{"prompt": "Create a Flutter Flame game component that Adding animations and depth¶: Flame provides us with a specialized classes to deal with such images: SpriteAnimation and its component wrapper SpriteAnimationComponent and changing our Player component to be an animation is quite simple, take a look at how the component will look like now:", "completion": "class Player extends SpriteAnimationComponent\n    with HasGameReference<SpaceShooterGame> {\n\n  Player() : super(\n    size: Vector2(100, 150),\n    anchor: Anchor.center,\n  );\n\n  @override\n  Future<void> onLoad() async {\n    await super.onLoad();\n\n    animation = await game.loadSpriteAnimation(\n      'player.png',\n      SpriteAnimationData.sequenced(\n        amount: 4,\n        stepTime: .2,\n        textureSize: Vector2(32, 48),\n      ),\n    );\n\n    position = game.size / 2;\n  }\n\n  // Other methods omitted\n}"}
{"prompt": "Show me how to implement Adding animations and depth¶: Flame provides us with a specialized classes to deal with such images: SpriteAnimation and its component wrapper SpriteAnimationComponent and changing our Player component to be an animation is quite simple, take a look at how the component will look like now: using Flutter Flame", "completion": "class Player extends SpriteAnimationComponent\n    with HasGameReference<SpaceShooterGame> {\n\n  Player() : super(\n    size: Vector2(100, 150),\n    anchor: Anchor.center,\n  );\n\n  @override\n  Future<void> onLoad() async {\n    await super.onLoad();\n\n    animation = await game.loadSpriteAnimation(\n      'player.png',\n      SpriteAnimationData.sequenced(\n        amount: 4,\n        stepTime: .2,\n        textureSize: Vector2(32, 48),\n      ),\n    );\n\n    position = game.size / 2;\n  }\n\n  // Other methods omitted\n}"}
{"prompt": "Write Flutter Flame code to Adding animations and depth¶: Flame provides us with a specialized classes to deal with such images: SpriteAnimation and its component wrapper SpriteAnimationComponent and changing our Player component to be an animation is quite simple, take a look at how the component will look like now:", "completion": "class Player extends SpriteAnimationComponent\n    with HasGameReference<SpaceShooterGame> {\n\n  Player() : super(\n    size: Vector2(100, 150),\n    anchor: Anchor.center,\n  );\n\n  @override\n  Future<void> onLoad() async {\n    await super.onLoad();\n\n    animation = await game.loadSpriteAnimation(\n      'player.png',\n      SpriteAnimationData.sequenced(\n        amount: 4,\n        stepTime: .2,\n        textureSize: Vector2(32, 48),\n      ),\n    );\n\n    position = game.size / 2;\n  }\n\n  // Other methods omitted\n}"}
{"prompt": "Create a Flutter Flame game component that Adding animations and depth¶: Flame provides classes to implement parallax scrolling out of the box, these classes are Parallax and ParallaxComponent, so lets take a look at how we can add that new feature to the game:", "completion": "class SpaceShooterGame extends FlameGame with PanDetector {\n  late Player player;\n\n  @override\n  Future<void> onLoad() async {\n    final parallax = await loadParallaxComponent(\n      [\n        ParallaxImageData('stars_0.png'),\n        ParallaxImageData('stars_1.png'),\n        ParallaxImageData('stars_2.png'),\n      ],\n      baseVelocity: Vector2(0, -5),\n      repeat: ImageRepeat.repeat,\n      velocityMultiplierDelta: Vector2(0, 5),\n    );\n    add(parallax);\n\n    player = Player();\n    add(player);\n  }\n\n  @override\n  void onPanUpdate(DragUpdateInfo info) {\n    player.move(info.delta.global);\n  }\n}"}
{"prompt": "Show me how to implement Adding animations and depth¶: Flame provides classes to implement parallax scrolling out of the box, these classes are Parallax and ParallaxComponent, so lets take a look at how we can add that new feature to the game: using Flutter Flame", "completion": "class SpaceShooterGame extends FlameGame with PanDetector {\n  late Player player;\n\n  @override\n  Future<void> onLoad() async {\n    final parallax = await loadParallaxComponent(\n      [\n        ParallaxImageData('stars_0.png'),\n        ParallaxImageData('stars_1.png'),\n        ParallaxImageData('stars_2.png'),\n      ],\n      baseVelocity: Vector2(0, -5),\n      repeat: ImageRepeat.repeat,\n      velocityMultiplierDelta: Vector2(0, 5),\n    );\n    add(parallax);\n\n    player = Player();\n    add(player);\n  }\n\n  @override\n  void onPanUpdate(DragUpdateInfo info) {\n    player.move(info.delta.global);\n  }\n}"}
{"prompt": "Write Flutter Flame code to Adding animations and depth¶: Flame provides classes to implement parallax scrolling out of the box, these classes are Parallax and ParallaxComponent, so lets take a look at how we can add that new feature to the game:", "completion": "class SpaceShooterGame extends FlameGame with PanDetector {\n  late Player player;\n\n  @override\n  Future<void> onLoad() async {\n    final parallax = await loadParallaxComponent(\n      [\n        ParallaxImageData('stars_0.png'),\n        ParallaxImageData('stars_1.png'),\n        ParallaxImageData('stars_2.png'),\n      ],\n      baseVelocity: Vector2(0, -5),\n      repeat: ImageRepeat.repeat,\n      velocityMultiplierDelta: Vector2(0, 5),\n    );\n    add(parallax);\n\n    player = Player();\n    add(player);\n  }\n\n  @override\n  void onPanUpdate(DragUpdateInfo info) {\n    player.move(info.delta.global);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Adding animations and depth¶: Give it a try by running the game now, you will notice that it looks way more dynamic now, giving a more convincing feeling to the player that the spaceship is really crossing the stars!", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/input.dart';\nimport 'package:flame/parallax.dart';\nimport 'package:flutter/material.dart';\n\nvoid main() {\nrunApp(GameWidget(game: SpaceShooterGame()));\n}\n\nclass SpaceShooterGame extends FlameGame with PanDetector {\nlate Player player;\n\n@override\nFuture<void> onLoad() async {\nfinal parallax = await loadParallaxComponent(\n[\nParallaxImageData('stars_0.png'),\nParallaxImageData('stars_1.png'),\nParallaxImageData('stars_2.png'),\n],\nbaseVelocity: Vector2(0, -5),\nrepeat: ImageRepeat.repeat,\nvelocityMultiplierDelta: Vector2(0, 5),\n);\nadd(parallax);\n\nplayer = Player();\nadd(player);\n}\n\n@override\nvoid onPanUpdate(DragUpdateInfo info) {\nplayer.move(info.delta.global);\n}\n}\n\nclass Player extends SpriteAnimationComponent\nwith HasGameReference<SpaceShooterGame> {\nPlayer()\n: super(\nsize: Vector2(100, 150),\nanchor: Anchor.center,\n);\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nanimation = await game.loadSpriteAnimation(\n'player.png',\nSpriteAnimationData.sequenced(\namount: 4,\nstepTime: 0.2,\ntextureSize: Vector2(32, 48),\n),\n);\n\nposition = game.size / 2;\n}\n\nvoid move(Vector2 delta) {\nposition.add(delta);\n}\n}"}
{"prompt": "Show me how to implement Adding animations and depth¶: Give it a try by running the game now, you will notice that it looks way more dynamic now, giving a more convincing feeling to the player that the spaceship is really crossing the stars! using Flutter Flame", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/input.dart';\nimport 'package:flame/parallax.dart';\nimport 'package:flutter/material.dart';\n\nvoid main() {\nrunApp(GameWidget(game: SpaceShooterGame()));\n}\n\nclass SpaceShooterGame extends FlameGame with PanDetector {\nlate Player player;\n\n@override\nFuture<void> onLoad() async {\nfinal parallax = await loadParallaxComponent(\n[\nParallaxImageData('stars_0.png'),\nParallaxImageData('stars_1.png'),\nParallaxImageData('stars_2.png'),\n],\nbaseVelocity: Vector2(0, -5),\nrepeat: ImageRepeat.repeat,\nvelocityMultiplierDelta: Vector2(0, 5),\n);\nadd(parallax);\n\nplayer = Player();\nadd(player);\n}\n\n@override\nvoid onPanUpdate(DragUpdateInfo info) {\nplayer.move(info.delta.global);\n}\n}\n\nclass Player extends SpriteAnimationComponent\nwith HasGameReference<SpaceShooterGame> {\nPlayer()\n: super(\nsize: Vector2(100, 150),\nanchor: Anchor.center,\n);\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nanimation = await game.loadSpriteAnimation(\n'player.png',\nSpriteAnimationData.sequenced(\namount: 4,\nstepTime: 0.2,\ntextureSize: Vector2(32, 48),\n),\n);\n\nposition = game.size / 2;\n}\n\nvoid move(Vector2 delta) {\nposition.add(delta);\n}\n}"}
{"prompt": "Write Flutter Flame code to Adding animations and depth¶: Give it a try by running the game now, you will notice that it looks way more dynamic now, giving a more convincing feeling to the player that the spaceship is really crossing the stars!", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/input.dart';\nimport 'package:flame/parallax.dart';\nimport 'package:flutter/material.dart';\n\nvoid main() {\nrunApp(GameWidget(game: SpaceShooterGame()));\n}\n\nclass SpaceShooterGame extends FlameGame with PanDetector {\nlate Player player;\n\n@override\nFuture<void> onLoad() async {\nfinal parallax = await loadParallaxComponent(\n[\nParallaxImageData('stars_0.png'),\nParallaxImageData('stars_1.png'),\nParallaxImageData('stars_2.png'),\n],\nbaseVelocity: Vector2(0, -5),\nrepeat: ImageRepeat.repeat,\nvelocityMultiplierDelta: Vector2(0, 5),\n);\nadd(parallax);\n\nplayer = Player();\nadd(player);\n}\n\n@override\nvoid onPanUpdate(DragUpdateInfo info) {\nplayer.move(info.delta.global);\n}\n}\n\nclass Player extends SpriteAnimationComponent\nwith HasGameReference<SpaceShooterGame> {\nPlayer()\n: super(\nsize: Vector2(100, 150),\nanchor: Anchor.center,\n);\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nanimation = await game.loadSpriteAnimation(\n'player.png',\nSpriteAnimationData.sequenced(\namount: 4,\nstepTime: 0.2,\ntextureSize: Vector2(32, 48),\n),\n);\n\nposition = game.size / 2;\n}\n\nvoid move(Vector2 delta) {\nposition.add(delta);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that Receive keyboard events in a game level¶: Minimal example:", "completion": "class MyGame extends FlameGame with KeyboardEvents {\n  // ...\n  @override\n  KeyEventResult onKeyEvent(\n    KeyEvent event,\n    Set<LogicalKeyboardKey> keysPressed,\n  ) {\n    final isKeyDown = event is KeyDownEvent;\n\n    final isSpace = keysPressed.contains(LogicalKeyboardKey.space);\n\n    if (isSpace && isKeyDown) {\n      if (keysPressed.contains(LogicalKeyboardKey.altLeft) ||\n          keysPressed.contains(LogicalKeyboardKey.altRight)) {\n        this.shootHarder();\n      } else {\n        this.shoot();\n      }\n      return KeyEventResult.handled;\n    }\n    return KeyEventResult.ignored;\n  }\n}"}
{"prompt": "Show me how to implement Receive keyboard events in a game level¶: Minimal example: using Flutter Flame", "completion": "class MyGame extends FlameGame with KeyboardEvents {\n  // ...\n  @override\n  KeyEventResult onKeyEvent(\n    KeyEvent event,\n    Set<LogicalKeyboardKey> keysPressed,\n  ) {\n    final isKeyDown = event is KeyDownEvent;\n\n    final isSpace = keysPressed.contains(LogicalKeyboardKey.space);\n\n    if (isSpace && isKeyDown) {\n      if (keysPressed.contains(LogicalKeyboardKey.altLeft) ||\n          keysPressed.contains(LogicalKeyboardKey.altRight)) {\n        this.shootHarder();\n      } else {\n        this.shoot();\n      }\n      return KeyEventResult.handled;\n    }\n    return KeyEventResult.ignored;\n  }\n}"}
{"prompt": "Write Flutter Flame code to Receive keyboard events in a game level¶: Minimal example:", "completion": "class MyGame extends FlameGame with KeyboardEvents {\n  // ...\n  @override\n  KeyEventResult onKeyEvent(\n    KeyEvent event,\n    Set<LogicalKeyboardKey> keysPressed,\n  ) {\n    final isKeyDown = event is KeyDownEvent;\n\n    final isSpace = keysPressed.contains(LogicalKeyboardKey.space);\n\n    if (isSpace && isKeyDown) {\n      if (keysPressed.contains(LogicalKeyboardKey.altLeft) ||\n          keysPressed.contains(LogicalKeyboardKey.altRight)) {\n        this.shootHarder();\n      } else {\n        this.shoot();\n      }\n      return KeyEventResult.handled;\n    }\n    return KeyEventResult.ignored;\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Receive keyboard events in a component level¶: For example, imagine a PositionComponent which has methods to move on the X and Y axis, then the following code could be used to bind those methods to key events:", "completion": "add(\n  KeyboardListenerComponent(\n    keyUp: {\n      LogicalKeyboardKey.keyA: (keysPressed) { ... },\n      LogicalKeyboardKey.keyD: (keysPressed) { ... },\n      LogicalKeyboardKey.keyW: (keysPressed) { ... },\n      LogicalKeyboardKey.keyS: (keysPressed) { ... },\n    },\n    keyDown: {\n      LogicalKeyboardKey.keyA: (keysPressed) { ... },\n      LogicalKeyboardKey.keyD: (keysPressed) { ... },\n      LogicalKeyboardKey.keyW: (keysPressed) { ... },\n      LogicalKeyboardKey.keyS: (keysPressed) { ... },\n    },\n  ),\n);"}
{"prompt": "Show me how to implement Receive keyboard events in a component level¶: For example, imagine a PositionComponent which has methods to move on the X and Y axis, then the following code could be used to bind those methods to key events: using Flutter Flame", "completion": "add(\n  KeyboardListenerComponent(\n    keyUp: {\n      LogicalKeyboardKey.keyA: (keysPressed) { ... },\n      LogicalKeyboardKey.keyD: (keysPressed) { ... },\n      LogicalKeyboardKey.keyW: (keysPressed) { ... },\n      LogicalKeyboardKey.keyS: (keysPressed) { ... },\n    },\n    keyDown: {\n      LogicalKeyboardKey.keyA: (keysPressed) { ... },\n      LogicalKeyboardKey.keyD: (keysPressed) { ... },\n      LogicalKeyboardKey.keyW: (keysPressed) { ... },\n      LogicalKeyboardKey.keyS: (keysPressed) { ... },\n    },\n  ),\n);"}
{"prompt": "Write Flutter Flame code to Receive keyboard events in a component level¶: For example, imagine a PositionComponent which has methods to move on the X and Y axis, then the following code could be used to bind those methods to key events:", "completion": "add(\n  KeyboardListenerComponent(\n    keyUp: {\n      LogicalKeyboardKey.keyA: (keysPressed) { ... },\n      LogicalKeyboardKey.keyD: (keysPressed) { ... },\n      LogicalKeyboardKey.keyW: (keysPressed) { ... },\n      LogicalKeyboardKey.keyS: (keysPressed) { ... },\n    },\n    keyDown: {\n      LogicalKeyboardKey.keyA: (keysPressed) { ... },\n      LogicalKeyboardKey.keyD: (keysPressed) { ... },\n      LogicalKeyboardKey.keyW: (keysPressed) { ... },\n      LogicalKeyboardKey.keyS: (keysPressed) { ... },\n    },\n  ),\n);"}
{"prompt": "Create a Flutter Flame game component that Support:", "completion": "[![Powered by Flame](https://img.shields.io/badge/Powered%20by-%F0%9F%94%A5-orange.svg)](https://flame-engine.org)\n[![Powered by Flame](https://img.shields.io/badge/Powered%20by-%F0%9F%94%A5-orange.svg?style=flat-square)](https://flame-engine.org)\n[![Powered by Flame](https://img.shields.io/badge/Powered%20by-%F0%9F%94%A5-orange.svg?style=for-the-badge)](https://flame-engine.org)"}
{"prompt": "Show me how to implement Support: using Flutter Flame", "completion": "[![Powered by Flame](https://img.shields.io/badge/Powered%20by-%F0%9F%94%A5-orange.svg)](https://flame-engine.org)\n[![Powered by Flame](https://img.shields.io/badge/Powered%20by-%F0%9F%94%A5-orange.svg?style=flat-square)](https://flame-engine.org)\n[![Powered by Flame](https://img.shields.io/badge/Powered%20by-%F0%9F%94%A5-orange.svg?style=for-the-badge)](https://flame-engine.org)"}
{"prompt": "Write Flutter Flame code to Support:", "completion": "[![Powered by Flame](https://img.shields.io/badge/Powered%20by-%F0%9F%94%A5-orange.svg)](https://flame-engine.org)\n[![Powered by Flame](https://img.shields.io/badge/Powered%20by-%F0%9F%94%A5-orange.svg?style=flat-square)](https://flame-engine.org)\n[![Powered by Flame](https://img.shields.io/badge/Powered%20by-%F0%9F%94%A5-orange.svg?style=for-the-badge)](https://flame-engine.org)"}
{"prompt": "Create a Flutter Flame game component that Support:", "completion": "[![Powered by Flame](https://img.shields.io/badge/Powered%20by-%F0%9F%94%A5-orange.svg)](https://flame-engine.org)\n[![Powered by Flame](https://img.shields.io/badge/Powered%20by-%F0%9F%94%A5-orange.svg?style=flat-square)](https://flame-engine.org)\n[![Powered by Flame](https://img.shields.io/badge/Powered%20by-%F0%9F%94%A5-orange.svg?style=for-the-badge)](https://flame-engine.org)"}
{"prompt": "Show me how to implement Support: using Flutter Flame", "completion": "[![Powered by Flame](https://img.shields.io/badge/Powered%20by-%F0%9F%94%A5-orange.svg)](https://flame-engine.org)\n[![Powered by Flame](https://img.shields.io/badge/Powered%20by-%F0%9F%94%A5-orange.svg?style=flat-square)](https://flame-engine.org)\n[![Powered by Flame](https://img.shields.io/badge/Powered%20by-%F0%9F%94%A5-orange.svg?style=for-the-badge)](https://flame-engine.org)"}
{"prompt": "Write Flutter Flame code to Support:", "completion": "[![Powered by Flame](https://img.shields.io/badge/Powered%20by-%F0%9F%94%A5-orange.svg)](https://flame-engine.org)\n[![Powered by Flame](https://img.shields.io/badge/Powered%20by-%F0%9F%94%A5-orange.svg?style=flat-square)](https://flame-engine.org)\n[![Powered by Flame](https://img.shields.io/badge/Powered%20by-%F0%9F%94%A5-orange.svg?style=for-the-badge)](https://flame-engine.org)"}
{"prompt": "Create a Flutter Flame game component that Controlling the player and adding some graphics¶: This detector will make our game class receive pan (or drag) events. To do so, we just need to add the PanDetector mixin to our game class and override its listener methods; in our case, we will use the onPanUpdate method. The updated code will look like the following:", "completion": "import 'package:flame/input.dart';\nimport 'package:flame/events.dart';\n\nclass SpaceShooterGame extends FlameGame with PanDetector {\n  late Player player;\n\n  @override\n  void onLoad() {\n    // omitted\n  }\n\n  @override\n  void onPanUpdate(DragUpdateInfo info) {\n  }\n}"}
{"prompt": "Show me how to implement Controlling the player and adding some graphics¶: This detector will make our game class receive pan (or drag) events. To do so, we just need to add the PanDetector mixin to our game class and override its listener methods; in our case, we will use the onPanUpdate method. The updated code will look like the following: using Flutter Flame", "completion": "import 'package:flame/input.dart';\nimport 'package:flame/events.dart';\n\nclass SpaceShooterGame extends FlameGame with PanDetector {\n  late Player player;\n\n  @override\n  void onLoad() {\n    // omitted\n  }\n\n  @override\n  void onPanUpdate(DragUpdateInfo info) {\n  }\n}"}
{"prompt": "Write Flutter Flame code to Controlling the player and adding some graphics¶: This detector will make our game class receive pan (or drag) events. To do so, we just need to add the PanDetector mixin to our game class and override its listener methods; in our case, we will use the onPanUpdate method. The updated code will look like the following:", "completion": "import 'package:flame/input.dart';\nimport 'package:flame/events.dart';\n\nclass SpaceShooterGame extends FlameGame with PanDetector {\n  late Player player;\n\n  @override\n  void onLoad() {\n    // omitted\n  }\n\n  @override\n  void onPanUpdate(DragUpdateInfo info) {\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Controlling the player and adding some graphics¶: We now need a way to move our player. That can be achieved by simply saving our Player component to a variable inside our game class, adding a method move to our Player, and just connect them:", "completion": "class Player extends PositionComponent { \n  static final _paint = Paint()..color = Colors.white;\n  \n  @override\n  void render(Canvas canvas) {\n    canvas.drawRect(size.toRect(), _paint);\n  }\n\n  void move(Vector2 delta) {\n    position.add(delta);\n  }\n}\n\nclass SpaceShooterGame extends FlameGame with PanDetector {\n  late Player player;\n\n  @override\n  Future<void> onLoad() async {\n    await super.onLoad();\n\n    player = Player()\n      ..position = size / 2\n      ..width = 50\n      ..height = 100\n      ..anchor = Anchor.center;\n\n    add(player);\n  }\n\n  @override\n  void onPanUpdate(DragUpdateInfo info) {\n    player.move(info.delta.global);\n  }\n}"}
{"prompt": "Show me how to implement Controlling the player and adding some graphics¶: We now need a way to move our player. That can be achieved by simply saving our Player component to a variable inside our game class, adding a method move to our Player, and just connect them: using Flutter Flame", "completion": "class Player extends PositionComponent { \n  static final _paint = Paint()..color = Colors.white;\n  \n  @override\n  void render(Canvas canvas) {\n    canvas.drawRect(size.toRect(), _paint);\n  }\n\n  void move(Vector2 delta) {\n    position.add(delta);\n  }\n}\n\nclass SpaceShooterGame extends FlameGame with PanDetector {\n  late Player player;\n\n  @override\n  Future<void> onLoad() async {\n    await super.onLoad();\n\n    player = Player()\n      ..position = size / 2\n      ..width = 50\n      ..height = 100\n      ..anchor = Anchor.center;\n\n    add(player);\n  }\n\n  @override\n  void onPanUpdate(DragUpdateInfo info) {\n    player.move(info.delta.global);\n  }\n}"}
{"prompt": "Write Flutter Flame code to Controlling the player and adding some graphics¶: We now need a way to move our player. That can be achieved by simply saving our Player component to a variable inside our game class, adding a method move to our Player, and just connect them:", "completion": "class Player extends PositionComponent { \n  static final _paint = Paint()..color = Colors.white;\n  \n  @override\n  void render(Canvas canvas) {\n    canvas.drawRect(size.toRect(), _paint);\n  }\n\n  void move(Vector2 delta) {\n    position.add(delta);\n  }\n}\n\nclass SpaceShooterGame extends FlameGame with PanDetector {\n  late Player player;\n\n  @override\n  Future<void> onLoad() async {\n    await super.onLoad();\n\n    player = Player()\n      ..position = size / 2\n      ..width = 50\n      ..height = 100\n      ..anchor = Anchor.center;\n\n    add(player);\n  }\n\n  @override\n  void onPanUpdate(DragUpdateInfo info) {\n    player.move(info.delta.global);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Controlling the player and adding some graphics¶: So let’s refactor our current implementation, first, we can replace our inheritance from PositionComponent to SpriteComponent (which is a component that extends from PositionComponent) and load the sprite:", "completion": "class Player extends SpriteComponent {\n  void move(Vector2 delta) {\n    position.add(delta);\n  }\n}\n\nclass SpaceShooterGame extends FlameGame with PanDetector {\n  late Player player;\n\n  @override\n  Future<void>? onLoad() async {\n    await super.onLoad();\n\n    final playerSprite = await loadSprite('player-sprite.png');\n    player = Player()\n      ..sprite = playerSprite\n      ..x = size.x / 2\n      ..y = size.y / 2\n      ..width = 50\n      ..height = 100\n      ..anchor = Anchor.center;\n\n    add(player);\n  }\n\n  @override\n  void onPanUpdate(DragUpdateInfo info) {\n    player.move(info.delta.global);\n  }\n}"}
{"prompt": "Show me how to implement Controlling the player and adding some graphics¶: So let’s refactor our current implementation, first, we can replace our inheritance from PositionComponent to SpriteComponent (which is a component that extends from PositionComponent) and load the sprite: using Flutter Flame", "completion": "class Player extends SpriteComponent {\n  void move(Vector2 delta) {\n    position.add(delta);\n  }\n}\n\nclass SpaceShooterGame extends FlameGame with PanDetector {\n  late Player player;\n\n  @override\n  Future<void>? onLoad() async {\n    await super.onLoad();\n\n    final playerSprite = await loadSprite('player-sprite.png');\n    player = Player()\n      ..sprite = playerSprite\n      ..x = size.x / 2\n      ..y = size.y / 2\n      ..width = 50\n      ..height = 100\n      ..anchor = Anchor.center;\n\n    add(player);\n  }\n\n  @override\n  void onPanUpdate(DragUpdateInfo info) {\n    player.move(info.delta.global);\n  }\n}"}
{"prompt": "Write Flutter Flame code to Controlling the player and adding some graphics¶: So let’s refactor our current implementation, first, we can replace our inheritance from PositionComponent to SpriteComponent (which is a component that extends from PositionComponent) and load the sprite:", "completion": "class Player extends SpriteComponent {\n  void move(Vector2 delta) {\n    position.add(delta);\n  }\n}\n\nclass SpaceShooterGame extends FlameGame with PanDetector {\n  late Player player;\n\n  @override\n  Future<void>? onLoad() async {\n    await super.onLoad();\n\n    final playerSprite = await loadSprite('player-sprite.png');\n    player = Player()\n      ..sprite = playerSprite\n      ..x = size.x / 2\n      ..y = size.y / 2\n      ..width = 50\n      ..height = 100\n      ..anchor = Anchor.center;\n\n    add(player);\n  }\n\n  @override\n  void onPanUpdate(DragUpdateInfo info) {\n    player.move(info.delta.global);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Controlling the player and adding some graphics¶: That is not a problem! Every time our component needs to access things from its game class, we can mix our component with the HasGameRef mixin; that will add a new variable to our component called gameRef which will point to the game instance where the component is running. Now, let’s refactor our game a little bit:", "completion": "class Player extends SpriteComponent with HasGameRef<SpaceShooterGame> {\n\n  Player() : super(\n    size: Vector2(100, 150),\n    anchor: Anchor.center,\n  );\n\n  @override\n  Future<void> onLoad() async {\n    await super.onLoad();\n\n    sprite = await gameRef.loadSprite('player-sprite.png');\n\n    position = gameRef.size / 2;\n  }\n\n  void move(Vector2 delta) {\n    position.add(delta);\n  }\n}\n\nclass SpaceShooterGame extends FlameGame with PanDetector {\n  late Player player;\n\n  @override\n  Future<void> onLoad() async {\n    await super.onLoad();\n\n    player = Player();\n\n    add(player);\n  }\n\n  @override\n  void onPanUpdate(DragUpdateInfo info) {\n    player.move(info.delta.global);\n  }\n}"}
{"prompt": "Show me how to implement Controlling the player and adding some graphics¶: That is not a problem! Every time our component needs to access things from its game class, we can mix our component with the HasGameRef mixin; that will add a new variable to our component called gameRef which will point to the game instance where the component is running. Now, let’s refactor our game a little bit: using Flutter Flame", "completion": "class Player extends SpriteComponent with HasGameRef<SpaceShooterGame> {\n\n  Player() : super(\n    size: Vector2(100, 150),\n    anchor: Anchor.center,\n  );\n\n  @override\n  Future<void> onLoad() async {\n    await super.onLoad();\n\n    sprite = await gameRef.loadSprite('player-sprite.png');\n\n    position = gameRef.size / 2;\n  }\n\n  void move(Vector2 delta) {\n    position.add(delta);\n  }\n}\n\nclass SpaceShooterGame extends FlameGame with PanDetector {\n  late Player player;\n\n  @override\n  Future<void> onLoad() async {\n    await super.onLoad();\n\n    player = Player();\n\n    add(player);\n  }\n\n  @override\n  void onPanUpdate(DragUpdateInfo info) {\n    player.move(info.delta.global);\n  }\n}"}
{"prompt": "Write Flutter Flame code to Controlling the player and adding some graphics¶: That is not a problem! Every time our component needs to access things from its game class, we can mix our component with the HasGameRef mixin; that will add a new variable to our component called gameRef which will point to the game instance where the component is running. Now, let’s refactor our game a little bit:", "completion": "class Player extends SpriteComponent with HasGameRef<SpaceShooterGame> {\n\n  Player() : super(\n    size: Vector2(100, 150),\n    anchor: Anchor.center,\n  );\n\n  @override\n  Future<void> onLoad() async {\n    await super.onLoad();\n\n    sprite = await gameRef.loadSprite('player-sprite.png');\n\n    position = gameRef.size / 2;\n  }\n\n  void move(Vector2 delta) {\n    position.add(delta);\n  }\n}\n\nclass SpaceShooterGame extends FlameGame with PanDetector {\n  late Player player;\n\n  @override\n  Future<void> onLoad() async {\n    await super.onLoad();\n\n    player = Player();\n\n    add(player);\n  }\n\n  @override\n  void onPanUpdate(DragUpdateInfo info) {\n    player.move(info.delta.global);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Controlling the player and adding some graphics¶: If you run the game now, you will not notice any visual differences, but now we have a more scalable structure for developing our game. And that closes this step!", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/input.dart';\nimport 'package:flutter/material.dart';\n\nvoid main() {\nrunApp(GameWidget(game: SpaceShooterGame()));\n}\n\nclass SpaceShooterGame extends FlameGame with PanDetector {\nlate Player player;\n\n@override\nFuture<void> onLoad() async {\nplayer = Player();\nadd(player);\n}\n\n@override\nvoid onPanUpdate(DragUpdateInfo info) {\nplayer.move(info.delta.global);\n}\n}\n\nclass Player extends SpriteComponent with HasGameReference<SpaceShooterGame> {\nPlayer()\n: super(\nsize: Vector2(100, 150),\nanchor: Anchor.center,\n);\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nsprite = await game.loadSprite('player-sprite.png');\n\nposition = game.size / 2;\nanchor = Anchor.center;\n}\n\nvoid move(Vector2 delta) {\nposition.add(delta);\n}\n}"}
{"prompt": "Show me how to implement Controlling the player and adding some graphics¶: If you run the game now, you will not notice any visual differences, but now we have a more scalable structure for developing our game. And that closes this step! using Flutter Flame", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/input.dart';\nimport 'package:flutter/material.dart';\n\nvoid main() {\nrunApp(GameWidget(game: SpaceShooterGame()));\n}\n\nclass SpaceShooterGame extends FlameGame with PanDetector {\nlate Player player;\n\n@override\nFuture<void> onLoad() async {\nplayer = Player();\nadd(player);\n}\n\n@override\nvoid onPanUpdate(DragUpdateInfo info) {\nplayer.move(info.delta.global);\n}\n}\n\nclass Player extends SpriteComponent with HasGameReference<SpaceShooterGame> {\nPlayer()\n: super(\nsize: Vector2(100, 150),\nanchor: Anchor.center,\n);\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nsprite = await game.loadSprite('player-sprite.png');\n\nposition = game.size / 2;\nanchor = Anchor.center;\n}\n\nvoid move(Vector2 delta) {\nposition.add(delta);\n}\n}"}
{"prompt": "Write Flutter Flame code to Controlling the player and adding some graphics¶: If you run the game now, you will not notice any visual differences, but now we have a more scalable structure for developing our game. And that closes this step!", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/input.dart';\nimport 'package:flutter/material.dart';\n\nvoid main() {\nrunApp(GameWidget(game: SpaceShooterGame()));\n}\n\nclass SpaceShooterGame extends FlameGame with PanDetector {\nlate Player player;\n\n@override\nFuture<void> onLoad() async {\nplayer = Player();\nadd(player);\n}\n\n@override\nvoid onPanUpdate(DragUpdateInfo info) {\nplayer.move(info.delta.global);\n}\n}\n\nclass Player extends SpriteComponent with HasGameReference<SpaceShooterGame> {\nPlayer()\n: super(\nsize: Vector2(100, 150),\nanchor: Anchor.center,\n);\n\n@override\nFuture<void> onLoad() async {\nawait super.onLoad();\n\nsprite = await game.loadSprite('player-sprite.png');\n\nposition = game.size / 2;\nanchor = Anchor.center;\n}\n\nvoid move(Vector2 delta) {\nposition.add(delta);\n}\n}"}
{"prompt": "Create a Flutter Flame game component that Keyboard Controls¶: lib/ember_quest.dart", "completion": "import 'package:flame/events.dart';\n\nclass EmberQuestGame extends FlameGame with HasKeyboardHandlerComponents {"}
{"prompt": "Show me how to implement Keyboard Controls¶: lib/ember_quest.dart using Flutter Flame", "completion": "import 'package:flame/events.dart';\n\nclass EmberQuestGame extends FlameGame with HasKeyboardHandlerComponents {"}
{"prompt": "Write Flutter Flame code to Keyboard Controls¶: lib/ember_quest.dart", "completion": "import 'package:flame/events.dart';\n\nclass EmberQuestGame extends FlameGame with HasKeyboardHandlerComponents {"}
{"prompt": "Create a Flutter Flame game component that Collisions¶: Now add the following onCollision method:", "completion": "@override\nvoid onCollision(Set<Vector2> intersectionPoints, PositionComponent other) {\n  if (other is GroundBlock || other is PlatformBlock) {\n    if (intersectionPoints.length == 2) {\n      // Calculate the collision normal and separation distance.\n      final mid = (intersectionPoints.elementAt(0) +\n        intersectionPoints.elementAt(1)) / 2;\n\n      final collisionNormal = absoluteCenter - mid;\n      final separationDistance = (size.x / 2) - collisionNormal.length;\n      collisionNormal.normalize();\n\n      // If collision normal is almost upwards,\n      // ember must be on ground.\n      if (fromAbove.dot(collisionNormal) > 0.9) {\n        isOnGround = true;\n      }\n\n      // Resolve collision by moving ember along\n      // collision normal by separation distance.\n      position += collisionNormal.scaled(separationDistance);\n      }\n    }\n\n  super.onCollision(intersectionPoints, other);\n}"}
{"prompt": "Show me how to implement Collisions¶: Now add the following onCollision method: using Flutter Flame", "completion": "@override\nvoid onCollision(Set<Vector2> intersectionPoints, PositionComponent other) {\n  if (other is GroundBlock || other is PlatformBlock) {\n    if (intersectionPoints.length == 2) {\n      // Calculate the collision normal and separation distance.\n      final mid = (intersectionPoints.elementAt(0) +\n        intersectionPoints.elementAt(1)) / 2;\n\n      final collisionNormal = absoluteCenter - mid;\n      final separationDistance = (size.x / 2) - collisionNormal.length;\n      collisionNormal.normalize();\n\n      // If collision normal is almost upwards,\n      // ember must be on ground.\n      if (fromAbove.dot(collisionNormal) > 0.9) {\n        isOnGround = true;\n      }\n\n      // Resolve collision by moving ember along\n      // collision normal by separation distance.\n      position += collisionNormal.scaled(separationDistance);\n      }\n    }\n\n  super.onCollision(intersectionPoints, other);\n}"}
{"prompt": "Write Flutter Flame code to Collisions¶: Now add the following onCollision method:", "completion": "@override\nvoid onCollision(Set<Vector2> intersectionPoints, PositionComponent other) {\n  if (other is GroundBlock || other is PlatformBlock) {\n    if (intersectionPoints.length == 2) {\n      // Calculate the collision normal and separation distance.\n      final mid = (intersectionPoints.elementAt(0) +\n        intersectionPoints.elementAt(1)) / 2;\n\n      final collisionNormal = absoluteCenter - mid;\n      final separationDistance = (size.x / 2) - collisionNormal.length;\n      collisionNormal.normalize();\n\n      // If collision normal is almost upwards,\n      // ember must be on ground.\n      if (fromAbove.dot(collisionNormal) > 0.9) {\n        isOnGround = true;\n      }\n\n      // Resolve collision by moving ember along\n      // collision normal by separation distance.\n      position += collisionNormal.scaled(separationDistance);\n      }\n    }\n\n  super.onCollision(intersectionPoints, other);\n}"}
{"prompt": "Create a Flutter Flame game component that Collisions¶: Earlier I mentioned that Ember was in the center of the grass, to solve this and show how collisions and gravity work with Ember, I like to add a little drop-in when you start the game. So in lib/ember_quest.dart in the initializeGame method, change the following:", "completion": "_ember = EmberPlayer(\n  position: Vector2(128, canvasSize.y - 128),\n);"}
{"prompt": "Show me how to implement Collisions¶: Earlier I mentioned that Ember was in the center of the grass, to solve this and show how collisions and gravity work with Ember, I like to add a little drop-in when you start the game. So in lib/ember_quest.dart in the initializeGame method, change the following: using Flutter Flame", "completion": "_ember = EmberPlayer(\n  position: Vector2(128, canvasSize.y - 128),\n);"}
{"prompt": "Write Flutter Flame code to Collisions¶: Earlier I mentioned that Ember was in the center of the grass, to solve this and show how collisions and gravity work with Ember, I like to add a little drop-in when you start the game. So in lib/ember_quest.dart in the initializeGame method, change the following:", "completion": "_ember = EmberPlayer(\n  position: Vector2(128, canvasSize.y - 128),\n);"}
{"prompt": "Create a Flutter Flame game component that Collisions with Objects¶: If the auto-imports did not occur, you will need to add the following imports to your file:", "completion": "import 'package:flame/effects.dart';\n\nimport '../objects/star.dart';\nimport 'water_enemy.dart';"}
{"prompt": "Show me how to implement Collisions with Objects¶: If the auto-imports did not occur, you will need to add the following imports to your file: using Flutter Flame", "completion": "import 'package:flame/effects.dart';\n\nimport '../objects/star.dart';\nimport 'water_enemy.dart';"}
{"prompt": "Write Flutter Flame code to Collisions with Objects¶: If the auto-imports did not occur, you will need to add the following imports to your file:", "completion": "import 'package:flame/effects.dart';\n\nimport '../objects/star.dart';\nimport 'water_enemy.dart';"}
{"prompt": "Create a Flutter Flame game component that Timer¶: Countdown example:", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/input.dart';\nimport 'package:flutter/material.dart';\n\nclass MyGame extends Game {\n  final TextPaint textPaint = TextPaint(\n    style: const TextStyle(color: Colors.white, fontSize: 20),\n  );\n\n  final countdown = Timer(2);\n\n  @override\n  void update(double dt) {\n    countdown.update(dt);\n    if (countdown.finished) {\n      // Prefer the timer callback, but this is better in some cases\n    }\n  }\n\n  @override\n  void render(Canvas canvas) {\n    textPaint.render(\n      canvas,\n      \"Countdown: ${countdown.current.toString()}\",\n      Vector2(10, 100),\n    );\n  }\n}"}
{"prompt": "Show me how to implement Timer¶: Countdown example: using Flutter Flame", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/input.dart';\nimport 'package:flutter/material.dart';\n\nclass MyGame extends Game {\n  final TextPaint textPaint = TextPaint(\n    style: const TextStyle(color: Colors.white, fontSize: 20),\n  );\n\n  final countdown = Timer(2);\n\n  @override\n  void update(double dt) {\n    countdown.update(dt);\n    if (countdown.finished) {\n      // Prefer the timer callback, but this is better in some cases\n    }\n  }\n\n  @override\n  void render(Canvas canvas) {\n    textPaint.render(\n      canvas,\n      \"Countdown: ${countdown.current.toString()}\",\n      Vector2(10, 100),\n    );\n  }\n}"}
{"prompt": "Write Flutter Flame code to Timer¶: Countdown example:", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/input.dart';\nimport 'package:flutter/material.dart';\n\nclass MyGame extends Game {\n  final TextPaint textPaint = TextPaint(\n    style: const TextStyle(color: Colors.white, fontSize: 20),\n  );\n\n  final countdown = Timer(2);\n\n  @override\n  void update(double dt) {\n    countdown.update(dt);\n    if (countdown.finished) {\n      // Prefer the timer callback, but this is better in some cases\n    }\n  }\n\n  @override\n  void render(Canvas canvas) {\n    textPaint.render(\n      canvas,\n      \"Countdown: ${countdown.current.toString()}\",\n      Vector2(10, 100),\n    );\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Timer¶: Interval example:", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/input.dart';\nimport 'package:flutter/material.dart';\n\nclass MyGame extends Game {\n  final TextPaint textPaint = TextPaint(\n    style: const TextStyle(color: Colors.white, fontSize: 20),\n  );\n  Timer interval;\n\n  int elapsedSecs = 0;\n\n  MyGame() {\n    interval = Timer(\n,\n      onTick: () => elapsedSecs += 1,\n      repeat: true,\n    );\n  }\n\n  @override\n  void update(double dt) {\n    interval.update(dt);\n  }\n\n  @override\n  void render(Canvas canvas) {\n    textPaint.render(canvas, \"Elapsed time: $elapsedSecs\", Vector2(10, 150));\n  }\n}"}
{"prompt": "Show me how to implement Timer¶: Interval example: using Flutter Flame", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/input.dart';\nimport 'package:flutter/material.dart';\n\nclass MyGame extends Game {\n  final TextPaint textPaint = TextPaint(\n    style: const TextStyle(color: Colors.white, fontSize: 20),\n  );\n  Timer interval;\n\n  int elapsedSecs = 0;\n\n  MyGame() {\n    interval = Timer(\n,\n      onTick: () => elapsedSecs += 1,\n      repeat: true,\n    );\n  }\n\n  @override\n  void update(double dt) {\n    interval.update(dt);\n  }\n\n  @override\n  void render(Canvas canvas) {\n    textPaint.render(canvas, \"Elapsed time: $elapsedSecs\", Vector2(10, 150));\n  }\n}"}
{"prompt": "Write Flutter Flame code to Timer¶: Interval example:", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/input.dart';\nimport 'package:flutter/material.dart';\n\nclass MyGame extends Game {\n  final TextPaint textPaint = TextPaint(\n    style: const TextStyle(color: Colors.white, fontSize: 20),\n  );\n  Timer interval;\n\n  int elapsedSecs = 0;\n\n  MyGame() {\n    interval = Timer(\n,\n      onTick: () => elapsedSecs += 1,\n      repeat: true,\n    );\n  }\n\n  @override\n  void update(double dt) {\n    interval.update(dt);\n  }\n\n  @override\n  void render(Canvas canvas) {\n    textPaint.render(canvas, \"Elapsed time: $elapsedSecs\", Vector2(10, 150));\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Timer¶: TimerComponent example:", "completion": "import 'package:flame/timer.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/game.dart';\n\nclass MyFlameGame extends FlameGame {\n  MyFlameGame() {\n    add(\n      TimerComponent(\n        period: 10,\n        repeat: true,\n        onTick: () => print('10 seconds elapsed'),\n      )\n    );\n  }\n}"}
{"prompt": "Show me how to implement Timer¶: TimerComponent example: using Flutter Flame", "completion": "import 'package:flame/timer.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/game.dart';\n\nclass MyFlameGame extends FlameGame {\n  MyFlameGame() {\n    add(\n      TimerComponent(\n        period: 10,\n        repeat: true,\n        onTick: () => print('10 seconds elapsed'),\n      )\n    );\n  }\n}"}
{"prompt": "Write Flutter Flame code to Timer¶: TimerComponent example:", "completion": "import 'package:flame/timer.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/game.dart';\n\nclass MyFlameGame extends FlameGame {\n  MyFlameGame() {\n    add(\n      TimerComponent(\n        period: 10,\n        repeat: true,\n        onTick: () => print('10 seconds elapsed'),\n      )\n    );\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Time Scale¶: HasTimeScale cannot control the movement of BodyComponent from flame_forge2d individually. It is only useful if the whole Game or Forge2DWorld is to be time scaled.", "completion": "import 'dart:async';\n\nimport 'package:doc_flame_examples/ember.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/game.dart';\n\nclass TimeScaleGame extends FlameGame with HasTimeScale {\nfinal _timeScales = [0.5, 1.0, 2.0];\nvar _index = 1;\n\n@override\nFuture<void> onLoad() async {\nawait add(\nEmberPlayer(\nposition: size / 2,\nsize: size / 4,\nonTap: (p0) => timeScale = getNextTimeScale(),\n),\n);\nreturn super.onLoad();\n}\n\ndouble getNextTimeScale() {\n++_index;\nif (_index >= _timeScales.length) {\n_index = 0;\n}\nreturn _timeScales[_index];\n}\n}"}
{"prompt": "Show me how to implement Time Scale¶: HasTimeScale cannot control the movement of BodyComponent from flame_forge2d individually. It is only useful if the whole Game or Forge2DWorld is to be time scaled. using Flutter Flame", "completion": "import 'dart:async';\n\nimport 'package:doc_flame_examples/ember.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/game.dart';\n\nclass TimeScaleGame extends FlameGame with HasTimeScale {\nfinal _timeScales = [0.5, 1.0, 2.0];\nvar _index = 1;\n\n@override\nFuture<void> onLoad() async {\nawait add(\nEmberPlayer(\nposition: size / 2,\nsize: size / 4,\nonTap: (p0) => timeScale = getNextTimeScale(),\n),\n);\nreturn super.onLoad();\n}\n\ndouble getNextTimeScale() {\n++_index;\nif (_index >= _timeScales.length) {\n_index = 0;\n}\nreturn _timeScales[_index];\n}\n}"}
{"prompt": "Write Flutter Flame code to Time Scale¶: HasTimeScale cannot control the movement of BodyComponent from flame_forge2d individually. It is only useful if the whole Game or Forge2DWorld is to be time scaled.", "completion": "import 'dart:async';\n\nimport 'package:doc_flame_examples/ember.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/game.dart';\n\nclass TimeScaleGame extends FlameGame with HasTimeScale {\nfinal _timeScales = [0.5, 1.0, 2.0];\nvar _index = 1;\n\n@override\nFuture<void> onLoad() async {\nawait add(\nEmberPlayer(\nposition: size / 2,\nsize: size / 4,\nonTap: (p0) => timeScale = getNextTimeScale(),\n),\n);\nreturn super.onLoad();\n}\n\ndouble getNextTimeScale() {\n++_index;\nif (_index >= _timeScales.length) {\n_index = 0;\n}\nreturn _timeScales[_index];\n}\n}"}
{"prompt": "Create a Flutter Flame game component that Time Scale¶: HasTimeScale cannot control the movement of BodyComponent from flame_forge2d individually. It is only useful if the whole Game or Forge2DWorld is to be time scaled.", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/game.dart';\n\nclass MyFlameGame extends FlameGame with HasTimeScale {\n  void speedUp(){\n    timeScale = 2.0;\n  }\n\n  void slowDown(){\n    timeScale = 1.0;\n  }\n}"}
{"prompt": "Show me how to implement Time Scale¶: HasTimeScale cannot control the movement of BodyComponent from flame_forge2d individually. It is only useful if the whole Game or Forge2DWorld is to be time scaled. using Flutter Flame", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/game.dart';\n\nclass MyFlameGame extends FlameGame with HasTimeScale {\n  void speedUp(){\n    timeScale = 2.0;\n  }\n\n  void slowDown(){\n    timeScale = 1.0;\n  }\n}"}
{"prompt": "Write Flutter Flame code to Time Scale¶: HasTimeScale cannot control the movement of BodyComponent from flame_forge2d individually. It is only useful if the whole Game or Forge2DWorld is to be time scaled.", "completion": "import 'package:flame/components.dart';\nimport 'package:flame/game.dart';\n\nclass MyFlameGame extends FlameGame with HasTimeScale {\n  void speedUp(){\n    timeScale = 2.0;\n  }\n\n  void slowDown(){\n    timeScale = 1.0;\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that RiverpodComponentMixin¶: Components using this mixin must use addToGameWidgetBuild in their onMount method to add listeners (e.g. ref.watch or ref.listen) prior to calling super.onMount, which manages the staged listeners and disposes of them on the user’s behalf inside onRemove.", "completion": "class RiverpodAwareTextComponent extends PositionComponent\n    with RiverpodComponentMixin {\n  late TextComponent textComponent;\n  int currentValue = 0;\n\n  @override\n  void onMount() {\n    addToGameWidgetBuild(() {\n      ref.listen(countingStreamProvider, (p0, p1) {\n        if (p1.hasValue) {\n          currentValue = p1.value!;\n          textComponent.text = '$currentValue';\n        }\n      });\n    });\n    super.onMount();\n    add(textComponent = TextComponent(position: position + Vector2(0, 27)));\n  }\n}"}
{"prompt": "Show me how to implement RiverpodComponentMixin¶: Components using this mixin must use addToGameWidgetBuild in their onMount method to add listeners (e.g. ref.watch or ref.listen) prior to calling super.onMount, which manages the staged listeners and disposes of them on the user’s behalf inside onRemove. using Flutter Flame", "completion": "class RiverpodAwareTextComponent extends PositionComponent\n    with RiverpodComponentMixin {\n  late TextComponent textComponent;\n  int currentValue = 0;\n\n  @override\n  void onMount() {\n    addToGameWidgetBuild(() {\n      ref.listen(countingStreamProvider, (p0, p1) {\n        if (p1.hasValue) {\n          currentValue = p1.value!;\n          textComponent.text = '$currentValue';\n        }\n      });\n    });\n    super.onMount();\n    add(textComponent = TextComponent(position: position + Vector2(0, 27)));\n  }\n}"}
{"prompt": "Write Flutter Flame code to RiverpodComponentMixin¶: Components using this mixin must use addToGameWidgetBuild in their onMount method to add listeners (e.g. ref.watch or ref.listen) prior to calling super.onMount, which manages the staged listeners and disposes of them on the user’s behalf inside onRemove.", "completion": "class RiverpodAwareTextComponent extends PositionComponent\n    with RiverpodComponentMixin {\n  late TextComponent textComponent;\n  int currentValue = 0;\n\n  @override\n  void onMount() {\n    addToGameWidgetBuild(() {\n      ref.listen(countingStreamProvider, (p0, p1) {\n        if (p1.hasValue) {\n          currentValue = p1.value!;\n          textComponent.text = '$currentValue';\n        }\n      });\n    });\n    super.onMount();\n    add(textComponent = TextComponent(position: position + Vector2(0, 27)));\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Usage¶: Example:", "completion": "void main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  await initSpineFlutter();\n  runApp(const GameWidget.controlled(gameFactory: SpineExample.new));\n}\n\nclass FlameSpineExample extends FlameGame with TapDetector {\n late final SpineComponent spineboy;\n\n @override\n Future<void> onLoad() async {\n  await initSpineFlutter();\n  // Load the Spineboy atlas and skeleton data from asset files\n  // and create a SpineComponent from them, scaled down and\n  // centered on the screen\n  spineboy = await SpineComponent.fromAssets(\n   atlasFile: 'assets/spine/spineboy.atlas',\n   skeletonFile: 'assets/spine/spineboy-pro.skel',\n   scale: Vector2(0.4, 0.4),\n   anchor: Anchor.center,\n   position: size / 2,\n  );\n\n  // Set the \"walk\" animation on track 0 in looping mode\n  spineboy.animationState.setAnimationByName(0, 'walk', true);\n  await add(spineboy);\n }\n\n @override\n void onDetach() {\n  // Dispose the native resources that have been loaded for spineboy.\n  spineboy.dispose();\n }\n}"}
{"prompt": "Show me how to implement Usage¶: Example: using Flutter Flame", "completion": "void main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  await initSpineFlutter();\n  runApp(const GameWidget.controlled(gameFactory: SpineExample.new));\n}\n\nclass FlameSpineExample extends FlameGame with TapDetector {\n late final SpineComponent spineboy;\n\n @override\n Future<void> onLoad() async {\n  await initSpineFlutter();\n  // Load the Spineboy atlas and skeleton data from asset files\n  // and create a SpineComponent from them, scaled down and\n  // centered on the screen\n  spineboy = await SpineComponent.fromAssets(\n   atlasFile: 'assets/spine/spineboy.atlas',\n   skeletonFile: 'assets/spine/spineboy-pro.skel',\n   scale: Vector2(0.4, 0.4),\n   anchor: Anchor.center,\n   position: size / 2,\n  );\n\n  // Set the \"walk\" animation on track 0 in looping mode\n  spineboy.animationState.setAnimationByName(0, 'walk', true);\n  await add(spineboy);\n }\n\n @override\n void onDetach() {\n  // Dispose the native resources that have been loaded for spineboy.\n  spineboy.dispose();\n }\n}"}
{"prompt": "Write Flutter Flame code to Usage¶: Example:", "completion": "void main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  await initSpineFlutter();\n  runApp(const GameWidget.controlled(gameFactory: SpineExample.new));\n}\n\nclass FlameSpineExample extends FlameGame with TapDetector {\n late final SpineComponent spineboy;\n\n @override\n Future<void> onLoad() async {\n  await initSpineFlutter();\n  // Load the Spineboy atlas and skeleton data from asset files\n  // and create a SpineComponent from them, scaled down and\n  // centered on the screen\n  spineboy = await SpineComponent.fromAssets(\n   atlasFile: 'assets/spine/spineboy.atlas',\n   skeletonFile: 'assets/spine/spineboy-pro.skel',\n   scale: Vector2(0.4, 0.4),\n   anchor: Anchor.center,\n   position: size / 2,\n  );\n\n  // Set the \"walk\" animation on track 0 in looping mode\n  spineboy.animationState.setAnimationByName(0, 'walk', true);\n  await add(spineboy);\n }\n\n @override\n void onDetach() {\n  // Dispose the native resources that have been loaded for spineboy.\n  spineboy.dispose();\n }\n}"}
{"prompt": "Create a Flutter Flame game component that PositionComponent¶: Creating a positioned entity using OxygenGame:", "completion": "game.createEntity(\n  position: Vector2(100, 100),\n  size: // ...\n);"}
{"prompt": "Show me how to implement PositionComponent¶: Creating a positioned entity using OxygenGame: using Flutter Flame", "completion": "game.createEntity(\n  position: Vector2(100, 100),\n  size: // ...\n);"}
{"prompt": "Write Flutter Flame code to PositionComponent¶: Creating a positioned entity using OxygenGame:", "completion": "game.createEntity(\n  position: Vector2(100, 100),\n  size: // ...\n);"}
{"prompt": "Create a Flutter Flame game component that SizeComponent¶: Creating a sized entity using OxygenGame:", "completion": "game.createEntity(\n  position: // ...\n  size: Vector2(50, 50),\n);"}
{"prompt": "Show me how to implement SizeComponent¶: Creating a sized entity using OxygenGame: using Flutter Flame", "completion": "game.createEntity(\n  position: // ...\n  size: Vector2(50, 50),\n);"}
{"prompt": "Write Flutter Flame code to SizeComponent¶: Creating a sized entity using OxygenGame:", "completion": "game.createEntity(\n  position: // ...\n  size: Vector2(50, 50),\n);"}
{"prompt": "Create a Flutter Flame game component that SpriteComponent¶: Creating an entity with a sprite using OxygenGame:", "completion": "game.createEntity(\n  position: // ...\n  size: // ...\n)..add<SpriteComponent, SpriteInit>(\n  SpriteInit(await game.loadSprite('pizza.png')),\n);"}
{"prompt": "Show me how to implement SpriteComponent¶: Creating an entity with a sprite using OxygenGame: using Flutter Flame", "completion": "game.createEntity(\n  position: // ...\n  size: // ...\n)..add<SpriteComponent, SpriteInit>(\n  SpriteInit(await game.loadSprite('pizza.png')),\n);"}
{"prompt": "Write Flutter Flame code to SpriteComponent¶: Creating an entity with a sprite using OxygenGame:", "completion": "game.createEntity(\n  position: // ...\n  size: // ...\n)..add<SpriteComponent, SpriteInit>(\n  SpriteInit(await game.loadSprite('pizza.png')),\n);"}
{"prompt": "Create a Flutter Flame game component that SpriteComponent¶: Creating an entity with a sprite using World:", "completion": "world.createEntity()\n  ..add<SpriteComponent, SpriteInit>(\n    SpriteInit(await game.loadSprite('pizza.png')),\n  );"}
{"prompt": "Show me how to implement SpriteComponent¶: Creating an entity with a sprite using World: using Flutter Flame", "completion": "world.createEntity()\n  ..add<SpriteComponent, SpriteInit>(\n    SpriteInit(await game.loadSprite('pizza.png')),\n  );"}
{"prompt": "Write Flutter Flame code to SpriteComponent¶: Creating an entity with a sprite using World:", "completion": "world.createEntity()\n  ..add<SpriteComponent, SpriteInit>(\n    SpriteInit(await game.loadSprite('pizza.png')),\n  );"}
{"prompt": "Create a Flutter Flame game component that TextComponent¶: Creating an entity with text using OxygenGame:", "completion": "game.createEntity(\n  position: // ...\n  size: // ...\n)..add<TextComponent, TextInit>(\n  TextInit(\n    'Your text',\n    config: const TextPaintConfig(),\n  ),\n);"}
{"prompt": "Show me how to implement TextComponent¶: Creating an entity with text using OxygenGame: using Flutter Flame", "completion": "game.createEntity(\n  position: // ...\n  size: // ...\n)..add<TextComponent, TextInit>(\n  TextInit(\n    'Your text',\n    config: const TextPaintConfig(),\n  ),\n);"}
{"prompt": "Write Flutter Flame code to TextComponent¶: Creating an entity with text using OxygenGame:", "completion": "game.createEntity(\n  position: // ...\n  size: // ...\n)..add<TextComponent, TextInit>(\n  TextInit(\n    'Your text',\n    config: const TextPaintConfig(),\n  ),\n);"}
{"prompt": "Create a Flutter Flame game component that TextComponent¶: Creating an entity with text using World:", "completion": "world.createEntity()\n  ..add<TextComponent, TextInit>(\n    TextInit(\n      'Your text',\n      config: const TextPaintConfig(),\n    ),\n  );"}
{"prompt": "Show me how to implement TextComponent¶: Creating an entity with text using World: using Flutter Flame", "completion": "world.createEntity()\n  ..add<TextComponent, TextInit>(\n    TextInit(\n      'Your text',\n      config: const TextPaintConfig(),\n    ),\n  );"}
{"prompt": "Write Flutter Flame code to TextComponent¶: Creating an entity with text using World:", "completion": "world.createEntity()\n  ..add<TextComponent, TextInit>(\n    TextInit(\n      'Your text',\n      config: const TextPaintConfig(),\n    ),\n  );"}
{"prompt": "Create a Flutter Flame game component that ParticleComponent¶: Creating an entity with a particle using OxygenGame:", "completion": "game.createEntity(\n  position: // ...\n  size: // ...\n)..add<ParticleComponent, Particle>(\n  // Your Particle.\n);"}
{"prompt": "Show me how to implement ParticleComponent¶: Creating an entity with a particle using OxygenGame: using Flutter Flame", "completion": "game.createEntity(\n  position: // ...\n  size: // ...\n)..add<ParticleComponent, Particle>(\n  // Your Particle.\n);"}
{"prompt": "Write Flutter Flame code to ParticleComponent¶: Creating an entity with a particle using OxygenGame:", "completion": "game.createEntity(\n  position: // ...\n  size: // ...\n)..add<ParticleComponent, Particle>(\n  // Your Particle.\n);"}
{"prompt": "Create a Flutter Flame game component that ParticleComponent¶: Creating an entity with a particle using World:", "completion": "world.createEntity()\n  ..add<ParticleComponent, Particle>(\n    // Your Particle.\n  );"}
{"prompt": "Show me how to implement ParticleComponent¶: Creating an entity with a particle using World: using Flutter Flame", "completion": "world.createEntity()\n  ..add<ParticleComponent, Particle>(\n    // Your Particle.\n  );"}
{"prompt": "Write Flutter Flame code to ParticleComponent¶: Creating an entity with a particle using World:", "completion": "world.createEntity()\n  ..add<ParticleComponent, Particle>(\n    // Your Particle.\n  );"}
{"prompt": "Create a Flutter Flame game component that DynamicLayer¶: Usage example:", "completion": "class GameLayer extends DynamicLayer {\n  final MyGame game;\n\n  GameLayer(this.game);\n\n  @override\n  void drawLayer() {\n    game.playerSprite.render(\n      canvas,\n      position: game.playerPosition,\n    );\n    game.enemySprite.render(\n      canvas,\n      position: game.enemyPosition,\n    );\n  }\n}\n\nclass MyGame extends Game {\n  // Other methods omitted...\n\n  @override\n  void render(Canvas canvas) {\n    gameLayer.render(canvas); // x and y can be provided as optional position arguments\n  }\n}"}
{"prompt": "Show me how to implement DynamicLayer¶: Usage example: using Flutter Flame", "completion": "class GameLayer extends DynamicLayer {\n  final MyGame game;\n\n  GameLayer(this.game);\n\n  @override\n  void drawLayer() {\n    game.playerSprite.render(\n      canvas,\n      position: game.playerPosition,\n    );\n    game.enemySprite.render(\n      canvas,\n      position: game.enemyPosition,\n    );\n  }\n}\n\nclass MyGame extends Game {\n  // Other methods omitted...\n\n  @override\n  void render(Canvas canvas) {\n    gameLayer.render(canvas); // x and y can be provided as optional position arguments\n  }\n}"}
{"prompt": "Write Flutter Flame code to DynamicLayer¶: Usage example:", "completion": "class GameLayer extends DynamicLayer {\n  final MyGame game;\n\n  GameLayer(this.game);\n\n  @override\n  void drawLayer() {\n    game.playerSprite.render(\n      canvas,\n      position: game.playerPosition,\n    );\n    game.enemySprite.render(\n      canvas,\n      position: game.enemyPosition,\n    );\n  }\n}\n\nclass MyGame extends Game {\n  // Other methods omitted...\n\n  @override\n  void render(Canvas canvas) {\n    gameLayer.render(canvas); // x and y can be provided as optional position arguments\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that PreRenderedLayer¶: Usage example:", "completion": "class BackgroundLayer extends PreRenderedLayer {\n  final Sprite sprite;\n\n  BackgroundLayer(this.sprite);\n\n  @override\n  void drawLayer() {\n    sprite.render(\n      canvas,\n      position: Vector2(50, 200),\n    );\n  }\n}\n\nclass MyGame extends Game {\n  // Other methods omitted...\n\n  @override\n  void render(Canvas canvas) {\n    // x and y can be provided as optional position arguments.\n    backgroundLayer.render(canvas);\n  }\n}"}
{"prompt": "Show me how to implement PreRenderedLayer¶: Usage example: using Flutter Flame", "completion": "class BackgroundLayer extends PreRenderedLayer {\n  final Sprite sprite;\n\n  BackgroundLayer(this.sprite);\n\n  @override\n  void drawLayer() {\n    sprite.render(\n      canvas,\n      position: Vector2(50, 200),\n    );\n  }\n}\n\nclass MyGame extends Game {\n  // Other methods omitted...\n\n  @override\n  void render(Canvas canvas) {\n    // x and y can be provided as optional position arguments.\n    backgroundLayer.render(canvas);\n  }\n}"}
{"prompt": "Write Flutter Flame code to PreRenderedLayer¶: Usage example:", "completion": "class BackgroundLayer extends PreRenderedLayer {\n  final Sprite sprite;\n\n  BackgroundLayer(this.sprite);\n\n  @override\n  void drawLayer() {\n    sprite.render(\n      canvas,\n      position: Vector2(50, 200),\n    );\n  }\n}\n\nclass MyGame extends Game {\n  // Other methods omitted...\n\n  @override\n  void render(Canvas canvas) {\n    // x and y can be provided as optional position arguments.\n    backgroundLayer.render(canvas);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Snapshots¶: Snapshots are an alternative to layers. The Snapshot mixin can be applied to any PositionComponent.", "completion": "class SnapshotComponent extends PositionComponent with Snapshot {}\n\nclass MyGame extends FlameGame {\n  late final SnapshotComponent root;\n\n  @override\n  Future<void> onLoad() async {\n    // Add a snapshot component.\n    root = SnapshotComponent();\n    add(root);\n  }\n}"}
{"prompt": "Show me how to implement Snapshots¶: Snapshots are an alternative to layers. The Snapshot mixin can be applied to any PositionComponent. using Flutter Flame", "completion": "class SnapshotComponent extends PositionComponent with Snapshot {}\n\nclass MyGame extends FlameGame {\n  late final SnapshotComponent root;\n\n  @override\n  Future<void> onLoad() async {\n    // Add a snapshot component.\n    root = SnapshotComponent();\n    add(root);\n  }\n}"}
{"prompt": "Write Flutter Flame code to Snapshots¶: Snapshots are an alternative to layers. The Snapshot mixin can be applied to any PositionComponent.", "completion": "class SnapshotComponent extends PositionComponent with Snapshot {}\n\nclass MyGame extends FlameGame {\n  late final SnapshotComponent root;\n\n  @override\n  Future<void> onLoad() async {\n    // Add a snapshot component.\n    root = SnapshotComponent();\n    add(root);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Render as a snapshot¶: Setting renderSnapshot to true (the default) on a snapshot-enabled component behaves similarly to a PreRenderedLayer. The component is rendered only once, cached in memory and then just replicated on the game canvas afterwards. This is useful for caching content that doesn’t change during the game, like a background.", "completion": "class SnapshotComponent extends PositionComponent with Snapshot {}\n\nclass MyGame extends FlameGame {\n  late final SnapshotComponent root;\n  late final SpriteComponent background1;\n  late final SpriteComponent background2;\n\n  @override\n  Future<void> onLoad() async {\n    // Add a snapshot component.\n    root = SnapshotComponent();\n    add(root);\n\n    // Add some children.\n    final background1Sprite = Sprite(await images.load('background1.png'));\n    background1 = SpriteComponent(sprite: background1Sprite);\n    root.add(background1);\n\n    final background2Sprite = Sprite(await images.load('background2.png'));\n    background2 = SpriteComponent(sprite: background2Sprite);\n    root.add(background2);\n\n    // root will now render once (itself and all its children) and then cache\n    // the result. On subsequent render calls, root itself, nor any of its\n    // children, will be rendered. The snapshot will be used instead for\n    // improved performance.\n  }\n}"}
{"prompt": "Show me how to implement Render as a snapshot¶: Setting renderSnapshot to true (the default) on a snapshot-enabled component behaves similarly to a PreRenderedLayer. The component is rendered only once, cached in memory and then just replicated on the game canvas afterwards. This is useful for caching content that doesn’t change during the game, like a background. using Flutter Flame", "completion": "class SnapshotComponent extends PositionComponent with Snapshot {}\n\nclass MyGame extends FlameGame {\n  late final SnapshotComponent root;\n  late final SpriteComponent background1;\n  late final SpriteComponent background2;\n\n  @override\n  Future<void> onLoad() async {\n    // Add a snapshot component.\n    root = SnapshotComponent();\n    add(root);\n\n    // Add some children.\n    final background1Sprite = Sprite(await images.load('background1.png'));\n    background1 = SpriteComponent(sprite: background1Sprite);\n    root.add(background1);\n\n    final background2Sprite = Sprite(await images.load('background2.png'));\n    background2 = SpriteComponent(sprite: background2Sprite);\n    root.add(background2);\n\n    // root will now render once (itself and all its children) and then cache\n    // the result. On subsequent render calls, root itself, nor any of its\n    // children, will be rendered. The snapshot will be used instead for\n    // improved performance.\n  }\n}"}
{"prompt": "Write Flutter Flame code to Render as a snapshot¶: Setting renderSnapshot to true (the default) on a snapshot-enabled component behaves similarly to a PreRenderedLayer. The component is rendered only once, cached in memory and then just replicated on the game canvas afterwards. This is useful for caching content that doesn’t change during the game, like a background.", "completion": "class SnapshotComponent extends PositionComponent with Snapshot {}\n\nclass MyGame extends FlameGame {\n  late final SnapshotComponent root;\n  late final SpriteComponent background1;\n  late final SpriteComponent background2;\n\n  @override\n  Future<void> onLoad() async {\n    // Add a snapshot component.\n    root = SnapshotComponent();\n    add(root);\n\n    // Add some children.\n    final background1Sprite = Sprite(await images.load('background1.png'));\n    background1 = SpriteComponent(sprite: background1Sprite);\n    root.add(background1);\n\n    final background2Sprite = Sprite(await images.load('background2.png'));\n    background2 = SpriteComponent(sprite: background2Sprite);\n    root.add(background2);\n\n    // root will now render once (itself and all its children) and then cache\n    // the result. On subsequent render calls, root itself, nor any of its\n    // children, will be rendered. The snapshot will be used instead for\n    // improved performance.\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Taking a snapshot¶: A snapshot is saved as a Picture, but it can be converted to an Image using snapshotToImage.", "completion": "class SnapshotComponent extends PositionComponent with Snapshot {}\n\nclass MyGame extends FlameGame {\n  late final SnapshotComponent root;\n\n  @override\n  Future<void> onLoad() async {\n    // Add a snapshot component, but don't use its render mode.\n    root = SnapshotComponent()..renderSnapshot = false;\n    add(root);\n\n    // Other code omitted.\n  }\n\n  // Call something like this to take an image snapshot at any time.\n  void takeSnapshot() {\n    root.takeSnapshot();\n    final image = root.snapshotToImage(200, 200);\n  }\n}"}
{"prompt": "Show me how to implement Taking a snapshot¶: A snapshot is saved as a Picture, but it can be converted to an Image using snapshotToImage. using Flutter Flame", "completion": "class SnapshotComponent extends PositionComponent with Snapshot {}\n\nclass MyGame extends FlameGame {\n  late final SnapshotComponent root;\n\n  @override\n  Future<void> onLoad() async {\n    // Add a snapshot component, but don't use its render mode.\n    root = SnapshotComponent()..renderSnapshot = false;\n    add(root);\n\n    // Other code omitted.\n  }\n\n  // Call something like this to take an image snapshot at any time.\n  void takeSnapshot() {\n    root.takeSnapshot();\n    final image = root.snapshotToImage(200, 200);\n  }\n}"}
{"prompt": "Write Flutter Flame code to Taking a snapshot¶: A snapshot is saved as a Picture, but it can be converted to an Image using snapshotToImage.", "completion": "class SnapshotComponent extends PositionComponent with Snapshot {}\n\nclass MyGame extends FlameGame {\n  late final SnapshotComponent root;\n\n  @override\n  Future<void> onLoad() async {\n    // Add a snapshot component, but don't use its render mode.\n    root = SnapshotComponent()..renderSnapshot = false;\n    add(root);\n\n    // Other code omitted.\n  }\n\n  // Call something like this to take an image snapshot at any time.\n  void takeSnapshot() {\n    root.takeSnapshot();\n    final image = root.snapshotToImage(200, 200);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Drag Events¶: In addition, the component must implement the containsLocalPoint() method (already implemented in PositionComponent, so most of the time you don’t need to do anything here) – this method allows Flame to know whether the event occurred within the component or not.", "completion": "class MyComponent extends PositionComponent with DragCallbacks {\n  MyComponent() : super(size: Vector2(180, 120));\n\n   @override\n   void onDragStart(DragStartEvent event) {\n     // Do something in response to a drag event\n   }\n}"}
{"prompt": "Show me how to implement Drag Events¶: In addition, the component must implement the containsLocalPoint() method (already implemented in PositionComponent, so most of the time you don’t need to do anything here) – this method allows Flame to know whether the event occurred within the component or not. using Flutter Flame", "completion": "class MyComponent extends PositionComponent with DragCallbacks {\n  MyComponent() : super(size: Vector2(180, 120));\n\n   @override\n   void onDragStart(DragStartEvent event) {\n     // Do something in response to a drag event\n   }\n}"}
{"prompt": "Write Flutter Flame code to Drag Events¶: In addition, the component must implement the containsLocalPoint() method (already implemented in PositionComponent, so most of the time you don’t need to do anything here) – this method allows Flame to know whether the event occurred within the component or not.", "completion": "class MyComponent extends PositionComponent with DragCallbacks {\n  MyComponent() : super(size: Vector2(180, 120));\n\n   @override\n   void onDragStart(DragStartEvent event) {\n     // Do something in response to a drag event\n   }\n}"}
{"prompt": "Create a Flutter Flame game component that Demo¶: In this example you can use drag gestures to either drag star-like shapes across the screen, or to draw curves inside the magenta rectangle.", "completion": "import 'dart:math';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/geometry.dart';\nimport 'package:flutter/rendering.dart';\n\nclass DragEventsGame extends FlameGame {\n@override\nFuture<void> onLoad() async {\naddAll([\nDragTarget(),\nStar(\nn: 5,\nradius1: 40,\nradius2: 20,\nsharpness: 0.2,\ncolor: const Color(0xffbae5ad),\nposition: Vector2(70, 70),\n),\nStar(\nn: 3,\nradius1: 50,\nradius2: 40,\nsharpness: 0.3,\ncolor: const Color(0xff6ecbe5),\nposition: Vector2(70, 160),\n),\nStar(\nn: 12,\nradius1: 10,\nradius2: 75,\nsharpness: 1.3,\ncolor: const Color(0xfff6df6a),\nposition: Vector2(70, 270),\n),\nStar(\nn: 10,\nradius1: 20,\nradius2: 17,\nsharpness: 0.85,\ncolor: const Color(0xfff82a4b),\nposition: Vector2(110, 110),\n),\n]);\n}\n}\n\n/// This component is the pink-ish rectangle in the center of the game window.\n/// It uses the [DragCallbacks] mixin in order to receive drag events.\nclass DragTarget extends PositionComponent with DragCallbacks {\nDragTarget() : super(anchor: Anchor.center);\n\nfinal _rectPaint = Paint()..color = const Color(0x88AC54BF);\n\n/// We will store all current circles into this map, keyed by the `pointerId`\n/// of the event that created the circle.\nfinal Map<int, Trail> _trails = {};\n\n@override\nvoid onGameResize(Vector2 size) {\nsuper.onGameResize(size);\nthis.size = size - Vector2(100, 75);\nif (this.size.x < 100 || this.size.y < 100) {\nthis.size = size * 0.9;\n}\nposition = size / 2;\n}\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRect(size.toRect(), _rectPaint);\n}\n\n@override\nvoid onDragStart(DragStartEvent event) {\nsuper.onDragStart(event);\nfinal trail = Trail(event.localPosition);\n_trails[event.pointerId] = trail;\nadd(trail);\n}\n\n@override\nvoid onDragUpdate(DragUpdateEvent event) {\n_trails[event.pointerId]!.addPoint(event.localEndPosition);\n}\n\n@override\nvoid onDragEnd(DragEndEvent event) {\nsuper.onDragEnd(event);\n_trails.remove(event.pointerId)!.end();\n}\n\n@override\nvoid onDragCancel(DragCancelEvent event) {\nsuper.onDragCancel(event);\n_trails.remove(event.pointerId)!.cancel();\n}\n}\n\nclass Trail extends Component {\nTrail(Vector2 origin)\n: _paths = [Path()..moveTo(origin.x, origin.y)],\n_opacities = [1],\n_lastPoint = origin.clone(),\n_color =\nHSLColor.fromAHSL(1, random.nextDouble() * 360, 1, 0.8).toColor();\n\nfinal List<Path> _paths;\nfinal List<double> _opacities;\nColor _color;\nlate final _linePaint = Paint()..style = PaintingStyle.stroke;\nlate final _circlePaint = Paint()..color = _color;\nbool _released = false;\ndouble _timer = 0;\nfinal _vanishInterval = 0.03;\nfinal Vector2 _lastPoint;\n\nstatic final random = Random();\nstatic const lineWidth = 10.0;\n\n@override\nvoid render(Canvas canvas) {\nassert(_paths.length == _opacities.length);\nfor (var i = 0; i < _paths.length; i++) {\nfinal path = _paths[i];\nfinal opacity = _opacities[i];\nif (opacity > 0) {\n_linePaint.color = _color.withValues(alpha: opacity);\n_linePaint.strokeWidth = lineWidth * opacity;\ncanvas.drawPath(path, _linePaint);\n}\n}\ncanvas.drawCircle(\n_lastPoint.toOffset(),\n(lineWidth - 2) * _opacities.last + 2,\n_circlePaint,\n);\n}\n\n@override\nvoid update(double dt) {\nassert(_paths.length == _opacities.length);\n_timer += dt;\nwhile (_timer > _vanishInterval) {\n_timer -= _vanishInterval;\nfor (var i = 0; i < _paths.length; i++) {\n_opacities[i] -= 0.01;\nif (_opacities[i] <= 0) {\n_paths[i].reset();\n}\n}\nif (!_released) {\n_paths.add(Path()..moveTo(_lastPoint.x, _lastPoint.y));\n_opacities.add(1);\n}\n}\nif (_opacities.last < 0) {\nremoveFromParent();\n}\n}\n\nvoid addPoint(Vector2 point) {\nif (!point.x.isNaN) {\nfor (final path in _paths) {\npath.lineTo(point.x, point.y);\n}\n_lastPoint.setFrom(point);\n}\n}\n\nvoid end() => _released = true;\n\nvoid cancel() {\n_released = true;\n_color = const Color(0xFFFFFFFF);\n}\n}\n\nclass Star extends PositionComponent with DragCallbacks {\nStar({\nrequired int n,\nrequired double radius1,\nrequired double radius2,\nrequired double sharpness,\nrequired this.color,\nsuper.position,\n}) {\n_path = Path()..moveTo(radius1, 0);\nfor (var i = 0; i < n; i++) {\nfinal p1 = Vector2(radius2, 0)..rotate(tau / n * (i + sharpness));\nfinal p2 = Vector2(radius2, 0)..rotate(tau / n * (i + 1 - sharpness));\nfinal p3 = Vector2(radius1, 0)..rotate(tau / n * (i + 1));\n_path.cubicTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);\n}\n_path.close();\n}\n\nfinal Color color;\nfinal Paint _paint = Paint();\nfinal Paint _borderPaint = Paint()\n..color = const Color(0xFFffffff)\n..style = PaintingStyle.stroke\n..strokeWidth = 3;\nfinal _shadowPaint = Paint()\n..color = const Color(0xFF000000)\n..maskFilter = const MaskFilter.blur(BlurStyle.normal, 4.0);\nlate final Path _path;\n\n@override\nbool containsLocalPoint(Vector2 point) {\nreturn _path.contains(point.toOffset());\n}\n\n@override\nvoid render(Canvas canvas) {\nif (isDragged) {\n_paint.color = color.withValues(alpha: 0.5);\ncanvas.drawPath(_path, _paint);\ncanvas.drawPath(_path, _borderPaint);\n} else {\n_paint.color = color.withValues(alpha: 1);\ncanvas.drawPath(_path, _shadowPaint);\ncanvas.drawPath(_path, _paint);\n}\n}\n\n@override\nvoid onDragStart(DragStartEvent event) {\nsuper.onDragStart(event);\npriority = 10;\n}\n\n@override\nvoid onDragEnd(DragEndEvent event) {\nsuper.onDragEnd(event);\npriority = 0;\n}\n\n@override\nvoid onDragUpdate(DragUpdateEvent event) {\nposition += event.localDelta;\n}\n}"}
{"prompt": "Show me how to implement Demo¶: In this example you can use drag gestures to either drag star-like shapes across the screen, or to draw curves inside the magenta rectangle. using Flutter Flame", "completion": "import 'dart:math';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/geometry.dart';\nimport 'package:flutter/rendering.dart';\n\nclass DragEventsGame extends FlameGame {\n@override\nFuture<void> onLoad() async {\naddAll([\nDragTarget(),\nStar(\nn: 5,\nradius1: 40,\nradius2: 20,\nsharpness: 0.2,\ncolor: const Color(0xffbae5ad),\nposition: Vector2(70, 70),\n),\nStar(\nn: 3,\nradius1: 50,\nradius2: 40,\nsharpness: 0.3,\ncolor: const Color(0xff6ecbe5),\nposition: Vector2(70, 160),\n),\nStar(\nn: 12,\nradius1: 10,\nradius2: 75,\nsharpness: 1.3,\ncolor: const Color(0xfff6df6a),\nposition: Vector2(70, 270),\n),\nStar(\nn: 10,\nradius1: 20,\nradius2: 17,\nsharpness: 0.85,\ncolor: const Color(0xfff82a4b),\nposition: Vector2(110, 110),\n),\n]);\n}\n}\n\n/// This component is the pink-ish rectangle in the center of the game window.\n/// It uses the [DragCallbacks] mixin in order to receive drag events.\nclass DragTarget extends PositionComponent with DragCallbacks {\nDragTarget() : super(anchor: Anchor.center);\n\nfinal _rectPaint = Paint()..color = const Color(0x88AC54BF);\n\n/// We will store all current circles into this map, keyed by the `pointerId`\n/// of the event that created the circle.\nfinal Map<int, Trail> _trails = {};\n\n@override\nvoid onGameResize(Vector2 size) {\nsuper.onGameResize(size);\nthis.size = size - Vector2(100, 75);\nif (this.size.x < 100 || this.size.y < 100) {\nthis.size = size * 0.9;\n}\nposition = size / 2;\n}\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRect(size.toRect(), _rectPaint);\n}\n\n@override\nvoid onDragStart(DragStartEvent event) {\nsuper.onDragStart(event);\nfinal trail = Trail(event.localPosition);\n_trails[event.pointerId] = trail;\nadd(trail);\n}\n\n@override\nvoid onDragUpdate(DragUpdateEvent event) {\n_trails[event.pointerId]!.addPoint(event.localEndPosition);\n}\n\n@override\nvoid onDragEnd(DragEndEvent event) {\nsuper.onDragEnd(event);\n_trails.remove(event.pointerId)!.end();\n}\n\n@override\nvoid onDragCancel(DragCancelEvent event) {\nsuper.onDragCancel(event);\n_trails.remove(event.pointerId)!.cancel();\n}\n}\n\nclass Trail extends Component {\nTrail(Vector2 origin)\n: _paths = [Path()..moveTo(origin.x, origin.y)],\n_opacities = [1],\n_lastPoint = origin.clone(),\n_color =\nHSLColor.fromAHSL(1, random.nextDouble() * 360, 1, 0.8).toColor();\n\nfinal List<Path> _paths;\nfinal List<double> _opacities;\nColor _color;\nlate final _linePaint = Paint()..style = PaintingStyle.stroke;\nlate final _circlePaint = Paint()..color = _color;\nbool _released = false;\ndouble _timer = 0;\nfinal _vanishInterval = 0.03;\nfinal Vector2 _lastPoint;\n\nstatic final random = Random();\nstatic const lineWidth = 10.0;\n\n@override\nvoid render(Canvas canvas) {\nassert(_paths.length == _opacities.length);\nfor (var i = 0; i < _paths.length; i++) {\nfinal path = _paths[i];\nfinal opacity = _opacities[i];\nif (opacity > 0) {\n_linePaint.color = _color.withValues(alpha: opacity);\n_linePaint.strokeWidth = lineWidth * opacity;\ncanvas.drawPath(path, _linePaint);\n}\n}\ncanvas.drawCircle(\n_lastPoint.toOffset(),\n(lineWidth - 2) * _opacities.last + 2,\n_circlePaint,\n);\n}\n\n@override\nvoid update(double dt) {\nassert(_paths.length == _opacities.length);\n_timer += dt;\nwhile (_timer > _vanishInterval) {\n_timer -= _vanishInterval;\nfor (var i = 0; i < _paths.length; i++) {\n_opacities[i] -= 0.01;\nif (_opacities[i] <= 0) {\n_paths[i].reset();\n}\n}\nif (!_released) {\n_paths.add(Path()..moveTo(_lastPoint.x, _lastPoint.y));\n_opacities.add(1);\n}\n}\nif (_opacities.last < 0) {\nremoveFromParent();\n}\n}\n\nvoid addPoint(Vector2 point) {\nif (!point.x.isNaN) {\nfor (final path in _paths) {\npath.lineTo(point.x, point.y);\n}\n_lastPoint.setFrom(point);\n}\n}\n\nvoid end() => _released = true;\n\nvoid cancel() {\n_released = true;\n_color = const Color(0xFFFFFFFF);\n}\n}\n\nclass Star extends PositionComponent with DragCallbacks {\nStar({\nrequired int n,\nrequired double radius1,\nrequired double radius2,\nrequired double sharpness,\nrequired this.color,\nsuper.position,\n}) {\n_path = Path()..moveTo(radius1, 0);\nfor (var i = 0; i < n; i++) {\nfinal p1 = Vector2(radius2, 0)..rotate(tau / n * (i + sharpness));\nfinal p2 = Vector2(radius2, 0)..rotate(tau / n * (i + 1 - sharpness));\nfinal p3 = Vector2(radius1, 0)..rotate(tau / n * (i + 1));\n_path.cubicTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);\n}\n_path.close();\n}\n\nfinal Color color;\nfinal Paint _paint = Paint();\nfinal Paint _borderPaint = Paint()\n..color = const Color(0xFFffffff)\n..style = PaintingStyle.stroke\n..strokeWidth = 3;\nfinal _shadowPaint = Paint()\n..color = const Color(0xFF000000)\n..maskFilter = const MaskFilter.blur(BlurStyle.normal, 4.0);\nlate final Path _path;\n\n@override\nbool containsLocalPoint(Vector2 point) {\nreturn _path.contains(point.toOffset());\n}\n\n@override\nvoid render(Canvas canvas) {\nif (isDragged) {\n_paint.color = color.withValues(alpha: 0.5);\ncanvas.drawPath(_path, _paint);\ncanvas.drawPath(_path, _borderPaint);\n} else {\n_paint.color = color.withValues(alpha: 1);\ncanvas.drawPath(_path, _shadowPaint);\ncanvas.drawPath(_path, _paint);\n}\n}\n\n@override\nvoid onDragStart(DragStartEvent event) {\nsuper.onDragStart(event);\npriority = 10;\n}\n\n@override\nvoid onDragEnd(DragEndEvent event) {\nsuper.onDragEnd(event);\npriority = 0;\n}\n\n@override\nvoid onDragUpdate(DragUpdateEvent event) {\nposition += event.localDelta;\n}\n}"}
{"prompt": "Write Flutter Flame code to Demo¶: In this example you can use drag gestures to either drag star-like shapes across the screen, or to draw curves inside the magenta rectangle.", "completion": "import 'dart:math';\n\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/geometry.dart';\nimport 'package:flutter/rendering.dart';\n\nclass DragEventsGame extends FlameGame {\n@override\nFuture<void> onLoad() async {\naddAll([\nDragTarget(),\nStar(\nn: 5,\nradius1: 40,\nradius2: 20,\nsharpness: 0.2,\ncolor: const Color(0xffbae5ad),\nposition: Vector2(70, 70),\n),\nStar(\nn: 3,\nradius1: 50,\nradius2: 40,\nsharpness: 0.3,\ncolor: const Color(0xff6ecbe5),\nposition: Vector2(70, 160),\n),\nStar(\nn: 12,\nradius1: 10,\nradius2: 75,\nsharpness: 1.3,\ncolor: const Color(0xfff6df6a),\nposition: Vector2(70, 270),\n),\nStar(\nn: 10,\nradius1: 20,\nradius2: 17,\nsharpness: 0.85,\ncolor: const Color(0xfff82a4b),\nposition: Vector2(110, 110),\n),\n]);\n}\n}\n\n/// This component is the pink-ish rectangle in the center of the game window.\n/// It uses the [DragCallbacks] mixin in order to receive drag events.\nclass DragTarget extends PositionComponent with DragCallbacks {\nDragTarget() : super(anchor: Anchor.center);\n\nfinal _rectPaint = Paint()..color = const Color(0x88AC54BF);\n\n/// We will store all current circles into this map, keyed by the `pointerId`\n/// of the event that created the circle.\nfinal Map<int, Trail> _trails = {};\n\n@override\nvoid onGameResize(Vector2 size) {\nsuper.onGameResize(size);\nthis.size = size - Vector2(100, 75);\nif (this.size.x < 100 || this.size.y < 100) {\nthis.size = size * 0.9;\n}\nposition = size / 2;\n}\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawRect(size.toRect(), _rectPaint);\n}\n\n@override\nvoid onDragStart(DragStartEvent event) {\nsuper.onDragStart(event);\nfinal trail = Trail(event.localPosition);\n_trails[event.pointerId] = trail;\nadd(trail);\n}\n\n@override\nvoid onDragUpdate(DragUpdateEvent event) {\n_trails[event.pointerId]!.addPoint(event.localEndPosition);\n}\n\n@override\nvoid onDragEnd(DragEndEvent event) {\nsuper.onDragEnd(event);\n_trails.remove(event.pointerId)!.end();\n}\n\n@override\nvoid onDragCancel(DragCancelEvent event) {\nsuper.onDragCancel(event);\n_trails.remove(event.pointerId)!.cancel();\n}\n}\n\nclass Trail extends Component {\nTrail(Vector2 origin)\n: _paths = [Path()..moveTo(origin.x, origin.y)],\n_opacities = [1],\n_lastPoint = origin.clone(),\n_color =\nHSLColor.fromAHSL(1, random.nextDouble() * 360, 1, 0.8).toColor();\n\nfinal List<Path> _paths;\nfinal List<double> _opacities;\nColor _color;\nlate final _linePaint = Paint()..style = PaintingStyle.stroke;\nlate final _circlePaint = Paint()..color = _color;\nbool _released = false;\ndouble _timer = 0;\nfinal _vanishInterval = 0.03;\nfinal Vector2 _lastPoint;\n\nstatic final random = Random();\nstatic const lineWidth = 10.0;\n\n@override\nvoid render(Canvas canvas) {\nassert(_paths.length == _opacities.length);\nfor (var i = 0; i < _paths.length; i++) {\nfinal path = _paths[i];\nfinal opacity = _opacities[i];\nif (opacity > 0) {\n_linePaint.color = _color.withValues(alpha: opacity);\n_linePaint.strokeWidth = lineWidth * opacity;\ncanvas.drawPath(path, _linePaint);\n}\n}\ncanvas.drawCircle(\n_lastPoint.toOffset(),\n(lineWidth - 2) * _opacities.last + 2,\n_circlePaint,\n);\n}\n\n@override\nvoid update(double dt) {\nassert(_paths.length == _opacities.length);\n_timer += dt;\nwhile (_timer > _vanishInterval) {\n_timer -= _vanishInterval;\nfor (var i = 0; i < _paths.length; i++) {\n_opacities[i] -= 0.01;\nif (_opacities[i] <= 0) {\n_paths[i].reset();\n}\n}\nif (!_released) {\n_paths.add(Path()..moveTo(_lastPoint.x, _lastPoint.y));\n_opacities.add(1);\n}\n}\nif (_opacities.last < 0) {\nremoveFromParent();\n}\n}\n\nvoid addPoint(Vector2 point) {\nif (!point.x.isNaN) {\nfor (final path in _paths) {\npath.lineTo(point.x, point.y);\n}\n_lastPoint.setFrom(point);\n}\n}\n\nvoid end() => _released = true;\n\nvoid cancel() {\n_released = true;\n_color = const Color(0xFFFFFFFF);\n}\n}\n\nclass Star extends PositionComponent with DragCallbacks {\nStar({\nrequired int n,\nrequired double radius1,\nrequired double radius2,\nrequired double sharpness,\nrequired this.color,\nsuper.position,\n}) {\n_path = Path()..moveTo(radius1, 0);\nfor (var i = 0; i < n; i++) {\nfinal p1 = Vector2(radius2, 0)..rotate(tau / n * (i + sharpness));\nfinal p2 = Vector2(radius2, 0)..rotate(tau / n * (i + 1 - sharpness));\nfinal p3 = Vector2(radius1, 0)..rotate(tau / n * (i + 1));\n_path.cubicTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);\n}\n_path.close();\n}\n\nfinal Color color;\nfinal Paint _paint = Paint();\nfinal Paint _borderPaint = Paint()\n..color = const Color(0xFFffffff)\n..style = PaintingStyle.stroke\n..strokeWidth = 3;\nfinal _shadowPaint = Paint()\n..color = const Color(0xFF000000)\n..maskFilter = const MaskFilter.blur(BlurStyle.normal, 4.0);\nlate final Path _path;\n\n@override\nbool containsLocalPoint(Vector2 point) {\nreturn _path.contains(point.toOffset());\n}\n\n@override\nvoid render(Canvas canvas) {\nif (isDragged) {\n_paint.color = color.withValues(alpha: 0.5);\ncanvas.drawPath(_path, _paint);\ncanvas.drawPath(_path, _borderPaint);\n} else {\n_paint.color = color.withValues(alpha: 1);\ncanvas.drawPath(_path, _shadowPaint);\ncanvas.drawPath(_path, _paint);\n}\n}\n\n@override\nvoid onDragStart(DragStartEvent event) {\nsuper.onDragStart(event);\npriority = 10;\n}\n\n@override\nvoid onDragEnd(DragEndEvent event) {\nsuper.onDragEnd(event);\npriority = 0;\n}\n\n@override\nvoid onDragUpdate(DragUpdateEvent event) {\nposition += event.localDelta;\n}\n}"}
{"prompt": "Create a Flutter Flame game component that DragCallbacks¶: If your component is a part of a larger hierarchy, then it will only receive drag events if its ancestors have all implemented the containsLocalPoint correctly.", "completion": "class MyComponent extends PositionComponent with DragCallbacks {\n  MyComponent({super.size});\n\n  final _paint = Paint();\n  bool _isDragged = false;\n\n  @override\n  void onDragStart(DragStartEvent event) => _isDragged = true;\n\n  @override\n  void onDragUpdate(DragUpdateEvent event) => position += event.delta;\n\n  @override\n  void onDragEnd(DragEndEvent event) => _isDragged = false;\n\n  @override\n  void render(Canvas canvas) {\n    _paint.color = _isDragged? Colors.red : Colors.white;\n    canvas.drawRect(size.toRect(), _paint);\n  }\n}"}
{"prompt": "Show me how to implement DragCallbacks¶: If your component is a part of a larger hierarchy, then it will only receive drag events if its ancestors have all implemented the containsLocalPoint correctly. using Flutter Flame", "completion": "class MyComponent extends PositionComponent with DragCallbacks {\n  MyComponent({super.size});\n\n  final _paint = Paint();\n  bool _isDragged = false;\n\n  @override\n  void onDragStart(DragStartEvent event) => _isDragged = true;\n\n  @override\n  void onDragUpdate(DragUpdateEvent event) => position += event.delta;\n\n  @override\n  void onDragEnd(DragEndEvent event) => _isDragged = false;\n\n  @override\n  void render(Canvas canvas) {\n    _paint.color = _isDragged? Colors.red : Colors.white;\n    canvas.drawRect(size.toRect(), _paint);\n  }\n}"}
{"prompt": "Write Flutter Flame code to DragCallbacks¶: If your component is a part of a larger hierarchy, then it will only receive drag events if its ancestors have all implemented the containsLocalPoint correctly.", "completion": "class MyComponent extends PositionComponent with DragCallbacks {\n  MyComponent({super.size});\n\n  final _paint = Paint();\n  bool _isDragged = false;\n\n  @override\n  void onDragStart(DragStartEvent event) => _isDragged = true;\n\n  @override\n  void onDragUpdate(DragUpdateEvent event) => position += event.delta;\n\n  @override\n  void onDragEnd(DragEndEvent event) => _isDragged = false;\n\n  @override\n  void render(Canvas canvas) {\n    _paint.color = _isDragged? Colors.red : Colors.white;\n    canvas.drawRect(size.toRect(), _paint);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that HasCollisionDetection¶: Example:", "completion": "class MyGame extends FlameGame with HasCollisionDetection {\n  // ...\n}"}
{"prompt": "Show me how to implement HasCollisionDetection¶: Example: using Flutter Flame", "completion": "class MyGame extends FlameGame with HasCollisionDetection {\n  // ...\n}"}
{"prompt": "Write Flutter Flame code to HasCollisionDetection¶: Example:", "completion": "class MyGame extends FlameGame with HasCollisionDetection {\n  // ...\n}"}
{"prompt": "Create a Flutter Flame game component that CollisionCallbacks¶: To react to a collision you should add the CollisionCallbacks mixin to your component. Example:", "completion": "import 'package:doc_flame_examples/ember.dart';\nimport 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\nimport 'package:flutter/material.dart' hide Image;\n\nclass CollisionDetectionGame extends FlameGame with HasCollisionDetection {\n@override\nFuture<void> onLoad() async {\nfinal emberPlayer = EmberPlayer(\nposition: Vector2(10, (size.y / 2) - 20),\nsize: Vector2.all(40),\nonTap: (emberPlayer) {\nemberPlayer.add(\nMoveEffect.to(\nVector2(size.x - 40, (size.y / 2) - 20),\nEffectController(\nduration: 5,\nreverseDuration: 5,\nrepeatCount: 1,\ncurve: Curves.easeOut,\n),\n),\n);\n},\n);\nadd(emberPlayer);\nadd(RectangleCollidable(canvasSize / 2));\n}\n}\n\nclass RectangleCollidable extends PositionComponent with CollisionCallbacks {\nfinal _collisionStartColor = Colors.amber;\nfinal _defaultColor = Colors.cyan;\nlate ShapeHitbox hitbox;\n\nRectangleCollidable(Vector2 position)\n: super(\nposition: position,\nsize: Vector2.all(50),\nanchor: Anchor.center,\n);\n\n@override\nFuture<void> onLoad() async {\nfinal defaultPaint = Paint()\n..color = _defaultColor\n..style = PaintingStyle.stroke;\nhitbox = RectangleHitbox()\n..paint = defaultPaint\n..renderShape = true;\nadd(hitbox);\n}\n\n@override\nvoid onCollisionStart(\nSet<Vector2> intersectionPoints,\nPositionComponent other,\n) {\nsuper.onCollisionStart(intersectionPoints, other);\nhitbox.paint.color = _collisionStartColor;\n}\n\n@override\nvoid onCollisionEnd(PositionComponent other) {\nsuper.onCollisionEnd(other);\nif (!isColliding) {\nhitbox.paint.color = _defaultColor;\n}\n}\n}"}
{"prompt": "Show me how to implement CollisionCallbacks¶: To react to a collision you should add the CollisionCallbacks mixin to your component. Example: using Flutter Flame", "completion": "import 'package:doc_flame_examples/ember.dart';\nimport 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\nimport 'package:flutter/material.dart' hide Image;\n\nclass CollisionDetectionGame extends FlameGame with HasCollisionDetection {\n@override\nFuture<void> onLoad() async {\nfinal emberPlayer = EmberPlayer(\nposition: Vector2(10, (size.y / 2) - 20),\nsize: Vector2.all(40),\nonTap: (emberPlayer) {\nemberPlayer.add(\nMoveEffect.to(\nVector2(size.x - 40, (size.y / 2) - 20),\nEffectController(\nduration: 5,\nreverseDuration: 5,\nrepeatCount: 1,\ncurve: Curves.easeOut,\n),\n),\n);\n},\n);\nadd(emberPlayer);\nadd(RectangleCollidable(canvasSize / 2));\n}\n}\n\nclass RectangleCollidable extends PositionComponent with CollisionCallbacks {\nfinal _collisionStartColor = Colors.amber;\nfinal _defaultColor = Colors.cyan;\nlate ShapeHitbox hitbox;\n\nRectangleCollidable(Vector2 position)\n: super(\nposition: position,\nsize: Vector2.all(50),\nanchor: Anchor.center,\n);\n\n@override\nFuture<void> onLoad() async {\nfinal defaultPaint = Paint()\n..color = _defaultColor\n..style = PaintingStyle.stroke;\nhitbox = RectangleHitbox()\n..paint = defaultPaint\n..renderShape = true;\nadd(hitbox);\n}\n\n@override\nvoid onCollisionStart(\nSet<Vector2> intersectionPoints,\nPositionComponent other,\n) {\nsuper.onCollisionStart(intersectionPoints, other);\nhitbox.paint.color = _collisionStartColor;\n}\n\n@override\nvoid onCollisionEnd(PositionComponent other) {\nsuper.onCollisionEnd(other);\nif (!isColliding) {\nhitbox.paint.color = _defaultColor;\n}\n}\n}"}
{"prompt": "Write Flutter Flame code to CollisionCallbacks¶: To react to a collision you should add the CollisionCallbacks mixin to your component. Example:", "completion": "import 'package:doc_flame_examples/ember.dart';\nimport 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/effects.dart';\nimport 'package:flame/game.dart';\nimport 'package:flutter/material.dart' hide Image;\n\nclass CollisionDetectionGame extends FlameGame with HasCollisionDetection {\n@override\nFuture<void> onLoad() async {\nfinal emberPlayer = EmberPlayer(\nposition: Vector2(10, (size.y / 2) - 20),\nsize: Vector2.all(40),\nonTap: (emberPlayer) {\nemberPlayer.add(\nMoveEffect.to(\nVector2(size.x - 40, (size.y / 2) - 20),\nEffectController(\nduration: 5,\nreverseDuration: 5,\nrepeatCount: 1,\ncurve: Curves.easeOut,\n),\n),\n);\n},\n);\nadd(emberPlayer);\nadd(RectangleCollidable(canvasSize / 2));\n}\n}\n\nclass RectangleCollidable extends PositionComponent with CollisionCallbacks {\nfinal _collisionStartColor = Colors.amber;\nfinal _defaultColor = Colors.cyan;\nlate ShapeHitbox hitbox;\n\nRectangleCollidable(Vector2 position)\n: super(\nposition: position,\nsize: Vector2.all(50),\nanchor: Anchor.center,\n);\n\n@override\nFuture<void> onLoad() async {\nfinal defaultPaint = Paint()\n..color = _defaultColor\n..style = PaintingStyle.stroke;\nhitbox = RectangleHitbox()\n..paint = defaultPaint\n..renderShape = true;\nadd(hitbox);\n}\n\n@override\nvoid onCollisionStart(\nSet<Vector2> intersectionPoints,\nPositionComponent other,\n) {\nsuper.onCollisionStart(intersectionPoints, other);\nhitbox.paint.color = _collisionStartColor;\n}\n\n@override\nvoid onCollisionEnd(PositionComponent other) {\nsuper.onCollisionEnd(other);\nif (!isColliding) {\nhitbox.paint.color = _defaultColor;\n}\n}\n}"}
{"prompt": "Create a Flutter Flame game component that CollisionCallbacks¶: To react to a collision you should add the CollisionCallbacks mixin to your component. Example:", "completion": "class MyCollidable extends PositionComponent with CollisionCallbacks {\n  @override\n  void onCollision(Set<Vector2> points, PositionComponent other) {\n    if (other is ScreenHitbox) {\n      //...\n    } else if (other is YourOtherComponent) {\n      //...\n    }\n  }\n\n  @override\n  void onCollisionEnd(PositionComponent other) {\n    if (other is ScreenHitbox) {\n      //...\n    } else if (other is YourOtherComponent) {\n      //...\n    }\n  }\n}"}
{"prompt": "Show me how to implement CollisionCallbacks¶: To react to a collision you should add the CollisionCallbacks mixin to your component. Example: using Flutter Flame", "completion": "class MyCollidable extends PositionComponent with CollisionCallbacks {\n  @override\n  void onCollision(Set<Vector2> points, PositionComponent other) {\n    if (other is ScreenHitbox) {\n      //...\n    } else if (other is YourOtherComponent) {\n      //...\n    }\n  }\n\n  @override\n  void onCollisionEnd(PositionComponent other) {\n    if (other is ScreenHitbox) {\n      //...\n    } else if (other is YourOtherComponent) {\n      //...\n    }\n  }\n}"}
{"prompt": "Write Flutter Flame code to CollisionCallbacks¶: To react to a collision you should add the CollisionCallbacks mixin to your component. Example:", "completion": "class MyCollidable extends PositionComponent with CollisionCallbacks {\n  @override\n  void onCollision(Set<Vector2> points, PositionComponent other) {\n    if (other is ScreenHitbox) {\n      //...\n    } else if (other is YourOtherComponent) {\n      //...\n    }\n  }\n\n  @override\n  void onCollisionEnd(PositionComponent other) {\n    if (other is ScreenHitbox) {\n      //...\n    } else if (other is YourOtherComponent) {\n      //...\n    }\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Collision order¶: An example of how this might be used is to add a local variable in your PositionComponent to save the other components with which it’s colliding: List<PositionComponent> collisionComponents = [];. The onCollision callback is then used to save all the other PositionComponents to this list:", "completion": "@override\nvoid onCollision(Set<Vector2> intersectionPoints, PositionComponent other) {\n  collisionComponents.add(other);\n  super.onCollision(intersectionPoints, other);\n}"}
{"prompt": "Show me how to implement Collision order¶: An example of how this might be used is to add a local variable in your PositionComponent to save the other components with which it’s colliding: List<PositionComponent> collisionComponents = [];. The onCollision callback is then used to save all the other PositionComponents to this list: using Flutter Flame", "completion": "@override\nvoid onCollision(Set<Vector2> intersectionPoints, PositionComponent other) {\n  collisionComponents.add(other);\n  super.onCollision(intersectionPoints, other);\n}"}
{"prompt": "Write Flutter Flame code to Collision order¶: An example of how this might be used is to add a local variable in your PositionComponent to save the other components with which it’s colliding: List<PositionComponent> collisionComponents = [];. The onCollision callback is then used to save all the other PositionComponents to this list:", "completion": "@override\nvoid onCollision(Set<Vector2> intersectionPoints, PositionComponent other) {\n  collisionComponents.add(other);\n  super.onCollision(intersectionPoints, other);\n}"}
{"prompt": "Create a Flutter Flame game component that ShapeHitbox¶: The ShapeHitboxs are normal components, so you add them to the component that you want to add hitboxes to just like any other component:", "completion": "class MyComponent extends PositionComponent {\n  @override\n  void onLoad() {\n    add(RectangleHitbox());\n  }\n}"}
{"prompt": "Show me how to implement ShapeHitbox¶: The ShapeHitboxs are normal components, so you add them to the component that you want to add hitboxes to just like any other component: using Flutter Flame", "completion": "class MyComponent extends PositionComponent {\n  @override\n  void onLoad() {\n    add(RectangleHitbox());\n  }\n}"}
{"prompt": "Write Flutter Flame code to ShapeHitbox¶: The ShapeHitboxs are normal components, so you add them to the component that you want to add hitboxes to just like any other component:", "completion": "class MyComponent extends PositionComponent {\n  @override\n  void onLoad() {\n    add(RectangleHitbox());\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that ShapeHitbox¶: In some specific cases you might want to handle collisions only between hitboxes, without propagating onCollision* events to the hitbox’s parent component. For example, a vehicle could have a body hitbox to control collisions and side hitboxes to check the possibility to turn left or right. So, colliding with a body hitbox means colliding with the component itself, whereas colliding with a side hitbox does not mean a real collision and should not be propagated to hitbox’s parent. For this case you can set triggersParentCollision variable to false:", "completion": "class MyComponent extends PositionComponent {\n\n  late final MySpecialHitbox utilityHitbox;\n\n  @override\n  void onLoad() {\n    utilityHitbox = MySpecialHitbox();\n    add(utilityHitbox);\n  }\n\n  void update(double dt) {\n    if (utilityHitbox.isColliding) {\n      // do some specific things if hitbox is colliding\n    }\n  }\n// component's onCollision* functions, ignoring MySpecialHitbox collisions.\n}\n\nclass MySpecialHitbox extends RectangleHitbox {\n  MySpecialHitbox() {\n    triggersParentCollision = false;\n  }\n\n// hitbox specific onCollision* functions\n\n}"}
{"prompt": "Show me how to implement ShapeHitbox¶: In some specific cases you might want to handle collisions only between hitboxes, without propagating onCollision* events to the hitbox’s parent component. For example, a vehicle could have a body hitbox to control collisions and side hitboxes to check the possibility to turn left or right. So, colliding with a body hitbox means colliding with the component itself, whereas colliding with a side hitbox does not mean a real collision and should not be propagated to hitbox’s parent. For this case you can set triggersParentCollision variable to false: using Flutter Flame", "completion": "class MyComponent extends PositionComponent {\n\n  late final MySpecialHitbox utilityHitbox;\n\n  @override\n  void onLoad() {\n    utilityHitbox = MySpecialHitbox();\n    add(utilityHitbox);\n  }\n\n  void update(double dt) {\n    if (utilityHitbox.isColliding) {\n      // do some specific things if hitbox is colliding\n    }\n  }\n// component's onCollision* functions, ignoring MySpecialHitbox collisions.\n}\n\nclass MySpecialHitbox extends RectangleHitbox {\n  MySpecialHitbox() {\n    triggersParentCollision = false;\n  }\n\n// hitbox specific onCollision* functions\n\n}"}
{"prompt": "Write Flutter Flame code to ShapeHitbox¶: In some specific cases you might want to handle collisions only between hitboxes, without propagating onCollision* events to the hitbox’s parent component. For example, a vehicle could have a body hitbox to control collisions and side hitboxes to check the possibility to turn left or right. So, colliding with a body hitbox means colliding with the component itself, whereas colliding with a side hitbox does not mean a real collision and should not be propagated to hitbox’s parent. For this case you can set triggersParentCollision variable to false:", "completion": "class MyComponent extends PositionComponent {\n\n  late final MySpecialHitbox utilityHitbox;\n\n  @override\n  void onLoad() {\n    utilityHitbox = MySpecialHitbox();\n    add(utilityHitbox);\n  }\n\n  void update(double dt) {\n    if (utilityHitbox.isColliding) {\n      // do some specific things if hitbox is colliding\n    }\n  }\n// component's onCollision* functions, ignoring MySpecialHitbox collisions.\n}\n\nclass MySpecialHitbox extends RectangleHitbox {\n  MySpecialHitbox() {\n    triggersParentCollision = false;\n  }\n\n// hitbox specific onCollision* functions\n\n}"}
{"prompt": "Create a Flutter Flame game component that Broad phase¶: For example, if you have implemented a broadphase built on a magic algorithm instead of the standard sweep and prune, then you would do the following:", "completion": "class MyGame extends FlameGame with HasCollisionDetection {\n  MyGame() : super() {\n    collisionDetection =\n        StandardCollisionDetection(broadphase: MagicAlgorithmBroadphase());\n  }\n}"}
{"prompt": "Show me how to implement Broad phase¶: For example, if you have implemented a broadphase built on a magic algorithm instead of the standard sweep and prune, then you would do the following: using Flutter Flame", "completion": "class MyGame extends FlameGame with HasCollisionDetection {\n  MyGame() : super() {\n    collisionDetection =\n        StandardCollisionDetection(broadphase: MagicAlgorithmBroadphase());\n  }\n}"}
{"prompt": "Write Flutter Flame code to Broad phase¶: For example, if you have implemented a broadphase built on a magic algorithm instead of the standard sweep and prune, then you would do the following:", "completion": "class MyGame extends FlameGame with HasCollisionDetection {\n  MyGame() : super() {\n    collisionDetection =\n        StandardCollisionDetection(broadphase: MagicAlgorithmBroadphase());\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Quad Tree broad phase¶: To do this, add the HasQuadTreeCollisionDetection mixin to your game instead of HasCollisionDetection and call the initializeCollisionDetection function on game load:", "completion": "class MyGame extends FlameGame with HasQuadTreeCollisionDetection {\n  @override\n  void onLoad() {\n    initializeCollisionDetection(\n      mapDimensions: const Rect.fromLTWH(0, 0, mapWidth, mapHeight),\n      minimumDistance: 10,\n    );\n  }\n}"}
{"prompt": "Show me how to implement Quad Tree broad phase¶: To do this, add the HasQuadTreeCollisionDetection mixin to your game instead of HasCollisionDetection and call the initializeCollisionDetection function on game load: using Flutter Flame", "completion": "class MyGame extends FlameGame with HasQuadTreeCollisionDetection {\n  @override\n  void onLoad() {\n    initializeCollisionDetection(\n      mapDimensions: const Rect.fromLTWH(0, 0, mapWidth, mapHeight),\n      minimumDistance: 10,\n    );\n  }\n}"}
{"prompt": "Write Flutter Flame code to Quad Tree broad phase¶: To do this, add the HasQuadTreeCollisionDetection mixin to your game instead of HasCollisionDetection and call the initializeCollisionDetection function on game load:", "completion": "class MyGame extends FlameGame with HasQuadTreeCollisionDetection {\n  @override\n  void onLoad() {\n    initializeCollisionDetection(\n      mapDimensions: const Rect.fromLTWH(0, 0, mapWidth, mapHeight),\n      minimumDistance: 10,\n    );\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Quad Tree broad phase¶: If you use the quad tree system, you can make it even more efficient by implementing the onComponentTypeCheck function of the CollisionCallbacks mixin in your components. It is useful if you need to prevent collisions of items of different types. The result of the calculation is cached so you should not check any dynamic parameters here, the function is intended to be used as a pure type checker:", "completion": "class Bullet extends PositionComponent with CollisionCallbacks {\n\n  @override\n  bool onComponentTypeCheck(PositionComponent other) {\n    if (other is Player || other is Water) {\n      // do NOT collide with Player or Water\n      return false;\n    }\n    // Just return true if you're not interested in the parent's type check result.\n    // Or call super and you will be able to override the result with the parent's\n    // result.\n    return super.onComponentTypeCheck(other);\n  }\n\n  @override\n  void onCollisionStart(\n    Set<Vector2> intersectionPoints,\n    PositionComponent other,\n  ) {\n    // Removes the component when it comes in contact with a Brick.\n    // Neither Player nor Water would be passed to this function\n    // because these classes are filtered out by [onComponentTypeCheck]\n    // in an earlier stage.\n    if (other is Brick) {\n      removeFromParent();\n    }\n    super.onCollisionStart(intersectionPoints, other);\n  }\n}"}
{"prompt": "Show me how to implement Quad Tree broad phase¶: If you use the quad tree system, you can make it even more efficient by implementing the onComponentTypeCheck function of the CollisionCallbacks mixin in your components. It is useful if you need to prevent collisions of items of different types. The result of the calculation is cached so you should not check any dynamic parameters here, the function is intended to be used as a pure type checker: using Flutter Flame", "completion": "class Bullet extends PositionComponent with CollisionCallbacks {\n\n  @override\n  bool onComponentTypeCheck(PositionComponent other) {\n    if (other is Player || other is Water) {\n      // do NOT collide with Player or Water\n      return false;\n    }\n    // Just return true if you're not interested in the parent's type check result.\n    // Or call super and you will be able to override the result with the parent's\n    // result.\n    return super.onComponentTypeCheck(other);\n  }\n\n  @override\n  void onCollisionStart(\n    Set<Vector2> intersectionPoints,\n    PositionComponent other,\n  ) {\n    // Removes the component when it comes in contact with a Brick.\n    // Neither Player nor Water would be passed to this function\n    // because these classes are filtered out by [onComponentTypeCheck]\n    // in an earlier stage.\n    if (other is Brick) {\n      removeFromParent();\n    }\n    super.onCollisionStart(intersectionPoints, other);\n  }\n}"}
{"prompt": "Write Flutter Flame code to Quad Tree broad phase¶: If you use the quad tree system, you can make it even more efficient by implementing the onComponentTypeCheck function of the CollisionCallbacks mixin in your components. It is useful if you need to prevent collisions of items of different types. The result of the calculation is cached so you should not check any dynamic parameters here, the function is intended to be used as a pure type checker:", "completion": "class Bullet extends PositionComponent with CollisionCallbacks {\n\n  @override\n  bool onComponentTypeCheck(PositionComponent other) {\n    if (other is Player || other is Water) {\n      // do NOT collide with Player or Water\n      return false;\n    }\n    // Just return true if you're not interested in the parent's type check result.\n    // Or call super and you will be able to override the result with the parent's\n    // result.\n    return super.onComponentTypeCheck(other);\n  }\n\n  @override\n  void onCollisionStart(\n    Set<Vector2> intersectionPoints,\n    PositionComponent other,\n  ) {\n    // Removes the component when it comes in contact with a Brick.\n    // Neither Player nor Water would be passed to this function\n    // because these classes are filtered out by [onComponentTypeCheck]\n    // in an earlier stage.\n    if (other is Brick) {\n      removeFromParent();\n    }\n    super.onCollisionStart(intersectionPoints, other);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Quad Tree broad phase¶: After intensive gameplay a map could become over-clusterized with a lot of empty quadrants. Run QuadTree.optimize() to perform a cleanup of empty quadrants:", "completion": "class QuadTreeExample extends FlameGame\n        with HasQuadTreeCollisionDetection {\n\n  /// A function called when intensive gameplay session is over\n  /// It also might be scheduled, but no need to run it on every update.\n  /// Use right interval depending on your game circumstances\n  onGameIdle() {\n    (collisionDetection as QuadTreeCollisionDetection)\n            .quadBroadphase\n            .tree\n            .optimize();\n  }\n}"}
{"prompt": "Show me how to implement Quad Tree broad phase¶: After intensive gameplay a map could become over-clusterized with a lot of empty quadrants. Run QuadTree.optimize() to perform a cleanup of empty quadrants: using Flutter Flame", "completion": "class QuadTreeExample extends FlameGame\n        with HasQuadTreeCollisionDetection {\n\n  /// A function called when intensive gameplay session is over\n  /// It also might be scheduled, but no need to run it on every update.\n  /// Use right interval depending on your game circumstances\n  onGameIdle() {\n    (collisionDetection as QuadTreeCollisionDetection)\n            .quadBroadphase\n            .tree\n            .optimize();\n  }\n}"}
{"prompt": "Write Flutter Flame code to Quad Tree broad phase¶: After intensive gameplay a map could become over-clusterized with a lot of empty quadrants. Run QuadTree.optimize() to perform a cleanup of empty quadrants:", "completion": "class QuadTreeExample extends FlameGame\n        with HasQuadTreeCollisionDetection {\n\n  /// A function called when intensive gameplay session is over\n  /// It also might be scheduled, but no need to run it on every update.\n  /// Use right interval depending on your game circumstances\n  onGameIdle() {\n    (collisionDetection as QuadTreeCollisionDetection)\n            .quadBroadphase\n            .tree\n            .optimize();\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Ray casting¶: Example:", "completion": "import 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/geometry.dart';\nimport 'package:flame/palette.dart';\nimport 'package:flutter/material.dart';\n\nclass RayCastExample extends FlameGame with HasCollisionDetection {\nfinal origin = Vector2(20, 20);\n\nfinal direction = Vector2(1, 0);\n\nfinal velocity = 60;\ndouble get resetPosition => -canvasSize.y;\n\nPaint paint = Paint()..color = Colors.red.withValues(alpha: 0.6);\n\nRaycastResult<ShapeHitbox>? result;\n\n@override\nFuture<void> onLoad() async {\nfinal paint = BasicPalette.gray.paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 2.0;\n\nadd(ScreenHitbox());\n\nadd(\nCircleComponent(\nposition: canvasSize / 2,\nradius: 30,\npaint: paint,\nchildren: [CircleHitbox()],\n),\n);\n}\n\n@override\nvoid update(double dt) {\nsuper.update(dt);\nfinal ray = Ray2(\norigin: origin,\ndirection: direction,\n);\nresult = collisionDetection.raycast(ray);\n\norigin.y += velocity * dt;\n\nif (origin.y > canvasSize.y) {\norigin.y += resetPosition;\n}\n}\n\n@override\nvoid render(Canvas canvas) {\nsuper.render(canvas);\n\nif (result != null && result!.isActive) {\nfinal originOffset = origin.toOffset();\nfinal intersectionPoint = result!.intersectionPoint!.toOffset();\ncanvas.drawLine(\noriginOffset,\nintersectionPoint,\npaint,\n);\n\ncanvas.drawCircle(originOffset, 10, paint);\n}\n}\n}"}
{"prompt": "Show me how to implement Ray casting¶: Example: using Flutter Flame", "completion": "import 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/geometry.dart';\nimport 'package:flame/palette.dart';\nimport 'package:flutter/material.dart';\n\nclass RayCastExample extends FlameGame with HasCollisionDetection {\nfinal origin = Vector2(20, 20);\n\nfinal direction = Vector2(1, 0);\n\nfinal velocity = 60;\ndouble get resetPosition => -canvasSize.y;\n\nPaint paint = Paint()..color = Colors.red.withValues(alpha: 0.6);\n\nRaycastResult<ShapeHitbox>? result;\n\n@override\nFuture<void> onLoad() async {\nfinal paint = BasicPalette.gray.paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 2.0;\n\nadd(ScreenHitbox());\n\nadd(\nCircleComponent(\nposition: canvasSize / 2,\nradius: 30,\npaint: paint,\nchildren: [CircleHitbox()],\n),\n);\n}\n\n@override\nvoid update(double dt) {\nsuper.update(dt);\nfinal ray = Ray2(\norigin: origin,\ndirection: direction,\n);\nresult = collisionDetection.raycast(ray);\n\norigin.y += velocity * dt;\n\nif (origin.y > canvasSize.y) {\norigin.y += resetPosition;\n}\n}\n\n@override\nvoid render(Canvas canvas) {\nsuper.render(canvas);\n\nif (result != null && result!.isActive) {\nfinal originOffset = origin.toOffset();\nfinal intersectionPoint = result!.intersectionPoint!.toOffset();\ncanvas.drawLine(\noriginOffset,\nintersectionPoint,\npaint,\n);\n\ncanvas.drawCircle(originOffset, 10, paint);\n}\n}\n}"}
{"prompt": "Write Flutter Flame code to Ray casting¶: Example:", "completion": "import 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/geometry.dart';\nimport 'package:flame/palette.dart';\nimport 'package:flutter/material.dart';\n\nclass RayCastExample extends FlameGame with HasCollisionDetection {\nfinal origin = Vector2(20, 20);\n\nfinal direction = Vector2(1, 0);\n\nfinal velocity = 60;\ndouble get resetPosition => -canvasSize.y;\n\nPaint paint = Paint()..color = Colors.red.withValues(alpha: 0.6);\n\nRaycastResult<ShapeHitbox>? result;\n\n@override\nFuture<void> onLoad() async {\nfinal paint = BasicPalette.gray.paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 2.0;\n\nadd(ScreenHitbox());\n\nadd(\nCircleComponent(\nposition: canvasSize / 2,\nradius: 30,\npaint: paint,\nchildren: [CircleHitbox()],\n),\n);\n}\n\n@override\nvoid update(double dt) {\nsuper.update(dt);\nfinal ray = Ray2(\norigin: origin,\ndirection: direction,\n);\nresult = collisionDetection.raycast(ray);\n\norigin.y += velocity * dt;\n\nif (origin.y > canvasSize.y) {\norigin.y += resetPosition;\n}\n}\n\n@override\nvoid render(Canvas canvas) {\nsuper.render(canvas);\n\nif (result != null && result!.isActive) {\nfinal originOffset = origin.toOffset();\nfinal intersectionPoint = result!.intersectionPoint!.toOffset();\ncanvas.drawLine(\noriginOffset,\nintersectionPoint,\npaint,\n);\n\ncanvas.drawCircle(originOffset, 10, paint);\n}\n}\n}"}
{"prompt": "Create a Flutter Flame game component that Ray casting¶: Example:", "completion": "class MyGame extends FlameGame with HasCollisionDetection {\n  @override\n  void update(double dt) {\n    super.update(dt);\n    final ray = Ray2(\n        origin: Vector2(0, 100),\n        direction: Vector2(1, 0),\n    );\n    final result = collisionDetection.raycast(ray);\n  }\n}"}
{"prompt": "Show me how to implement Ray casting¶: Example: using Flutter Flame", "completion": "class MyGame extends FlameGame with HasCollisionDetection {\n  @override\n  void update(double dt) {\n    super.update(dt);\n    final ray = Ray2(\n        origin: Vector2(0, 100),\n        direction: Vector2(1, 0),\n    );\n    final result = collisionDetection.raycast(ray);\n  }\n}"}
{"prompt": "Write Flutter Flame code to Ray casting¶: Example:", "completion": "class MyGame extends FlameGame with HasCollisionDetection {\n  @override\n  void update(double dt) {\n    super.update(dt);\n    final ray = Ray2(\n        origin: Vector2(0, 100),\n        direction: Vector2(1, 0),\n    );\n    final result = collisionDetection.raycast(ray);\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Ray casting¶: Example:", "completion": "class MyGame extends FlameGame with HasCollisionDetection {\n  @override\n  void update(double dt) {\n    super.update(dt);\n    final origin = Vector2(200, 200);\n    final result = collisionDetection.raycastAll(\n      origin,\n      numberOfRays: 100,\n    );\n  }\n}"}
{"prompt": "Show me how to implement Ray casting¶: Example: using Flutter Flame", "completion": "class MyGame extends FlameGame with HasCollisionDetection {\n  @override\n  void update(double dt) {\n    super.update(dt);\n    final origin = Vector2(200, 200);\n    final result = collisionDetection.raycastAll(\n      origin,\n      numberOfRays: 100,\n    );\n  }\n}"}
{"prompt": "Write Flutter Flame code to Ray casting¶: Example:", "completion": "class MyGame extends FlameGame with HasCollisionDetection {\n  @override\n  void update(double dt) {\n    super.update(dt);\n    final origin = Vector2(200, 200);\n    final result = collisionDetection.raycastAll(\n      origin,\n      numberOfRays: 100,\n    );\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that Ray tracing¶: Example:", "completion": "import 'dart:math';\n\nimport 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/geometry.dart';\nimport 'package:flame/palette.dart';\nimport 'package:flutter/material.dart';\n\nclass RayTraceExample extends FlameGame\nwith HasCollisionDetection, TapDetector {\nPaint paint = Paint()..color = Colors.red.withValues(alpha: 0.6);\nbool isClicked = false;\n\nVector2 get origin => canvasSize / 2;\n\nRaycastResult<ShapeHitbox>? result;\n\nfinal Ray2 _ray = Ray2.zero();\n\nfinal boxPaint = BasicPalette.gray.paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 2.0;\n\nfinal List<RaycastResult<ShapeHitbox>> results = [];\n\n@override\nFuture<void> onLoad() async {\nadd(\nCircleComponent(\nradius: min(size.x, size.y) / 2,\npaint: boxPaint,\nchildren: [CircleHitbox()],\n),\n);\n}\n\nvar _timePassed = 0.0;\n\n@override\nvoid update(double dt) {\nsuper.update(dt);\nif (isClicked) {\n_timePassed += dt;\n}\n\nresult = collisionDetection.raycast(_ray);\n\n_ray.origin.setFrom(origin);\n_ray.direction\n..setValues(1, 1)\n..normalize();\ncollisionDetection\n.raytrace(\n_ray,\nmaxDepth: min((_timePassed * 8).ceil(), 1000),\nout: results,\n)\n.toList();\n}\n\n@override\nvoid render(Canvas canvas) {\nsuper.render(canvas);\nvar originOffset = origin.toOffset();\nfor (final result in results) {\nif (!result.isActive) {\ncontinue;\n}\nfinal intersectionPoint = result.intersectionPoint!.toOffset();\ncanvas.drawLine(\noriginOffset,\nintersectionPoint,\npaint,\n);\noriginOffset = intersectionPoint;\n}\n}\n\n@override\nvoid onTap() {\nsuper.onTap();\nif (!isClicked) {\nisClicked = true;\nreturn;\n}\n_timePassed = 0;\n}\n}"}
{"prompt": "Show me how to implement Ray tracing¶: Example: using Flutter Flame", "completion": "import 'dart:math';\n\nimport 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/geometry.dart';\nimport 'package:flame/palette.dart';\nimport 'package:flutter/material.dart';\n\nclass RayTraceExample extends FlameGame\nwith HasCollisionDetection, TapDetector {\nPaint paint = Paint()..color = Colors.red.withValues(alpha: 0.6);\nbool isClicked = false;\n\nVector2 get origin => canvasSize / 2;\n\nRaycastResult<ShapeHitbox>? result;\n\nfinal Ray2 _ray = Ray2.zero();\n\nfinal boxPaint = BasicPalette.gray.paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 2.0;\n\nfinal List<RaycastResult<ShapeHitbox>> results = [];\n\n@override\nFuture<void> onLoad() async {\nadd(\nCircleComponent(\nradius: min(size.x, size.y) / 2,\npaint: boxPaint,\nchildren: [CircleHitbox()],\n),\n);\n}\n\nvar _timePassed = 0.0;\n\n@override\nvoid update(double dt) {\nsuper.update(dt);\nif (isClicked) {\n_timePassed += dt;\n}\n\nresult = collisionDetection.raycast(_ray);\n\n_ray.origin.setFrom(origin);\n_ray.direction\n..setValues(1, 1)\n..normalize();\ncollisionDetection\n.raytrace(\n_ray,\nmaxDepth: min((_timePassed * 8).ceil(), 1000),\nout: results,\n)\n.toList();\n}\n\n@override\nvoid render(Canvas canvas) {\nsuper.render(canvas);\nvar originOffset = origin.toOffset();\nfor (final result in results) {\nif (!result.isActive) {\ncontinue;\n}\nfinal intersectionPoint = result.intersectionPoint!.toOffset();\ncanvas.drawLine(\noriginOffset,\nintersectionPoint,\npaint,\n);\noriginOffset = intersectionPoint;\n}\n}\n\n@override\nvoid onTap() {\nsuper.onTap();\nif (!isClicked) {\nisClicked = true;\nreturn;\n}\n_timePassed = 0;\n}\n}"}
{"prompt": "Write Flutter Flame code to Ray tracing¶: Example:", "completion": "import 'dart:math';\n\nimport 'package:flame/collisions.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame/game.dart';\nimport 'package:flame/geometry.dart';\nimport 'package:flame/palette.dart';\nimport 'package:flutter/material.dart';\n\nclass RayTraceExample extends FlameGame\nwith HasCollisionDetection, TapDetector {\nPaint paint = Paint()..color = Colors.red.withValues(alpha: 0.6);\nbool isClicked = false;\n\nVector2 get origin => canvasSize / 2;\n\nRaycastResult<ShapeHitbox>? result;\n\nfinal Ray2 _ray = Ray2.zero();\n\nfinal boxPaint = BasicPalette.gray.paint()\n..style = PaintingStyle.stroke\n..strokeWidth = 2.0;\n\nfinal List<RaycastResult<ShapeHitbox>> results = [];\n\n@override\nFuture<void> onLoad() async {\nadd(\nCircleComponent(\nradius: min(size.x, size.y) / 2,\npaint: boxPaint,\nchildren: [CircleHitbox()],\n),\n);\n}\n\nvar _timePassed = 0.0;\n\n@override\nvoid update(double dt) {\nsuper.update(dt);\nif (isClicked) {\n_timePassed += dt;\n}\n\nresult = collisionDetection.raycast(_ray);\n\n_ray.origin.setFrom(origin);\n_ray.direction\n..setValues(1, 1)\n..normalize();\ncollisionDetection\n.raytrace(\n_ray,\nmaxDepth: min((_timePassed * 8).ceil(), 1000),\nout: results,\n)\n.toList();\n}\n\n@override\nvoid render(Canvas canvas) {\nsuper.render(canvas);\nvar originOffset = origin.toOffset();\nfor (final result in results) {\nif (!result.isActive) {\ncontinue;\n}\nfinal intersectionPoint = result.intersectionPoint!.toOffset();\ncanvas.drawLine(\noriginOffset,\nintersectionPoint,\npaint,\n);\noriginOffset = intersectionPoint;\n}\n}\n\n@override\nvoid onTap() {\nsuper.onTap();\nif (!isClicked) {\nisClicked = true;\nreturn;\n}\n_timePassed = 0;\n}\n}"}
{"prompt": "Create a Flutter Flame game component that Ray tracing¶: Example:", "completion": "class MyGame extends FlameGame with HasCollisionDetection {\n  @override\n  void update(double dt) {\n    super.update(dt);\n    final ray = Ray2(\n        origin: Vector2(0, 100),\n        direction: Vector2(1, 1)..normalize()\n    );\n    final results = collisionDetection.raytrace(\n      ray,\n      maxDepth: 100,\n    );\n    for (final result in results) {\n      if (result.intersectionPoint.distanceTo(ray.origin) > 300) {\n        break;\n      }\n    }\n  }\n}"}
{"prompt": "Show me how to implement Ray tracing¶: Example: using Flutter Flame", "completion": "class MyGame extends FlameGame with HasCollisionDetection {\n  @override\n  void update(double dt) {\n    super.update(dt);\n    final ray = Ray2(\n        origin: Vector2(0, 100),\n        direction: Vector2(1, 1)..normalize()\n    );\n    final results = collisionDetection.raytrace(\n      ray,\n      maxDepth: 100,\n    );\n    for (final result in results) {\n      if (result.intersectionPoint.distanceTo(ray.origin) > 300) {\n        break;\n      }\n    }\n  }\n}"}
{"prompt": "Write Flutter Flame code to Ray tracing¶: Example:", "completion": "class MyGame extends FlameGame with HasCollisionDetection {\n  @override\n  void update(double dt) {\n    super.update(dt);\n    final ray = Ray2(\n        origin: Vector2(0, 100),\n        direction: Vector2(1, 1)..normalize()\n    );\n    final results = collisionDetection.raytrace(\n      ray,\n      maxDepth: 100,\n    );\n    for (final result in results) {\n      if (result.intersectionPoint.distanceTo(ray.origin) > 300) {\n        break;\n      }\n    }\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that mixin GameRef¶: The GameRef mixin allows a system to become aware of the OxygenGame instance its attached to. This allows easy access to the methods on the game class.", "completion": "class YourSystem extends System with GameRef<YourGame> {\n  @override\n  void init() {\n    // Access to game using the .game property\n  }\n\n  // ...\n}"}
{"prompt": "Show me how to implement mixin GameRef¶: The GameRef mixin allows a system to become aware of the OxygenGame instance its attached to. This allows easy access to the methods on the game class. using Flutter Flame", "completion": "class YourSystem extends System with GameRef<YourGame> {\n  @override\n  void init() {\n    // Access to game using the .game property\n  }\n\n  // ...\n}"}
{"prompt": "Write Flutter Flame code to mixin GameRef¶: The GameRef mixin allows a system to become aware of the OxygenGame instance its attached to. This allows easy access to the methods on the game class.", "completion": "class YourSystem extends System with GameRef<YourGame> {\n  @override\n  void init() {\n    // Access to game using the .game property\n  }\n\n  // ...\n}"}
{"prompt": "Create a Flutter Flame game component that BaseSystem¶: AngleComponent (optional, defaults to 0)", "completion": "class SimpleBaseSystem extends BaseSystem {\n  @override\n  List<Filter<Component>> get filters => [];\n\n  @override\n  void renderEntity(Canvas canvas, Entity entity) {\n    // The canvas is translated, rotated and fully prepared for rendering.\n  }\n}"}
{"prompt": "Show me how to implement BaseSystem¶: AngleComponent (optional, defaults to 0) using Flutter Flame", "completion": "class SimpleBaseSystem extends BaseSystem {\n  @override\n  List<Filter<Component>> get filters => [];\n\n  @override\n  void renderEntity(Canvas canvas, Entity entity) {\n    // The canvas is translated, rotated and fully prepared for rendering.\n  }\n}"}
{"prompt": "Write Flutter Flame code to BaseSystem¶: AngleComponent (optional, defaults to 0)", "completion": "class SimpleBaseSystem extends BaseSystem {\n  @override\n  List<Filter<Component>> get filters => [];\n\n  @override\n  void renderEntity(Canvas canvas, Entity entity) {\n    // The canvas is translated, rotated and fully prepared for rendering.\n  }\n}"}
{"prompt": "Create a Flutter Flame game component that ParticleSystem¶: Simply register the ParticleSystem and the ParticleComponent to your world like so:", "completion": "world.registerSystem(ParticleSystem());\n\nworld.registerComponent<ParticleComponent, Particle>(() => ParticleComponent);"}
{"prompt": "Show me how to implement ParticleSystem¶: Simply register the ParticleSystem and the ParticleComponent to your world like so: using Flutter Flame", "completion": "world.registerSystem(ParticleSystem());\n\nworld.registerComponent<ParticleComponent, Particle>(() => ParticleComponent);"}
{"prompt": "Write Flutter Flame code to ParticleSystem¶: Simply register the ParticleSystem and the ParticleComponent to your world like so:", "completion": "world.registerSystem(ParticleSystem());\n\nworld.registerComponent<ParticleComponent, Particle>(() => ParticleComponent);"}
