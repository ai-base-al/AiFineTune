[
  {
    "context": "ConstantVolumeJoint¶: It can for example be useful when simulating “soft-bodies”.",
    "code": "import 'dart:math';\n\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boundaries.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\n\nclass ConstantVolumeJointExample extends Forge2DGame {\nstatic const description = '''\nThis example shows how to use a `ConstantVolumeJoint`. Tap the screen to add\na bunch off balls, that maintain a constant volume within them.\n''';\n\nConstantVolumeJointExample() : super(world: SpriteBodyWorld());\n}\n\nclass SpriteBodyWorld extends Forge2DWorld\nwith TapCallbacks, HasGameReference<Forge2DGame> {\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\naddAll(createBoundaries(game));\n}\n\n@override\nFuture<void> onTapDown(TapDownEvent info) async {\nsuper.onTapDown(info);\nfinal center = info.localPosition;\n\nconst numPieces = 20;\nconst radius = 5.0;\nfinal balls = <Ball>[];\n\nfor (var i = 0; i < numPieces; i++) {\nfinal x = radius * cos(2 * pi * (i / numPieces));\nfinal y = radius * sin(2 * pi * (i / numPieces));\n\nfinal ball = Ball(Vector2(x + center.x, y + center.y), radius: 0.5);\n\nadd(ball);\nballs.add(ball);\n}\n\nawait Future.wait(balls.map((e) => e.loaded));\n\nfinal constantVolumeJoint = ConstantVolumeJointDef()\n..frequencyHz = 10\n..dampingRatio = 0.8;\n\nballs.forEach((ball) {\nconstantVolumeJoint.addBody(ball.body);\n});\n\ncreateJoint(\nConstantVolumeJoint(\nphysicsWorld,\nconstantVolumeJoint,\n),\n);\n}\n}"
  },
  {
    "context": "DistanceJoint¶: You can view this as a massless, rigid rod.",
    "code": "import 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boundaries.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\n\nclass DistanceJointExample extends Forge2DGame {\nstatic const description = '''\nThis example shows how to use a `DistanceJoint`. Tap the screen to add a\npair of balls joined with a `DistanceJoint`.\n''';\n\nDistanceJointExample() : super(world: DistanceJointWorld());\n}\n\nclass DistanceJointWorld extends Forge2DWorld\nwith TapCallbacks, HasGameReference<Forge2DGame> {\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\naddAll(createBoundaries(game));\n}\n\n@override\nFuture<void> onTapDown(TapDownEvent info) async {\nsuper.onTapDown(info);\nfinal tap = info.localPosition;\n\nfinal first = Ball(tap);\nfinal second = Ball(Vector2(tap.x + 3, tap.y + 3));\naddAll([first, second]);\n\nawait Future.wait([first.loaded, second.loaded]);\n\nfinal distanceJointDef = DistanceJointDef()\n..initialize(\nfirst.body,\nsecond.body,\nfirst.body.worldCenter,\nsecond.center,\n)\n..length = 10\n..frequencyHz = 3\n..dampingRatio = 0.2;\n\ncreateJoint(DistanceJoint(distanceJointDef));\n}\n}"
  },
  {
    "context": "FrictionJoint¶: The third parameter is the anchor point in the world coordinates where the friction force will be applied. In most cases, it would be the center of the first object. However, for more complex physics interactions between bodies, you can set the anchor point to a specific location on one or both of the bodies.",
    "code": "import 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boundaries.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\n\nclass FrictionJointExample extends Forge2DGame {\nstatic const description = '''\nThis example shows how to use a `FrictionJoint`. Tap the screen to move the\nball around and observe it slows down due to the friction force.\n''';\n\nFrictionJointExample()\n: super(gravity: Vector2.all(0), world: FrictionJointWorld());\n}\n\nclass FrictionJointWorld extends Forge2DWorld\nwith TapCallbacks, HasGameReference<Forge2DGame> {\nlate Wall border;\nlate Ball ball;\n\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\nfinal boundaries = createBoundaries(game);\nborder = boundaries.first;\naddAll(boundaries);\n\nball = Ball(Vector2.zero(), radius: 3);\nadd(ball);\n\nawait Future.wait([ball.loaded, border.loaded]);\n\ncreateFrictionJoint(ball.body, border.body);\n}\n\n@override\nFuture<void> onTapDown(TapDownEvent info) async {\nsuper.onTapDown(info);\nball.body.applyLinearImpulse(Vector2.random() * 5000);\n}\n\nvoid createFrictionJoint(Body first, Body second) {\nfinal frictionJointDef = FrictionJointDef()\n..initialize(first, second, first.worldCenter)\n..collideConnected = true\n..maxForce = 500\n..maxTorque = 500;\n\ncreateJoint(FrictionJoint(frictionJointDef));\n}\n}"
  },
  {
    "context": "GearJoint¶: The connected joints must attach a dynamic body to a static body. The static body is expected to be a bodyA on those joints",
    "code": "import 'dart:ui';\n\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boxes.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\n\nclass GearJointExample extends Forge2DGame {\nstatic const description = '''\nThis example shows how to use a `GearJoint`.\n\nDrag the box along the specified axis and observe gears respond to the\ntranslation.\n''';\n\nGearJointExample() : super(world: GearJointWorld());\n}\n\nclass GearJointWorld extends Forge2DWorld with HasGameReference<Forge2DGame> {\nlate PrismaticJoint prismaticJoint;\nVector2 boxAnchor = Vector2.zero();\n\ndouble boxWidth = 2;\ndouble ball1Radius = 4;\ndouble ball2Radius = 2;\n\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\n\nfinal box =\nDraggableBox(startPosition: boxAnchor, width: boxWidth, height: 20);\nadd(box);\n\nfinal ball1Anchor = boxAnchor - Vector2(boxWidth / 2 + ball1Radius, 0);\nfinal ball1 = Ball(ball1Anchor, radius: ball1Radius);\nadd(ball1);\n\nfinal ball2Anchor = ball1Anchor - Vector2(ball1Radius + ball2Radius, 0);\nfinal ball2 = Ball(ball2Anchor, radius: ball2Radius);\nadd(ball2);\n\nawait Future.wait([box.loaded, ball1.loaded, ball2.loaded]);\n\nprismaticJoint = createPrismaticJoint(box.body, boxAnchor);\nfinal revoluteJoint1 = createRevoluteJoint(ball1.body, ball1Anchor);\nfinal revoluteJoint2 = createRevoluteJoint(ball2.body, ball2Anchor);\n\ncreateGearJoint(prismaticJoint, revoluteJoint1, 1);\ncreateGearJoint(revoluteJoint1, revoluteJoint2, 0.5);\nadd(JointRenderer(joint: prismaticJoint, anchor: boxAnchor));\n}\n\nPrismaticJoint createPrismaticJoint(Body box, Vector2 anchor) {\nfinal groundBody = createBody(BodyDef());\n\nfinal prismaticJointDef = PrismaticJointDef()\n..initialize(\ngroundBody,\nbox,\nanchor,\nVector2(0, 1),\n)\n..enableLimit = true\n..lowerTranslation = -10\n..upperTranslation = 10;\n\nfinal joint = PrismaticJoint(prismaticJointDef);\ncreateJoint(joint);\nreturn joint;\n}\n\nRevoluteJoint createRevoluteJoint(Body ball, Vector2 anchor) {\nfinal groundBody = createBody(BodyDef());\n\nfinal revoluteJointDef = RevoluteJointDef()\n..initialize(\ngroundBody,\nball,\nanchor,\n);\n\nfinal joint = RevoluteJoint(revoluteJointDef);\ncreateJoint(joint);\nreturn joint;\n}\n\nvoid createGearJoint(Joint first, Joint second, double gearRatio) {\nfinal gearJointDef = GearJointDef()\n..bodyA = first.bodyA\n..bodyB = second.bodyA\n..joint1 = first\n..joint2 = second\n..ratio = gearRatio;\n\nfinal joint = GearJoint(gearJointDef);\ncreateJoint(joint);\n}\n}\n\nclass JointRenderer extends Component {\nJointRenderer({required this.joint, required this.anchor});\n\nfinal PrismaticJoint joint;\nfinal Vector2 anchor;\nfinal Vector2 p1 = Vector2.zero();\nfinal Vector2 p2 = Vector2.zero();\n\n@override\nvoid render(Canvas canvas) {\np1\n..setFrom(joint.getLocalAxisA())\n..scale(joint.getLowerLimit())\n..add(anchor);\np2\n..setFrom(joint.getLocalAxisA())\n..scale(joint.getUpperLimit())\n..add(anchor);\n\ncanvas.drawLine(p1.toOffset(), p2.toOffset(), debugPaint);\n}\n}"
  },
  {
    "context": "MotorJoint¶: A MotorJoint lets you control the motion of a body by specifying target position and rotation offsets. You can set the maximum motor force and torque that will be applied to reach the target position and rotation. If the body is blocked, it will stop and the contact forces will be proportional the maximum motor force and torque.",
    "code": "import 'dart:ui';\n\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/balls.dart';\nimport 'package:examples/stories/bridge_libraries/flame_forge2d/utils/boxes.dart';\nimport 'package:flame/components.dart';\nimport 'package:flame/events.dart';\nimport 'package:flame_forge2d/flame_forge2d.dart';\n\nclass MotorJointExample extends Forge2DGame {\nstatic const description = '''\nThis example shows how to use a `MotorJoint`. The ball spins around the\ncenter point. Tap the screen to change the direction.\n''';\n\nMotorJointExample()\n: super(gravity: Vector2.zero(), world: MotorJointWorld());\n}\n\nclass MotorJointWorld extends Forge2DWorld with TapCallbacks {\nlate Ball ball;\nlate MotorJoint joint;\nfinal motorSpeed = 1;\n\nbool clockWise = true;\n\n@override\nFuture<void> onLoad() async {\nsuper.onLoad();\n\nfinal box = Box(\nstartPosition: Vector2.zero(),\nwidth: 2,\nheight: 1,\nbodyType: BodyType.static,\n);\nadd(box);\n\nball = Ball(Vector2(0, -5));\nadd(ball);\n\nawait Future.wait([ball.loaded, box.loaded]);\n\njoint = createMotorJoint(ball.body, box.body);\nadd(JointRenderer(joint: joint));\n}\n\n@override\nvoid onTapDown(TapDownEvent info) {\nsuper.onTapDown(info);\nclockWise = !clockWise;\n}\n\nMotorJoint createMotorJoint(Body first, Body second) {\nfinal motorJointDef = MotorJointDef()\n..initialize(first, second)\n..maxForce = 1000\n..maxTorque = 1000\n..correctionFactor = 0.1;\n\nfinal joint = MotorJoint(motorJointDef);\ncreateJoint(joint);\nreturn joint;\n}\n\nfinal linearOffset = Vector2.zero();\n\n@override\nvoid update(double dt) {\nsuper.update(dt);\n\nvar deltaOffset = motorSpeed * dt;\nif (clockWise) {\ndeltaOffset = -deltaOffset;\n}\n\nfinal linearOffsetX = joint.getLinearOffset().x + deltaOffset;\nfinal linearOffsetY = joint.getLinearOffset().y + deltaOffset;\nlinearOffset.setValues(linearOffsetX, linearOffsetY);\nfinal angularOffset = joint.getAngularOffset() + deltaOffset;\n\njoint.setLinearOffset(linearOffset);\njoint.setAngularOffset(angularOffset);\n}\n}\n\nclass JointRenderer extends Component {\nJointRenderer({required this.joint});\n\nfinal MotorJoint joint;\n\n@override\nvoid render(Canvas canvas) {\ncanvas.drawLine(\njoint.anchorA.toOffset(),\njoint.anchorB.toOffset(),\ndebugPaint,\n);\n}\n}"
  }
]